#!/usr/bin/env node

exports.id = 459;
exports.ids = [459];
exports.modules = {

/***/ 34514:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 34514;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 622219:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 622219;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 507745:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 507745;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 645982:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 645982;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 160627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(655674);
const del = __webpack_require__(935163);
const WorkflowCompile = __webpack_require__(577135);
const BuildError = __webpack_require__(142863);
const {spawn} = __webpack_require__(532081);
const spawnargs = __webpack_require__(372255);
const _ = __webpack_require__(496486);
const expect = __webpack_require__(414096);

function CommandBuilder(command) {
  this.command = command;
}

CommandBuilder.prototype.build = function (options, callback) {
  console.log("Running `" + this.command + "`...");

  const args = spawnargs(this.command);
  const ps = args.shift();

  const cmd = spawn(ps, args, {
    detached: false,
    cwd: options.working_directory,
    env: _.merge(process.env, {
      WORKING_DIRECTORY: options.working_directory,
      BUILD_DESTINATION_DIRECTORY: options.destination_directory,
      BUILD_CONTRACTS_DIRECTORY: options.contracts_build_directory
    })
  });

  cmd.stdout.on("data", function (data) {
    console.log(data.toString());
  });

  cmd.stderr.on("data", function (data) {
    console.error(data);
  });

  cmd.on("close", function (code) {
    let error = null;
    if (code !== 0) {
      error = "Command exited with code " + code;
    }
    callback(error);
  });
};

const Build = {
  clean: async function (options) {
    const destination = options.build_directory;
    const contracts_build_directory = options.contracts_build_directory;

    // Clean first.
    await del([destination + "/*", "!" + contracts_build_directory]);
    fse.ensureDirSync(destination);
  },

  build: async function (options) {
    expect.options(options, [
      "build_directory",
      "working_directory",
      "contracts_build_directory",
      "networks"
    ]);

    const logger = options.logger || console;
    let builder = options.build;

    // Duplicate build directory for legacy purposes
    options.destination_directory = options.build_directory;

    if (builder === null || typeof builder === "undefined") {
      logger.log(
        "No build configuration found. Preparing to compile contracts."
      );
    } else if (typeof builder === "string") {
      builder = new CommandBuilder(builder);
    } else if (typeof builder === "function") {
      // If they've only provided a build function, use that.
      builder = { build: builder };
    } else if (builder.build == null) {
      throw new BuildError(
        "Build configuration can no longer be specified as an object. Please see our documentation for an updated list of supported build configurations."
      );
    }

    // Use our own clean method unless the builder supplies one.
    let clean = this.clean;
    if (builder && builder.hasOwnProperty("clean")) {
      clean = builder.clean;
    }

    await clean(options);

    // If necessary. This prevents errors due to the .sol.js files not existing.
    await WorkflowCompile.compileAndSave(options);
    if (builder) {
      builder.build(options, function (err) {
        if (typeof err === "string") {
          throw new BuildError(err);
        }
      });
    }
  }
};

module.exports = Build;


/***/ }),

/***/ 789664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);

const templates = {
  test: {
    filename: path.join(__dirname, "templates", "example.js"),
    variable: "example"
  },
  contract: {
    filename: path.join(__dirname, "templates", "Example.sol"),
    name: "Example",
    license: "MIT",
    variable: "example"
  },
  migration: {
    filename: path.join(__dirname, "templates", "migration.js")
  }
};

const replaceContents = (filePath, find, replacement) => {
  const data = fse.readFileSync(filePath, { encoding: "utf8" });
  if (typeof find === "string") {
    find = new RegExp(find, "g");
  }
  const result = data.replace(find, replacement);
  fse.writeFileSync(filePath, result, { encoding: "utf8" });
};

const toUnderscoreFromCamel = (string) => {
  string = string.replace(/([A-Z])/g, function ($1) {
    return "_" + $1.toLowerCase();
  });

  if (string[0] === "_") {
    string = string.substring(1);
  }

  return string;
};

// getLicense return the license property value from Truffle config first and
// in case that the file doesn't exist it will fallback to package.json
const getLicense = (options) => {
  try {
    if ((license = (__webpack_require__(120553).detect)(options).license)) {
      return license;
    }
  } catch (err) {
    console.log(err);
  }

  try {
    return __webpack_require__(876775)(path.join(process.cwd(), "package.json")).license;
  } catch {}
}

const Create = {
  contract: function (directory, name, options) {
    const from = templates.contract.filename;
    const to = path.join(directory, name + ".sol");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + name + ".sol: file exists");
    }

    fse.copySync(from, to);

    replaceContents(to, templates.contract.name, name);
    if ((license = getLicense(options))) {
      replaceContents(to, templates.contract.license, license);
    }
  },

  test: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name);
    underscored = underscored.replace(/\./g, "_");
    const from = templates.test.filename;
    const to = path.join(directory, underscored + ".js");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + underscored + ".js: file exists");
    }

    fse.copySync(from, to);
    replaceContents(to, templates.contract.name, name);
    replaceContents(to, templates.contract.variable, underscored);
  },

  migration: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name || "");
    underscored = underscored.replace(/\./g, "_");
    const from = templates.migration.filename;
    let filename = (new Date().getTime() / 1000) | 0; // Only do seconds.

    if (name != null && name !== "") {
      filename += "_" + underscored;
    }

    filename += ".js";
    const to = path.join(directory, filename);

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + filename + ": file exists");
    }
    fse.copySync(from, to);
  }
};

module.exports = Create;


/***/ }),

/***/ 900458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:cli");

const fs = __webpack_require__(655674);
const path = __webpack_require__(371017);

const Debugger = __webpack_require__(692851);
const DebugUtils = __webpack_require__(93293);
const Codec = __webpack_require__(20102);
const { fetchAndCompileForDebugger } = __webpack_require__(705523);

const { DebugInterpreter } = __webpack_require__(779311);
const { DebugCompiler } = __webpack_require__(455887);

const Spinner = (__webpack_require__(92189).Spinner);

class CLIDebugger {
  constructor(config, { compilations, txHash } = {}) {
    this.config = config;
    this.compilations = compilations;
    this.txHash = txHash;
  }

  async run() {
    this.config.logger.log("Starting Truffle Debugger...");

    const session = await this.connect();

    // initialize prompt/breakpoints/ui logic
    const interpreter = await this.buildInterpreter(session);

    return interpreter;
  }

  async connect() {
    // get compilations (either by shimming compiled artifacts,
    // or by doing a recompile)
    const compilations = this.compilations || (await this.getCompilations());

    // invoke @truffle/debugger
    const session = await this.startDebugger(compilations);

    return session;
  }

  async fetchExternalSources(bugger) {
    const fetchSpinner = new Spinner(
      "core:debug:cli:fetch",
      "Getting and compiling external sources..."
    );
    const {
      fetch: badAddresses,
      fetchers: badFetchers,
      compile: badCompilationAddresses
    } = await fetchAndCompileForDebugger(bugger, this.config); //Note: mutates bugger!!
    if (
      badAddresses.length === 0 &&
      badFetchers.length === 0 &&
      badCompilationAddresses.length === 0
    ) {
      fetchSpinner.succeed();
    } else {
      let warningStrings = [];
      if (badFetchers.length > 0) {
        warningStrings.push(
          `Errors occurred connecting to ${badFetchers.join(", ")}.`
        );
      }
      if (badAddresses.length > 0) {
        warningStrings.push(
          `Errors occurred while getting sources for addresses ${badAddresses.join(
            ", "
          )}.`
        );
      }
      if (badCompilationAddresses.length > 0) {
        warningStrings.push(
          `Errors occurred while compiling sources for addresses ${badCompilationAddresses.join(
            ", "
          )}.`
        );
      }
      // simulate ora's "warn" feature
      fetchSpinner.warn(warningStrings.join("  "));
    }
  }

  async getCompilations() {
    //if compileNone is true and configFileSkiped
    //we understand that user is debugging using --url and does not have a config file
    //so instead of resolving compilations, we return an empty value
    if (this.config.compileNone && this.config.configFileSkipped) {
      return [];
    }

    let artifacts;
    artifacts = await this.gatherArtifacts();
    if ((artifacts && !this.config.compileAll) || this.config.compileNone) {
      let shimmedCompilations =
        Codec.Compilations.Utils.shimArtifacts(artifacts);
      //if they were compiled simultaneously, yay, we can use it!
      //(or if we *force* it to...)
      if (
        this.config.compileNone ||
        shimmedCompilations.every(DebugUtils.isUsableCompilation)
      ) {
        debug("shimmed compilations usable");
        return shimmedCompilations;
      }
      debug("shimmed compilations unusable");
    }
    //if not, or if build directory doesn't exist, we have to recompile
    return await this.compileSources();
  }

  async compileSources() {
    const compileSpinner = new Spinner(
      "core:debug:cli:compile",
      "Compiling your contracts..."
    );

    const compilationResult = await new DebugCompiler(this.config).compile({
      withTests: this.config.compileTests
    });
    debug("compilationResult: %O", compilationResult);

    compileSpinner.succeed();

    return Codec.Compilations.Utils.shimCompilations(compilationResult);
  }

  async startDebugger(compilations) {
    const startMessage = DebugUtils.formatStartMessage(
      this.txHash !== undefined
    );
    let bugger;
    if (!this.config.fetchExternal) {
      //ordinary case, not doing fetch-external
      const startSpinner = new Spinner("core:debug:cli:start", startMessage);
      bugger = await Debugger.forProject({
        provider: this.config.provider,
        compilations
      });
      if (this.txHash !== undefined) {
        try {
          debug("loading %s", this.txHash);
          await bugger.load(this.txHash);
          startSpinner.succeed();
        } catch (_) {
          debug("loading error");
          startSpinner.fail();
          //just start up unloaded
        }
      } else {
        startSpinner.succeed();
      }
    } else {
      //fetch-external case
      //note that in this case we start in light mode
      //and only wake up to full mode later!
      //also, in this case, we can be sure that txHash is defined
      bugger = await Debugger.forTx(this.txHash, {
        provider: this.config.provider,
        compilations,
        lightMode: true
      }); //note: may throw!
      await this.fetchExternalSources(bugger); //note: mutates bugger!
      const startSpinner = new Spinner("core:debug:cli:start", startMessage);
      await bugger.startFullMode();
      //I'm removing the failure check here because I don't think that can
      //actually happen
      startSpinner.succeed();
    }
    return bugger;
  }

  async buildInterpreter(session) {
    return new DebugInterpreter(this.config, session, this.txHash);
  }

  async gatherArtifacts() {
    // Gather all available contract artifacts
    // if build directory doesn't exist, return undefined to signal that
    // a recompile is necessary
    if (!fs.existsSync(this.config.contracts_build_directory)) {
      return undefined;
    }
    const files = fs.readdirSync(this.config.contracts_build_directory);

    let contracts = files
      .filter(filePath => {
        return path.extname(filePath) === ".json";
      })
      .map(filePath => {
        return path.basename(filePath, ".json");
      })
      .map(contractName => {
        return this.config.resolver.require(contractName);
      });

    await Promise.all(
      contracts.map(abstraction => abstraction.detectNetwork())
    );

    return contracts;
  }
}

module.exports = {
  CLIDebugger
};


/***/ }),

/***/ 455887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const WorkflowCompile = __webpack_require__(577135);
const { Resolver } = __webpack_require__(648511);
const glob = __webpack_require__(312884);
const path = __webpack_require__(371017);

class DebugCompiler {
  constructor(config) {
    this.config = config;
  }

  async compile({ withTests }) {
    let compileConfig = this.config.with({ quiet: true });

    if (withTests) {
      const testResolver = new Resolver(this.config, {
        includeTruffleSources: true
      });
      const testFiles = glob
        .sync(`${this.config.test_directory}/**/*.sol`)
        .map(filePath => path.resolve(filePath));
      compileConfig = compileConfig.with({
        resolver: testResolver,
        //note we only need to pass *additional* files
        files: testFiles
      });
    }

    const { compilations } = await WorkflowCompile.compile(
      compileConfig.with({ all: true })
    );

    return compilations;
  }
}

module.exports = {
  DebugCompiler
};


/***/ }),

/***/ 779311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:interpreter");

const path = __webpack_require__(371017);
const util = __webpack_require__(473837);

const DebugUtils = __webpack_require__(93293);
const selectors = (__webpack_require__(692851).selectors);
const { session, sourcemapping, stacktrace, trace, evm, controller } =
  selectors;

const analytics = __webpack_require__(795614);
const repl = __webpack_require__(438102);

const { DebugPrinter } = __webpack_require__(429099);

const Spinner = (__webpack_require__(92189).Spinner);

function watchExpressionAnalytics(raw) {
  if (raw.includes("!<")) {
    //don't send analytics for watch expressions involving selectors
    return;
  }
  let expression = raw.trim();
  //legal Solidity identifiers (= legal JS identifiers)
  let identifierRegex = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  let isVariable = expression.match(identifierRegex) !== null;
  analytics.send({
    command: "debug: watch expression",
    args: { isVariable }
  });
}

class DebugInterpreter {
  constructor(config, session, txHash) {
    this.session = session;
    this.network = config.network;
    this.fetchExternal = config.fetchExternal;
    this.printer = new DebugPrinter(config, session);
    this.txHash = txHash;
    this.lastCommand = "n";
    this.enabledExpressions = new Set();
    this.repl = null;
  }

  async setOrClearBreakpoint(args, setOrClear) {
    const breakpoints = this.determineBreakpoints(args); //note: not pure, can print
    if (breakpoints !== null) {
      for (const breakpoint of breakpoints) {
        await this.setOrClearBreakpointObject(breakpoint, setOrClear);
      }
    } else {
      //null is a special value representing all, we'll handle it separately
      if (setOrClear) {
        // only "B all" is legal, not "b all"
        this.printer.print("Cannot add breakpoint everywhere.");
      } else {
        await this.session.removeAllBreakpoints();
        this.printer.print("Removed all breakpoints.");
      }
    }
  }

  //NOTE: not pure, also prints!
  //returns an array of the breakpoints, unless it's remove all breakpoints,
  //in which case it returns null
  //(if something goes wrong it will return [] to indicate do nothing)
  determineBreakpoints(args) {
    const currentLocation = this.session.view(controller.current.location);

    const currentStart = currentLocation.sourceRange
      ? currentLocation.sourceRange.start
      : null;
    const currentLength = currentLocation.sourceRange
      ? currentLocation.sourceRange.length
      : null;
    const currentSourceId = currentLocation.source
      ? currentLocation.source.id
      : null;
    const currentLine =
      currentSourceId !== null && currentSourceId !== undefined
        ? //sourceRange is never null, so we go by whether currentSourceId is null/undefined
          currentLocation.sourceRange.lines.start.line
        : null;

    if (args.length === 0) {
      //no arguments, want currrent node
      debug("node case");
      if (currentSourceId === null) {
        this.printer.print("Cannot determine current location.");
        return [];
      }
      return [
        {
          start: currentStart,
          line: currentLine, //this isn't necessary for the
          //breakpoint to work, but we use it for printing messages
          length: currentLength,
          sourceId: currentSourceId
        }
      ];
    }

    //the special case of "B all"
    else if (args[0] === "all") {
      return null;
    }

    //if the argument starts with a "+" or "-", we have a relative
    //line number
    else if (args[0][0] === "+" || args[0][0] === "-") {
      debug("relative case");
      if (currentLine === null) {
        this.printer.print("Cannot determine current location.");
        return [];
      }
      let delta = parseInt(args[0], 10); //want an integer
      debug("delta %d", delta);

      if (isNaN(delta)) {
        this.printer.print("Offset must be an integer.");
        return [];
      }

      return [
        {
          sourceId: currentSourceId,
          line: currentLine + delta
        }
      ];
    }

    //if it contains a colon, it's in the form source:line
    else if (args[0].includes(":")) {
      debug("source case");
      let sourceArgs = args[0].split(":");
      let sourceArg = sourceArgs[0];
      let lineArg = sourceArgs[1];
      debug("sourceArgs %O", sourceArgs);

      //first let's get the line number as usual
      let line = parseInt(lineArg, 10); //want an integer
      if (isNaN(line)) {
        this.printer.print("Line number must be an integer.");
        return [];
      }

      //search sources for given string
      let sources = Object.values(
        this.session.view(sourcemapping.views.sources)
      );
      //we will indeed need the sources here, not just IDs
      let matchingSources = sources.filter(source =>
        source.sourcePath.includes(sourceArg)
      );

      if (matchingSources.length === 0) {
        this.printer.print(`No source file found matching ${sourceArg}.`);
        return [];
      } else if (matchingSources.length > 1) {
        //normally if there's multiple matching sources, we want to return no
        //breakpoint and print a disambiguation prompt.
        //however, if one of them has a source path that is a substring of all
        //the others...
        if (
          matchingSources.some(shortSource =>
            matchingSources.every(
              source =>
                typeof source.sourcePath !== "string" || //just ignore these I guess?
                source.sourcePath.includes(shortSource.sourcePath)
            )
          )
        ) {
          //exceptional case
          this.printer.print(
            `WARNING: Acting on all matching sources because disambiguation between them is not possible.`
          );
          return matchingSources.map(source => ({
            sourceId: source.id,
            line: line - 1 //adjust for breakpoint!
          }));
        } else {
          //normal case
          this.printer.print(
            `Multiple source files found matching ${sourceArg}.  Which did you mean?`
          );
          matchingSources.forEach(source =>
            this.printer.print(source.sourcePath)
          );
          this.printer.print("");
          return [];
        }
      }

      //otherwise, we found it!
      return [
        {
          sourceId: matchingSources[0].id,
          line: line - 1 //adjust for zero-indexing!
        }
      ];
    }

    //otherwise, it's a simple line number
    else {
      debug("absolute case");
      if (currentSourceId === null || currentSourceId === undefined) {
        this.printer.print("Cannot determine current file.");
        return [];
      }
      let line = parseInt(args[0], 10); //want an integer
      debug("line %d", line);

      if (isNaN(line)) {
        this.printer.print("Line number must be an integer.");
        return [];
      }

      return [
        {
          sourceId: currentSourceId,
          line: line - 1 //adjust for zero-indexing!
        }
      ];
    }
  }

  //note: also prints!
  async setOrClearBreakpointObject(breakpoint, setOrClear) {
    const existingBreakpoints = this.session.view(controller.breakpoints);
    //OK, we've constructed the breakpoint!  But if we're adding, we'll
    //want to adjust to make sure we don't set it on an empty line or
    //anything like that
    if (setOrClear) {
      let resolver = this.session.view(controller.breakpoints.resolver);
      breakpoint = resolver(breakpoint);
      //of course, this might result in finding that there's nowhere to
      //add it after that point
      if (breakpoint === null) {
        this.printer.print(
          "Nowhere to add breakpoint at or beyond that location."
        );
        return;
      }
    }

    const currentSource = this.session.view(controller.current.location.source);
    const currentSourceId = currentSource ? currentSource.id : null;

    //having constructed and adjusted breakpoint, here's now a
    //user-readable message describing its location
    let sources = this.session.view(sourcemapping.views.sources);
    let sourceNames = Object.assign(
      //note: only include user sources
      {},
      ...Object.entries(sources).map(([id, source]) => ({
        [id]: path.basename(source.sourcePath)
      }))
    );
    let locationMessage = DebugUtils.formatBreakpointLocation(
      breakpoint,
      true, //only relevant for node-based breakpoints
      currentSourceId,
      sourceNames
    );

    //one last check -- does this breakpoint already exist?
    let alreadyExists =
      existingBreakpoints.filter(
        existingBreakpoint =>
          existingBreakpoint.sourceId === breakpoint.sourceId &&
          existingBreakpoint.line === breakpoint.line &&
          existingBreakpoint.node === breakpoint.node //may be undefined
      ).length > 0;

    //NOTE: in the "set breakpoint" case, the above check is somewhat
    //redundant, as we're going to check again when we actually make the
    //call to add or remove the breakpoint!  But we need to check here so
    //that we can display the appropriate message.  Hopefully we can find
    //some way to avoid this redundant check in the future.

    //if it already exists and is being set, or doesn't and is being
    //cleared, report back that we can't do that
    if (setOrClear === alreadyExists) {
      if (setOrClear) {
        this.printer.print(`Breakpoint at ${locationMessage} already exists.`);
        return;
      } else {
        this.printer.print(`No breakpoint at ${locationMessage} to remove.`);
        return;
      }
    }

    //finally, if we've reached this point, do it!
    //also report back to the user on what happened
    if (setOrClear) {
      await this.session.addBreakpoint(breakpoint);
      this.printer.print(`Breakpoint added at ${locationMessage}.`);
    } else {
      await this.session.removeBreakpoint(breakpoint);
      this.printer.print(`Breakpoint removed at ${locationMessage}.`);
    }
  }

  start(terminate) {
    // if terminate is not passed, return a Promise instead
    if (terminate === undefined) {
      return util.promisify(this.start.bind(this))();
    }

    if (this.session.view(session.status.loaded)) {
      debug("loaded");
      this.printer.printSessionLoaded();
    } else if (this.session.view(session.status.isError)) {
      debug("error!");
      this.printer.printSessionError();
    } else {
      debug("didn't attempt a load");
      this.printer.printHelp();
    }

    const prompt = this.session.view(session.status.loaded)
      ? DebugUtils.formatPrompt(this.network, this.txHash)
      : DebugUtils.formatPrompt(this.network);

    this.repl = repl.start({
      prompt: prompt,
      eval: util.callbackify(this.interpreter.bind(this)),
      ignoreUndefined: true,
      done: terminate
    });
  }

  async interpreter(cmd) {
    cmd = cmd.trim();
    let cmdArgs, splitArgs;
    debug("cmd %s", cmd);

    if (cmd === ".exit") {
      cmd = "q";
    }

    //split arguments for commands that want that; split on runs of spaces
    splitArgs = cmd.trim().split(/ +/).slice(1);
    debug("splitArgs %O", splitArgs);

    //warning: this bit *alters* cmd!
    if (cmd.length > 0) {
      cmdArgs = cmd.slice(1).trim();
      cmd = cmd[0];
    }

    if (cmd === "") {
      cmd = this.lastCommand;
      cmdArgs = "";
      splitArgs = [];
    }

    //quit if that's what we were given
    if (cmd === "q") {
      process.exit();
    }

    let alreadyFinished = this.session.view(trace.finishedOrUnloaded);
    let loadFailed = false;

    // If not finished, perform commands that require state changes
    // (other than quitting or resetting)
    if (!alreadyFinished) {
      const stepSpinner = new Spinner(
        "core:debug:interpreter:step",
        "Stepping..."
      );
      switch (cmd) {
        case "o":
          await this.session.stepOver();
          break;
        case "i":
          await this.session.stepInto();
          break;
        case "u":
          await this.session.stepOut();
          break;
        case "n":
          await this.session.stepNext();
          break;
        case ";":
          //two cases -- parameterized and unparameterized
          if (cmdArgs !== "") {
            let count = parseInt(cmdArgs, 10);
            debug("cmdArgs=%s", cmdArgs);
            if (isNaN(count)) {
              this.printer.print("Number of steps must be an integer.");
              break;
            }
            await this.session.advance(count);
          } else {
            await this.session.advance();
          }
          break;
        case "c":
          await this.session.continueUntilBreakpoint();
          break;
      }
      stepSpinner.remove();
    } //otherwise, inform the user we can't do that
    else {
      switch (cmd) {
        case "o":
        case "i":
        case "u":
        case "n":
        case "c":
        case ";":
          //are we "finished" because we've reached the end, or because
          //nothing is loaded?
          if (this.session.view(session.status.loaded)) {
            this.printer.print("Transaction has halted; cannot advance.");
            this.printer.print("");
          } else {
            this.printer.print("No transaction loaded.");
            this.printer.print("");
          }
      }
    }
    if (cmd === "r") {
      //reset if given the reset command
      //(but not if nothing is loaded)
      if (this.session.view(session.status.loaded)) {
        await this.session.reset();
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "y") {
      if (this.session.view(session.status.loaded)) {
        if (this.session.view(trace.finished)) {
          if (!this.session.view(evm.current.step.isExceptionalHalting)) {
            const errorIndex = this.session.view(
              stacktrace.current.innerErrorIndex
            );
            if (errorIndex !== null) {
              const stepSpinner = new Spinner(
                "core:debug:interpreter:step",
                "Stepping..."
              );
              await this.session.reset();
              await this.session.advance(errorIndex);
              stepSpinner.remove();
            } else {
              this.printer.print("No error to return to.");
            }
          } else {
            this.printer.print("You are already at the final error.");
            this.printer.print(
              "Use the `Y` command to return to the previous error."
            );
            this.printer.print("");
          }
        } else {
          this.printer.print(
            "This command is only usable at end of transaction; did you mean `Y`?"
          );
        }
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "Y") {
      if (this.session.view(session.status.loaded)) {
        const errorIndex = this.session.view(
          stacktrace.current.innerErrorIndex
        );
        if (errorIndex !== null) {
          const stepSpinner = new Spinner(
            "core:debug:interpreter:step",
            "Stepping..."
          );
          await this.session.reset();
          await this.session.advance(errorIndex);
          stepSpinner.remove();
        } else {
          this.printer.print("No previous error to return to.");
        }
      } else {
        this.printer.print("No transaction loaded.");
        this.printer.print("");
      }
    }
    if (cmd === "t") {
      if (!this.fetchExternal) {
        if (!this.session.view(session.status.loaded)) {
          const txSpinner = new Spinner(
            "core:debug:interpreter:step",
            DebugUtils.formatTransactionStartMessage()
          );
          try {
            await this.session.load(cmdArgs);
            txSpinner.succeed();
            this.repl.setPrompt(DebugUtils.formatPrompt(this.network, cmdArgs));
          } catch (_) {
            txSpinner.fail();
            loadFailed = true;
          }
        } else {
          loadFailed = true;
          this.printer.print(
            "Please unload the current transaction before loading a new one."
          );
        }
      } else {
        loadFailed = true;
        this.printer.print(
          "Cannot change transactions in fetch-external mode.  Please quit and restart the debugger instead."
        );
      }
    }
    if (cmd === "T") {
      if (!this.fetchExternal) {
        if (this.session.view(session.status.loaded)) {
          await this.session.unload();
          this.printer.print("Transaction unloaded.");
          this.repl.setPrompt(DebugUtils.formatPrompt(this.network));
        } else {
          this.printer.print("No transaction to unload.");
          this.printer.print("");
        }
      } else {
        this.printer.print(
          "Cannot change transactions in fetch-external mode.  Please quit and restart the debugger instead."
        );
      }
    }
    if (cmd === "g") {
      if (!this.session.view(controller.stepIntoInternalSources)) {
        this.session.setInternalStepping(true);
        this.printer.print(
          "All debugger commands can now step into generated sources."
        );
      } else {
        this.printer.print("Generated sources already activated.");
      }
    }
    if (cmd === "G") {
      if (this.session.view(controller.stepIntoInternalSources)) {
        this.session.setInternalStepping(false);
        this.printer.print(
          "Commands other than (;) and (c) will now skip over generated sources."
        );
      } else {
        this.printer.print("Generated sources already off.");
      }
    }

    // Check if execution has (just now) stopped.
    if (this.session.view(trace.finished) && !alreadyFinished) {
      this.printer.print("");
      //check if transaction failed
      if (!this.session.view(evm.transaction.status)) {
        await this.printer.printRevertMessage();
        this.printer.print("");
        this.printer.printStacktrace(true); //final stacktrace
        this.printer.print("");
        this.printer.printErrorLocation();
      } else {
        //case if transaction succeeded
        this.printer.print("Transaction completed successfully.");
        if (
          this.session.view(sourcemapping.current.source).language !== "Vyper"
        ) {
          //HACK: not supported for vyper yet
          await this.printer.printReturnValue();
        }
      }
    }

    // Perform post printing
    // (we want to see if execution stopped before printing state).
    switch (cmd) {
      case "+":
        if (cmdArgs[0] === ":") {
          watchExpressionAnalytics(cmdArgs.substring(1));
        }
        this.enabledExpressions.add(cmdArgs);
        await this.printer.printWatchExpressionResult(cmdArgs);
        break;
      case "-":
        this.enabledExpressions.delete(cmdArgs);
        break;
      case "!":
        this.printer.printSelector(cmdArgs);
        break;
      case "?":
        this.printer.printWatchExpressions(this.enabledExpressions);
        this.printer.printBreakpoints();
        this.printer.printGeneratedSourcesState();
        break;
      case "v":
        if (
          this.session.view(sourcemapping.current.source).language === "Vyper"
        ) {
          this.printer.print(
            "Decoding of variables is not currently supported for Vyper."
          );
          break;
        }

        //first: process which sections we should print out
        const tempPrintouts = this.updatePrintouts(
          splitArgs,
          this.printer.sections,
          this.printer.sectionPrintouts
        );

        await this.printer.printVariables(tempPrintouts);
        if (this.session.view(trace.finished)) {
          await this.printer.printReturnValue();
        }
        break;
      case ":":
        watchExpressionAnalytics(cmdArgs);
        this.printer.evalAndPrintExpression(cmdArgs);
        break;
      case "b":
        await this.setOrClearBreakpoint(splitArgs, true);
        break;
      case "B":
        await this.setOrClearBreakpoint(splitArgs, false);
        break;
      case "p":
        // determine the numbers of instructions to be printed
        this.printer.instructionLines = this.parsePrintoutLines(
          splitArgs,
          this.printer.instructionLines
        );
        // process which locations we should print out
        const temporaryPrintouts = this.updatePrintouts(
          splitArgs,
          this.printer.locations,
          this.printer.locationPrintouts
        );

        if (this.session.view(session.status.loaded)) {
          if (this.session.view(trace.steps).length > 0) {
            this.printer.printInstruction(temporaryPrintouts);
            this.printer.printFile();
            this.printer.printState();
          } else {
            //if there are no trace steps, let's just print a warning message
            this.printer.print("No trace steps to inspect.");
          }
        }
        //finally, print watch expressions
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "l":
        if (this.session.view(session.status.loaded)) {
          this.printer.printFile();
          // determine the numbers of lines to be printed
          this.printer.sourceLines = this.parsePrintoutLines(
            splitArgs,
            this.printer.sourceLines
          );
          this.printer.printState(
            this.printer.sourceLines.beforeLines,
            this.printer.sourceLines.afterLines
          );
        }
        break;
      case ";":
        if (!this.session.view(trace.finishedOrUnloaded)) {
          this.printer.printInstruction();
          this.printer.printFile();
          this.printer.printState();
        }
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "s":
        if (this.session.view(session.status.loaded)) {
          //print final report if finished & failed, intermediate if not
          if (
            this.session.view(trace.finished) &&
            !this.session.view(evm.transaction.status)
          ) {
            this.printer.printStacktrace(true); //print final stack trace
            //Now: actually show the point where things went wrong
            this.printer.printErrorLocation(
              this.printer.sourceLines.beforeLines,
              this.printer.sourceLines.afterLines
            );
          } else {
            this.printer.printStacktrace(false); //intermediate call stack
          }
        }
        break;
      case "o":
      case "i":
      case "u":
      case "n":
      case "c":
      case "y":
      case "Y":
        if (!this.session.view(trace.finishedOrUnloaded)) {
          if (!this.session.view(sourcemapping.current.source).source) {
            this.printer.printInstruction();
          }
          this.printer.printFile();
          this.printer.printState();
        }
        await this.printer.printWatchExpressionsResults(
          this.enabledExpressions
        );
        break;
      case "r":
        if (this.session.view(session.status.loaded)) {
          this.printer.printAddressesAffected();
          this.printer.warnIfNoSteps();
          this.printer.printFile();
          this.printer.printState();
        }
        break;
      case "t":
        if (!loadFailed) {
          this.printer.printAddressesAffected();
          this.printer.warnIfNoSteps();
          this.printer.printFile();
          this.printer.printState();
        } else if (this.session.view(session.status.isError)) {
          let loadError = this.session.view(session.status.error);
          this.printer.print(loadError);
        }
        break;
      case "T":
      case "g":
      case "G":
        //nothing to print
        break;
      default:
        this.printer.printHelp(this.lastCommand);
    }

    if (
      cmd !== "b" &&
      cmd !== "B" &&
      cmd !== "v" &&
      cmd !== "h" &&
      cmd !== "p" &&
      cmd !== "l" &&
      cmd !== "?" &&
      cmd !== "!" &&
      cmd !== ":" &&
      cmd !== "+" &&
      cmd !== "r" &&
      cmd !== "-" &&
      cmd !== "t" &&
      cmd !== "T" &&
      cmd !== "g" &&
      cmd !== "G" &&
      cmd !== "s" &&
      cmd !== "y"
    ) {
      this.lastCommand = cmd;
    }
  }

  // update the printouts according to user inputs
  // called by case v for section printouts and case p for location printouts
  //
  // NOTE: THIS FUNCTION IS NOT PURE.
  //       The input printOuts is altered according to the values of other inputs: userArgs and selections.
  //       The function returns an object, tempPrintouts, that contains the selected printouts.
  updatePrintouts(userArgs, selections, printOuts) {
    let tempPrintouts = new Set();
    for (let argument of userArgs) {
      let fullSelection;
      if (argument[0] === "+" || argument[0] === "-") {
        fullSelection = argument.slice(1);
      } else {
        fullSelection = argument;
      }
      let selection = selections.find(possibleSelection =>
        fullSelection.startsWith(possibleSelection)
      );
      if (argument[0] === "+") {
        printOuts.add(selection);
      } else if (argument[0] === "-") {
        printOuts.delete(selection);
      } else {
        tempPrintouts.add(selection);
      }
    }
    for (let selection of printOuts) {
      debug("selection: %s", selection);
      tempPrintouts.add(selection);
    }
    return tempPrintouts;
  }

  // parse the numbers of lines options -<num>|+<num> from user args
  parsePrintoutLines(userArgs, currentLines) {
    let { beforeLines, afterLines } = currentLines;
    for (const argument of userArgs) {
      // ignore an option with length less than 2,such as a bare + or -
      if (argument.length < 2) continue;
      const newLines = Number(argument.slice(1));
      // ignore the arguments that are not of the correct form, number
      if (isNaN(newLines)) continue;
      if (argument[0] === "-") {
        beforeLines = newLines;
      } else if (argument[0] === "+") {
        afterLines = newLines;
      }
    }
    return { beforeLines, afterLines };
  }
}

module.exports = {
  DebugInterpreter
};


/***/ }),

/***/ 212834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:mocha");

const colors = __webpack_require__(183196);
const util = __webpack_require__(473837);

const { CLIDebugger } = __webpack_require__(900458);
const execute = __webpack_require__(141441);

class CLIDebugHook {
  constructor(config, compilations, runner) {
    this.config = config;
    this.compilations = compilations;
    this.runner = runner; // mocha runner (**not** lib/test/testrunner)
  }

  async debug(operation) {
    // turn off timeouts for the current runnable
    // HACK we don't turn it back on because it doesn't work...
    // tests that take a long time _after_ debug break just won't timeout
    this.disableTimeout();

    const { txHash, result, method } = await this.invoke(operation);
    debug("txHash: %o", txHash);

    this.printStartTestHook(method);

    const interpreter = await new CLIDebugger(this.config, {
      compilations: this.compilations,
      txHash
    }).run();
    await interpreter.start();

    this.printStopTestHook();

    return result;
  }

  async start() {}

  disableTimeout() {
    this.runner.currentRunnable.timeout(0);
  }

  async invoke(operation) {
    const method = await this.detectMethod(operation);
    const { action } = method;

    switch (action) {
      case "deploy": {
        const result = await operation;

        return {
          txHash: result.transactionHash, // different name; who knew
          method,
          result
        };
      }
      case "send": {
        const result = await operation;

        return { txHash: result.tx, method, result };
      }
      case "call": {
        // replays as send
        const { contract, fn, abi, args, address } = method;

        // get the result of the call
        const result = await operation;

        // and replay it as a transaction so we can debug
        // bit of a HACK: properly making a call act like a tx requires forking
        const { tx: txHash } = await execute.send.call(
          contract,
          fn,
          abi,
          address
        )(...args);

        return { txHash, method, result };
      }
      default: {
        throw new Error(`Unsupported action for debugging: ${action}`);
      }
    }
  }

  detectMethod(promiEvent) {
    return new Promise(accept => {
      for (let action of ["send", "call", "deploy"]) {
        promiEvent.on(
          `execute:${action}:method`,
          ({ fn, abi, args, contract, address }) => {
            accept({
              fn,
              abi,
              args,
              address,
              contract,
              action
            });
          }
        );
      }
    });
  }

  printStartTestHook(method) {
    const formatOperation = ({
      action,
      contract: { contractName },
      abi,
      args
    }) => {
      switch (action) {
        case "deploy": {
          return colors.bold(
            `${contractName}.new(${args.map(util.inspect).join(", ")})`
          );
        }
        case "call":
        case "send": {
          return colors.bold(
            `${contractName}.${abi.name}(${args.map(util.inspect).join(", ")})`
          );
        }
      }
    };

    this.config.logger.log("");
    this.config.logger.log("  ...");
    this.config.logger.log(
      colors.cyan(
        ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      )
    );
    this.config.logger.log("  Test run interrupted.");
    this.config.logger.log(`  Debugging ${formatOperation(method)}`);
    this.config.logger.log(
      colors.cyan(
        ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
      )
    );
    this.config.logger.log("");
  }

  printStopTestHook() {
    this.config.logger.log("");
    this.config.logger.log("");
    this.config.logger.log(
      colors.cyan(
        "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
      )
    );
    this.config.logger.log("  Debugger stopped. Test resuming");
    this.config.logger.log(
      colors.cyan(
        "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"
      )
    );
    this.config.logger.log("  ...");
    this.config.logger.log("");
  }
}

module.exports = {
  CLIDebugHook
};


/***/ }),

/***/ 429099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debugModule = __webpack_require__(615158);
const debug = debugModule("lib:debug:printer");

const path = __webpack_require__(371017);
const util = __webpack_require__(473837);

const DebugUtils = __webpack_require__(93293);
const Codec = __webpack_require__(20102);
const colors = __webpack_require__(183196);
const Interpreter = __webpack_require__(797941);

const selectors = (__webpack_require__(692851).selectors);
const { session, sourcemapping, trace, controller, data, evm, stacktrace } =
  selectors;

class DebugPrinter {
  constructor(config, session) {
    this.config = config;
    this.session = session;
    this.select = expr => {
      let selector, result;

      try {
        selector = expr
          .split(".")
          .reduce((sel, next) => (next.length ? sel[next] : sel), selectors);
      } catch (_) {
        throw new Error("Unknown selector: %s", expr);
      }

      // throws its own exception
      // note: we avoid using this.session so that this
      // can be called from js-interpreter
      result = session.view(selector);

      return result;
    };

    const colorizeSourceObject = source => {
      const { source: raw, language } = source;
      const detabbed = DebugUtils.tabsToSpaces(raw);
      return DebugUtils.colorize(detabbed, language);
    };

    this.colorizedSources = Object.assign(
      {},
      ...Object.entries(this.session.view(sourcemapping.views.sources)).map(
        ([id, source]) => ({
          [id]: colorizeSourceObject(source)
        })
      )
    );

    // location printouts for command (p): print instruction and state
    //   sto: Storage
    //   cal: Calldata
    //   mem: Memory
    //   sta: Stack
    // Note that this is a public variable and can be modified from outside.
    this.locationPrintouts = new Set(["sta"]);
    this.locations = ["sto", "cal", "mem", "sta"]; //should remain constant

    // section printouts for command (v): print variables and values
    //   bui: Solidity built-ins
    //   glo: Global constants
    //   con: Contract variables
    //   loc: Local variables
    // Note that this is a public variable and can be modified from outside.
    this.sectionPrintouts = new Set(["bui", "glo", "con", "loc"]);
    this.sections = ["bui", "glo", "con", "loc"]; //should remain constant

    // numbers of instructions before and after the current instruction to be printed
    // used by commands (p) and (;)
    // Note that this is a public variable and can be modified from outside.
    this.instructionLines = { beforeLines: 3, afterLines: 3 };

    // numbers of lines before and after the current line to be printed
    // used by commands (l) and (s)
    // Note that this is a public variable and can be modified from outside.
    this.sourceLines = { beforeLines: 5, afterLines: 3 };
  }

  print(...args) {
    this.config.logger.log(...args);
  }

  printSessionLoaded() {
    this.printAddressesAffected();
    this.warnIfNoSteps();
    this.printHelp();
    debug("Help printed");
    this.printFile();
    debug("File printed");
    this.printState();
    debug("State printed");
  }

  printSessionError() {
    this.print(this.session.view(session.status.error));
    this.printHelp();
  }

  printAddressesAffected() {
    const affectedInstances = this.session.view(session.info.affectedInstances);

    this.config.logger.log("");
    this.config.logger.log("Addresses affected:");
    this.config.logger.log(
      DebugUtils.formatAffectedInstances(affectedInstances)
    );
  }

  warnIfNoSteps() {
    if (this.session.view(trace.steps).length === 0) {
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} this transaction has no trace steps. This may happen if you are attempting to debug a transaction sent to an externally-owned account, or if the node you are connecting to failed to produce a trace for some reason. Please check your configuration and try again.`
      );
    }
  }

  printHelp(lastCommand) {
    this.config.logger.log("");
    this.config.logger.log(DebugUtils.formatHelp(lastCommand));
  }

  printFile(location = this.session.view(controller.current.location)) {
    let message = "";

    const sourcePath = location.source.sourcePath;

    if (sourcePath) {
      message += path.basename(sourcePath);
    } else {
      message += "?";
    }

    this.config.logger.log("");
    this.config.logger.log(message + ":");
  }

  printState(
    contextBefore = 2,
    contextAfter = 0,
    location = this.session.view(controller.current.location)
  ) {
    const {
      source: { id: sourceId },
      sourceRange: range
    } = location;

    if (sourceId === undefined) {
      this.config.logger.log();
      this.config.logger.log("1: // No source code found.");
      this.config.logger.log("");
      return;
    }

    //we don't just get extract the source text from the location because passed-in location may be
    //missing the source text
    const source = this.session.view(sourcemapping.views.sources)[sourceId]
      .source;
    const colorizedSource = this.colorizedSources[sourceId];

    debug("range: %o", range);

    // We were splitting on OS.EOL, but it turns out on Windows,
    // in some environments (perhaps?) line breaks are still denoted by just \n
    const splitLines = str => str.split(/\r?\n/g);

    const lines = splitLines(source);
    const colorizedLines = splitLines(colorizedSource);

    this.config.logger.log("");
    // We create printoutRange with range.lines as initial value for printing.
    let printoutRange = range.lines;

    // We print a warning message and display the end of source code when the
    // instruction's byte-offset to the start of the range in the source code
    // is past the end of source code.
    if (range.start >= source.length) {
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} Location is past end of source, displaying end.`
      );
      this.config.logger.log("");
      // We set the printoutRange with the end of source code.
      // Note that "lines" is the split lines of source code as defined above.
      printoutRange = {
        start: {
          line: lines.length - 1,
          column: 0
        },
        end: {
          line: lines.length - 1,
          column: 0
        }
      };
    }

    //HACK -- the line-pointer formatter doesn't work right with colorized
    //lines, so we pass in the uncolored version too
    this.config.logger.log(
      DebugUtils.formatRangeLines(
        colorizedLines,
        printoutRange,
        lines,
        contextBefore,
        contextAfter
      )
    );

    this.config.logger.log("");
  }

  printInstruction(locations = this.locationPrintouts) {
    const instruction = this.session.view(sourcemapping.current.instruction);
    const instructions = this.session.view(sourcemapping.current.instructions);
    const step = this.session.view(trace.step);
    const traceIndex = this.session.view(trace.index);
    const totalSteps = this.session.view(trace.steps).length;
    //note calldata will be a Uint8Array, not a hex string or array of such
    const calldata = this.session.view(data.current.state.calldata);
    //storage here is an object mapping hex words to hex words, all w/o 0x prefix
    const storage = this.session.view(evm.current.codex.storage);

    this.config.logger.log("");
    if (locations.has("sto")) {
      this.config.logger.log(DebugUtils.formatStorage(storage));
      this.config.logger.log("");
    }
    if (locations.has("cal")) {
      this.config.logger.log(DebugUtils.formatCalldata(calldata));
      this.config.logger.log("");
    }
    if (locations.has("mem")) {
      this.config.logger.log(DebugUtils.formatMemory(step.memory));
      this.config.logger.log("");
    }
    if (locations.has("sta")) {
      this.config.logger.log(DebugUtils.formatStack(step.stack));
      this.config.logger.log("");
    }

    this.config.logger.log("Instructions:");
    if (!instruction || instruction.pc === undefined) {
      // printout warning message if the debugger does not have the code for this contract
      this.config.logger.log(
        `${colors.bold(
          "Warning:"
        )} The debugger does not have the code for this contract.`
      );
    } else {
      // printout instructions
      const previousInstructions = this.instructionLines.beforeLines;
      const upcomingInstructions = this.instructionLines.afterLines;
      const currentIndex = instruction.index;

      // add an ellipse if there exist additional instructions before
      if (currentIndex - previousInstructions > 0) {
        this.config.logger.log("...");
      }
      // printout 3 previous instructions
      for (
        let i = Math.max(currentIndex - previousInstructions, 0);
        i < currentIndex;
        i++
      ) {
        this.config.logger.log(DebugUtils.formatInstruction(instructions[i]));
      }

      // printout current instruction
      this.config.logger.log(DebugUtils.formatCurrentInstruction(instruction));

      // printout 3 upcoming instructions
      for (
        let i = currentIndex + 1;
        i <=
        Math.min(currentIndex + upcomingInstructions, instructions.length - 1);
        i++
      ) {
        this.config.logger.log(DebugUtils.formatInstruction(instructions[i]));
      }

      // add an ellipse if there exist additional instructions after
      if (currentIndex + upcomingInstructions < instructions.length - 1) {
        this.config.logger.log("...");
      }
    }

    this.config.logger.log("");
    this.config.logger.log(
      "Step " + (traceIndex + 1).toString() + "/" + totalSteps.toString()
    );
    this.config.logger.log(step.gas + " gas remaining");
  }

  /**
   * @param {string} selector
   */
  printSelector(selector) {
    const result = this.select(selector);
    const debugSelector = debugModule(selector);
    debugSelector.enabled = true;
    debugSelector("%O", result);
  }

  printWatchExpressions(expressions) {
    if (expressions.size === 0) {
      this.config.logger.log("No watch expressions added.");
      return;
    }

    this.config.logger.log("");
    for (const expression of expressions) {
      this.config.logger.log("  " + expression);
    }
  }

  printBreakpoints() {
    const sources = this.session.view(sourcemapping.views.sources);
    const sourceNames = Object.assign(
      //note: only include user sources
      {},
      ...Object.entries(sources).map(([id, source]) => ({
        [id]: path.basename(source.sourcePath)
      }))
    );
    const breakpoints = this.session.view(controller.breakpoints);
    if (breakpoints.length > 0) {
      for (let breakpoint of this.session.view(controller.breakpoints)) {
        let currentLocation = this.session.view(controller.current.location);
        let locationMessage = DebugUtils.formatBreakpointLocation(
          breakpoint,
          currentLocation.node !== undefined &&
            breakpoint.sourceId === currentLocation.source.sourceId &&
            breakpoint.node === currentLocation.astRef,
          currentLocation.source.id,
          sourceNames
        );
        this.config.logger.log("  Breakpoint at " + locationMessage);
      }
    } else {
      this.config.logger.log("No breakpoints added.");
    }
  }

  printGeneratedSourcesState() {
    if (this.session.view(controller.stepIntoInternalSources)) {
      this.config.logger.log("Generated sources are turned on.");
    } else {
      this.config.logger.log("Generated sources are turned off.");
    }
  }

  //this doesn't really *need* to be async as we could use codec directly, but, eh
  async printRevertMessage() {
    this.config.logger.log(
      DebugUtils.truffleColors.red("Transaction halted with a RUNTIME ERROR.")
    );
    this.config.logger.log("");
    const revertDecodings = await this.session.returnValue(); //in this context we know it's a revert
    debug("revertDecodings: %o", revertDecodings);
    switch (revertDecodings.length) {
      case 0:
        this.config.logger.log(
          "There was revert data, but it could not be decoded."
        );
        break;
      case 1:
        const revertDecoding = revertDecodings[0];
        switch (revertDecoding.kind) {
          case "failure":
            this.config.logger.log(
              "There was no revert message.  This may be due to an intentional halting expression, such as assert(), revert(), or require(), or could be due to an unintentional exception such as out-of-gas exceptions."
            );
            break;
          case "revert":
            const signature = Codec.AbiData.Utils.abiSignature(
              revertDecoding.abi
            );
            switch (signature) {
              case "Error(string)":
                const revertStringInfo =
                  revertDecoding.arguments[0].value.value;
                let revertString;
                switch (revertStringInfo.kind) {
                  case "valid":
                    revertString = revertStringInfo.asString;
                    this.config.logger.log(`Revert message: ${revertString}`);
                    break;
                  case "malformed":
                    //turn into a JS string while smoothing over invalid UTF-8
                    //slice 2 to remove 0x prefix
                    revertString = Buffer.from(
                      revertStringInfo.asHex.slice(2),
                      "hex"
                    ).toString();
                    this.config.logger.log(`Revert message: ${revertString}`);
                    this.config.logger.log(
                      `${colors.bold(
                        "Warning:"
                      )} This message contained invalid UTF-8.`
                    );
                    break;
                }
                break;
              case "Panic(uint)":
                const panicCode = revertDecoding.arguments[0].value.value.asBN;
                const panicString = DebugUtils.panicString(panicCode, true); //get verbose panic string :)
                this.config.logger.log(
                  `Panic: Code 0x${panicCode.toString(
                    16
                  )}. This code indicates that ${panicString.toLowerCase()}`
                );
                break;
              default:
                this.config.logger.log("The following error was thrown:");
                this.config.logger.log(
                  DebugUtils.formatCustomError(revertDecoding, 2)
                );
            }
            break;
        }
        break;
      default:
        this.config.logger.log(
          "There was revert data, but it could not be unambiguously decoded."
        );
        this.config.logger.log("Possible interpretations:");
        for (const decoding of revertDecodings) {
          this.config.logger.log(DebugUtils.formatCustomError(decoding, 2));
        }
        break;
    }
    this.config.logger.log(
      "Please inspect your transaction parameters and contract code to determine the meaning of this error."
    );
  }

  async printReturnValue() {
    //note: when printing revert messages, this will do so in a somewhat
    //different way than printRevertMessage does
    const inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    }; //copypaste warning: copied from debug-utils!
    const allocationFound = Boolean(
      this.session.view(data.current.returnAllocation)
    );
    const decodings = await this.session.returnValue();
    debug("decodings: %o", decodings);
    if (!allocationFound && decodings.length === 0) {
      //case 1: no allocation found, decoding failed
      this.config.logger.log("");
      this.config.logger.log(
        "A value was returned but it could not be decoded."
      );
      this.config.logger.log("");
    } else if (!allocationFound && decodings[0].status === true) {
      //case 2: no allocation found, decoding succeeded, but not a revert
      //(i.e. it's a presumed selfdestruct; no value was returned)
      //do nothing
    } else if (allocationFound && decodings.length === 0) {
      //case 3: allocation found but decoding failed
      this.config.logger.log("");
      this.config.logger.log("The return value could not be decoded.");
      this.config.logger.log("");
    } else if (allocationFound && decodings[0].kind === "selfdestruct") {
      //case 4: allocation found, apparent self-destruct (note due to the use of [0] this
      //won't occur if no return value was expected, as return takes priority over selfdestruct)
      //Oops -- in an actual selfdestruct, we won't have the code! >_>
      //(Not until reconstruct mode exists...) Oh well, leaving this in
      this.config.logger.log("");
      this.config.logger.log(
        "No value was returned even though one was expected.  This may indicate a self-destruct."
      );
      this.config.logger.log("");
    } else if (decodings[0].kind === "failure") {
      //case 5: revert (no message)
      this.config.logger.log("");
      this.config.logger.log("There was no revert message.");
      this.config.logger.log("");
    } else if (decodings[0].kind === "unknownbytecode") {
      //case 6: unknown bytecode
      this.config.logger.log("");
      this.config.logger.log(
        "Bytecode was returned, but it could not be identified."
      );
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "return" &&
      decodings[0].arguments.length === 0
    ) {
      //case 7: return values but with no content
      //do nothing
    } else if (decodings[0].kind === "bytecode") {
      //case 8: known bytecode
      this.config.logger.log("");
      //we just defer to the ReturndataDecodingInspector in this case
      this.config.logger.log(
        util.inspect(
          new Codec.Export.ReturndataDecodingInspector(decodings[0]),
          inspectOptions
        )
      );
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "revert" &&
      decodings.filter(decoding => decoding.kind === "revert").length === 1
    ) {
      //case 9: revert (with message) (unambiguous)
      const decoding = decodings[0];
      const signature = Codec.AbiData.Utils.abiSignature(decoding.abi);
      this.config.logger.log("");
      switch (signature) {
        case "Error(string)": {
          //case 9a: revert string
          //(special handling, don't use inspector)
          const prefix = "Revert string: ";
          const value = decodings[0].arguments[0].value;
          const formatted = DebugUtils.formatValue(value, prefix.length);
          this.config.logger.log(prefix + formatted);
          break;
        }
        case "Panic(uint)": {
          //case 9b: panic code
          //(special handling, don't use inspector)
          const prefix = "Panic code: ";
          const value = decodings[0].arguments[0].value;
          const formatted = DebugUtils.formatValue(value, prefix.length);
          const meaning = DebugUtils.panicString(value.value.asBN);
          this.config.logger.log(`${prefix} ${formatted} (${meaning})`);
          break;
        }
        default:
          //case 9c: custom error
          //just use the inspector
          this.config.logger.log(
            util.inspect(
              new Codec.Export.ReturndataDecodingInspector(decodings[0]),
              inspectOptions
            )
          );
      }
      this.config.logger.log("");
    } else if (
      decodings[0].kind === "revert" &&
      decodings.filter(decoding => decoding.kind === "revert").length > 1
    ) {
      //case 10: ambiguous revert with message
      this.config.logger.log(
        "Ambiguous error thrown, possible interpretations:"
      );
      for (const decoding of decodings) {
        if (decoding.kind !== "revert") {
          break;
        }
        //again, we can use the inspector
        this.config.logger.log(
          util.inspect(
            new Codec.Export.ReturndataDecodingInspector(decodings[0]),
            inspectOptions
          )
        );
      }
    } else if (
      decodings[0].kind === "return" &&
      decodings[0].arguments.length > 0
    ) {
      //case 11: actual return values to print!
      //we're not going to use the inspector here, we're going to
      //handle this in a custom manner
      this.config.logger.log("");
      const values = decodings[0].arguments;
      if (values.length === 1 && !values[0].name) {
        //case 11a: if there's only one value and it's unnamed
        const value = values[0].value;
        const prefix = "Returned value: ";
        const formatted = DebugUtils.formatValue(value, prefix.length);
        this.config.logger.log(prefix + formatted);
      } else {
        //case 11b: otherwise
        this.config.logger.log("Returned values:");
        const prefixes = values.map(({ name }, index) =>
          name ? `${name}: ` : `Component #${index + 1}: `
        );
        const maxLength = Math.max(...prefixes.map(prefix => prefix.length));
        const paddedPrefixes = prefixes.map(prefix =>
          prefix.padStart(maxLength)
        );
        for (let index = 0; index < values.length; index++) {
          const { value } = values[index];
          const prefix = paddedPrefixes[index];
          const formatted = DebugUtils.formatValue(value, maxLength);
          this.config.logger.log(prefix + formatted);
        }
      }
      this.config.logger.log("");
    } else if (decodings[0].kind === "returnmessage") {
      //case 12: raw binary data
      //(special handling, don't use inspector)
      this.config.logger.log("");
      const fallbackOutputDefinition = this.session.view(
        data.current.fallbackOutputForContext
      );
      const name = (fallbackOutputDefinition || {}).name;
      const prettyData = `${colors.green("hex")}${DebugUtils.formatValue(
        decodings[0].data.slice(2), //remove '0x'
        0,
        true
      )}`;
      if (name) {
        //case 12a: it has a name
        this.config.logger.log("Returned values:");
        this.config.logger.log(`${name}: ${prettyData}`);
      } else {
        //case 12b: it doesn't
        this.config.logger.log(`Returned value: ${prettyData}`);
      }
      //it's already a string, so we'll pass the nativized parameter
      //and hack this together :)
      //also, since we only have one thing and it's a string, we'll skip
      //fancy indent processing
      this.config.logger.log("");
    }
  }

  printStacktrace(final) {
    this.config.logger.log(final ? "Stacktrace:" : "Call stack:");
    let report = final
      ? this.session.view(stacktrace.current.finalReport)
      : this.session.view(stacktrace.current.report);
    this.config.logger.log(DebugUtils.formatStacktrace(report));
  }

  printErrorLocation(linesBefore, linesAfter) {
    const stacktraceReport = this.session.view(stacktrace.current.finalReport);
    const lastUserFrame = stacktraceReport
      .slice()
      .reverse() //clone before reversing, reverse is in-place!
      .find(frame => !frame.location.internal);
    if (lastUserFrame) {
      this.config.logger.log("");
      this.config.logger.log(
        DebugUtils.truffleColors.red("Location of error:")
      );
      this.printFile(lastUserFrame.location);
      this.printState(linesBefore, linesAfter, lastUserFrame.location);
    }
  }

  async printWatchExpressionsResults(expressions) {
    debug("expressions %o", expressions);
    for (let expression of expressions) {
      this.config.logger.log(expression);
      // Add some padding. Note: This won't work with all loggers,
      // meaning it's not portable. But doing this now so we can get something
      // pretty until we can build more architecture around this.
      // Note: Selector results already have padding, so this isn't needed.
      if (expression[0] === ":") {
        process.stdout.write("  ");
      }
      await this.printWatchExpressionResult(expression);
    }
  }

  async printWatchExpressionResult(expression) {
    const type = expression[0];
    const exprArgs = expression.substring(1);

    if (type === "!") {
      this.printSelector(exprArgs);
    } else {
      await this.evalAndPrintExpression(exprArgs, 2, true);
    }
  }

  async printVariables(sectionOuts = this.sectionPrintouts) {
    const values = await this.session.variables({ indicateUnknown: true });
    const sections = this.session.view(data.current.identifiers.sections);

    const sectionNames = {
      builtin: "Solidity built-ins",
      global: "Global constants",
      contract: "Contract variables",
      local: "Local variables"
    };

    this.config.logger.log();

    let printLegend = false;

    // printout the sections that are included in the inputs and have positive contents length
    for (const [section, variables] of Object.entries(sections)) {
      // only check the first 3 characters of each name given in the input sectionPrintouts
      // since each section name defined in the constructor contains 3 characters
      const printThisSection = sectionOuts.has(section.slice(0, 3));
      if (printThisSection && variables.length > 0) {
        this.config.logger.log(sectionNames[section] + ":");
        // Get the length of the longest name.
        const longestNameLength = variables.reduce((longest, name) => {
          return name.length > longest ? name.length : longest;
        }, -Infinity);
        for (const variable of variables) {
          const paddedName = variable.padStart(longestNameLength) + ":";
          const value = values[variable];
          const formatted = DebugUtils.formatValue(
            value,
            longestNameLength + 5
          );
          this.config.logger.log("  " + paddedName, formatted);
          if (Codec.Export.containsDeliberateReadError(value)) {
            printLegend = true;
          }
        }
        this.config.logger.log();
      }
    }

    if (printLegend) {
      this.config.logger.log(
        "Note: Some storage variables could not be fully decoded; the debugger can only see storage it has seen touched during the transaction."
      );
    }
  }

  /**
   * @param {string} raw - user input for watch expression
   *
   * performs pre-processing on `raw`, using !<...> delimeters to refer
   * to selector expressions.
   *
   * e.g., to see a particular part of the current trace step's stack:
   *
   *    debug(development:0x4228cdd1...)>
   *
   *        :!<trace.step.stack>[1]
   */
  async evalAndPrintExpression(raw, indent, suppress) {
    let variables = await this.session.variables({ indicateUnknown: true });

    //if we're just dealing with a single variable, handle that case
    //separately (so that we can do things in a better way for that
    //case)
    let variable = raw.trim();
    if (variable in variables) {
      let formatted = DebugUtils.formatValue(variables[variable], indent);
      this.config.logger.log(formatted);
      this.config.logger.log();
      if (Codec.Export.containsDeliberateReadError(variables[variable])) {
        this.config.logger.log(
          "Note: Variable could not be fully decoded as the debugger can only see storage it has seen touched during the transaction."
        );
      }
      return;
    }
    debug("expression case");

    // converts all !<...> expressions to JS-valid selector requests
    const preprocessSelectors = expr => {
      const regex = /!<([^>]+)>/g;
      const select = "$"; // expect repl context to have this func
      const replacer = (_, selector) => `${select}("${selector}")`;

      return expr.replace(regex, replacer);
    };

    //HACK
    //if we're not in the single-variable case, we'll need to do some
    //things to Javascriptify our variables so that the JS syntax for
    //using them is closer to the Solidity syntax
    let context = Codec.Format.Utils.Inspect.unsafeNativizeVariables(variables);

    //HACK -- we can't use "this" as a variable name, so we're going to
    //find an available replacement name, and then modify the context
    //and expression appropriately
    let pseudoThis = "_this";
    while (pseudoThis in context) {
      pseudoThis = "_" + pseudoThis;
    }
    //in addition to pseudoThis, which replaces this, we also have
    //pseudoPseudoThis, which replaces pseudoThis in order to ensure
    //that any uses of pseudoThis yield an error instead of showing this
    let pseudoPseudoThis = "thereisnovariableofthatname";
    while (pseudoPseudoThis in context) {
      pseudoPseudoThis = "_" + pseudoPseudoThis;
    }
    context = DebugUtils.cleanThis(context, pseudoThis);
    let expr = raw.replace(
      //those characters in [] are the legal JS variable name characters
      //note that pseudoThis contains no special characters
      new RegExp("(?<![a-zA-Z0-9_$])" + pseudoThis + "(?![a-zA-Z0-9_$])"),
      pseudoPseudoThis
    );
    expr = expr.replace(
      //those characters in [] are the legal JS variable name characters
      /(?<![a-zA-Z0-9_$])this(?![a-zA-Z0-9_$])/,
      pseudoThis
    );
    //note that pseudoThis contains no dollar signs to screw things up

    expr = preprocessSelectors(expr);

    try {
      const result = this.safelyEvaluateWithSelectors(expr, context);
      const formatted = DebugUtils.formatValue(result, indent, true);
      this.config.logger.log(formatted);
      this.config.logger.log();
    } catch (e) {
      if (!suppress) {
        this.config.logger.log(e);
      } else {
        this.config.logger.log(DebugUtils.formatValue(undefined, indent, true));
      }
    }
  }

  //evaluates expression with the variables in context,
  //but also has `$` as a variable that is the select function
  safelyEvaluateWithSelectors(expression, context) {
    const select = this.select;
    let interpreter;
    interpreter = new Interpreter(expression, function (
      interpreter,
      globalObject
    ) {
      //first let's set up our select function (which will be called $)
      interpreter.setProperty(
        globalObject,
        "$",
        interpreter.createNativeFunction(selectorName => {
          debug("selecting %s", selectorName);
          return interpreter.nativeToPseudo(select(selectorName));
        })
      );
      //now let's set up the variables
      for (const [variable, value] of Object.entries(context)) {
        try {
          debug("variable: %s", variable);
          //note: circular objects wll raise an exception here and get excluded.
          interpreter.setProperty(
            globalObject,
            variable,
            interpreter.nativeToPseudo(value)
          );
        } catch (_) {
          debug("failure");
          //just omit things that don't work
        }
      }
    });
    interpreter.run();
    return interpreter.pseudoToNative(interpreter.value);
  }
}

module.exports = {
  DebugPrinter
};


/***/ }),

/***/ 142863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(183196);
const TruffleError = __webpack_require__(673321);

class BuildError extends TruffleError {
  constructor(message) {
    message =
      "Error building:\n\n" +
      message +
      "\n\n" +
      colors.red("Build failed. See above.");
    super(message);
  }
}

module.exports = BuildError;


/***/ }),

/***/ 478979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(657147);
const path = __webpack_require__(371017);
const OS = __webpack_require__(822037);
const BlockchainUtils = __webpack_require__(986317);
const Provider = __webpack_require__(200509);
const { createInterfaceAdapter } = __webpack_require__(936339);

const Networks = {
  deployed: async function(options) {
    let files;
    try {
      // Only read JSON files in directory
      files = fs
        .readdirSync(options.contracts_build_directory)
        .filter(fn => fn.endsWith(".json"));
    } catch (error) {
      // We can't read the directory. Act like we found nothing.
      files = [];
    }

    const binaries = files.map(file => {
      const filePath = path.join(options.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      return JSON.parse(fileContents);
    });

    const idsToNames = {};
    const networks = {};

    for (let networkName in options.networks) {
      const network = options.networks[networkName];
      const networkId = network.network_id;

      if (networkId == null) return;

      idsToNames[networkId] = networkName;
      networks[networkName] = {};
    }

    for (let json of binaries) {
      for (let networkId in json.networks) {
        const networkName = idsToNames[networkId] || networkId;

        if (networks[networkName] == null) networks[networkName] = {};

        const address = json.networks[networkId].address;

        if (address == null) return;

        networks[networkName][json.contractName] = address;
      }
    }
    return networks;
  },

  display: async function(config) {
    const networks = await this.deployed(config);
    const { networkNames, starNetworks } = Object.keys(networks)
      .sort()
      .reduce(
        (acc, networkName) => {
          if (
            config.networks[networkName] &&
            config.networks[networkName].network_id === "*"
          ) {
            acc.starNetworks.push(networkName);
          } else {
            acc.networkNames.push(networkName);
          }
          return acc;
        },
        { networkNames: [], starNetworks: [] }
      );

    const unknownNetworks = networkNames.filter(networkName => {
      const configuredNetworks = Object.keys(config.networks);
      let found = false;
      for (let i = 0; i < configuredNetworks.length; i++) {
        const configuredNetworkName = configuredNetworks[i];
        if (networkName === configuredNetworkName) {
          found = true;
          break;
        }
      }

      return !found;
    });

    // Only display this warning if:
    //
    //   At least one network is configured with the wildcard ('*') network id
    //   There's a least one network deployed to
    //   And one of those networks deployed to is unknown (i.e., unconfigured).
    if (
      starNetworks.length > 0 &&
      networkNames.length > 0 &&
      unknownNetworks.length > 0
    ) {
      config.logger.log(
        OS.EOL +
          "The following networks are configured to match any network id ('*'):" +
          OS.EOL
      );

      starNetworks.forEach(networkName => {
        config.logger.log("    " + networkName);
      });

      config.logger.log(
        OS.EOL +
          "Closely inspect the deployed networks below, and use `truffle networks --clean` to remove any networks that don't match your configuration. You should not use the wildcard configuration ('*') for staging and production networks for which you intend to deploy your application."
      );
    }

    networkNames.forEach(networkName => {
      config.logger.log("");

      let output = Object.keys(networks[networkName])
        .sort()
        .map(contract_name => {
          const address = networks[networkName][contract_name];
          return contract_name + ": " + address;
        });

      if (output.length === 0) output = ["No contracts deployed."];

      let message = "Network: ";

      const is_id = config.networks[networkName] == null;

      if (is_id) {
        message += "UNKNOWN (id: " + networkName + ")";
      } else {
        message +=
          networkName +
          " (id: " +
          config.networks[networkName].network_id +
          ")";
      }

      config.logger.log(message);
      config.logger.log("  " + output.join("\n  "));
    });

    if (networkNames.length === 0) {
      config.logger.log(
        OS.EOL + "Contracts have not been deployed to any network."
      );
    }
    config.logger.log("");
  },

  clean: async function(config) {
    // Only read JSON files in directory
    let files = fs
      .readdirSync(config.contracts_build_directory)
      .filter(fn => fn.endsWith(".json"));
    const configuredNetworks = Object.keys(config.networks);
    const results = [];

    files.forEach(file => {
      const filePath = path.join(config.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      const body = JSON.parse(fileContents);

      for (let installedNetworkId of Object.keys(body.networks)) {
        let found = false;
        for (let i = 0; i < configuredNetworks.length; i++) {
          const configuredNetwork = configuredNetworks[i];

          // If an installed network id matches a configured id, then we can ignore this one.
          let parsedNetworkId;
          try {
            // Account for an integer or string in the config
            parsedNetworkId = parseInt(installedNetworkId);
          } catch (_error) {
            // If it can't be parsed into an int like * then don't worry about it
          }
          if (
            installedNetworkId ===
              config.networks[configuredNetwork].network_id ||
            parsedNetworkId === config.networks[configuredNetwork].network_id
          ) {
            found = true;
            break;
          }
        }
        // If we didn't find a suitable configuration, delete this network.
        if (found === false) delete body.networks[installedNetworkId];
      }
      // Our work is done here. Save the file.
      fs.writeFileSync(filePath, JSON.stringify(body, null, 2), "utf8");
      results.push(body);
    });

    // TODO: Display what's removed?
    return results;
  },

  // Try to connect to every named network except for "test" and "development"
  asURIs: async function(options, networks) {
    const result = {
      uris: {},
      failed: []
    };

    for (const networkName of networks) {
      const provider = Provider.create(options.networks[networkName]);
      try {
        const uri = await BlockchainUtils.asURI(provider);
        result.uris[networkName] = uri;
      } catch (error) {
        result.failed.push(networkName);
      }
    }

    return result;
  },

  matchesNetwork: async function(network_id, network_options) {
    const provider = Provider.create(network_options);

    const first = network_id + "";
    const second = network_options.network_id + "";

    if (first === second) return true;

    const isFirstANumber = isNaN(parseInt(network_id)) === false;
    const isSecondANumber =
      isNaN(parseInt(network_options.network_id)) === false;

    // If both network ids are numbers, then they don't match, and we should quit.
    if (isFirstANumber && isSecondANumber) return false;

    const interfaceAdapter = createInterfaceAdapter({
      provider,
      networkType: network_options.type
    });

    const currentNetworkID = await interfaceAdapter.getNetworkId();
    if (first === currentNetworkID) return true;
    if (isFirstANumber === false)
      await BlockchainUtils.matches(first, provider);
    else {
      // Nothing else to compare.
      return false;
    }
  }
};

module.exports = Networks;


/***/ }),

/***/ 883513:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const Networks = __webpack_require__(478979);
const EthPM = __webpack_require__(954733);
const EthPMRegistry = __webpack_require__(838182);
const Web3 = __webpack_require__(503283);
const { createInterfaceAdapter } = __webpack_require__(936339);
const path = __webpack_require__(371017);
const fs = __webpack_require__(657147);
const OS = __webpack_require__(822037);

const Package = {
  install: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    expect.options(options, ["working_directory", "ethpm"]);

    expect.options(options.ethpm, ["registry", "ipfs_host"]);

    expect.one(options.ethpm, ["provider", "install_provider_uri"]);

    // ipfs_port and ipfs_protocol are optinal.

    const provider =
      options.ethpm.provider ||
      new Web3.providers.HttpProvider(options.ethpm.install_provider_uri, {
        keepAlive: false
      });
    let host = options.ethpm.ipfs_host;

    if (host instanceof EthPM.hosts.IPFS === false) {
      host = new EthPM.hosts.IPFSWithLocalReader(
        options.ethpm.ipfs_host,
        options.ethpm.ipfs_port,
        options.ethpm.ipfs_protocol
      );
    }

    // When installing, we use infura to make a bunch of eth_call's.
    // We don't make any transactions. To satisfy APIs we'll put a from address,
    // but it doesn't really matter in this case.
    const fakeAddress = "0x1234567890123456789012345678901234567890";

    let registry = options.ethpm.registry;

    if (typeof registry === "string") {
      try {
        registry = await EthPMRegistry.use(
          options.ethpm.registry,
          fakeAddress,
          provider
        );
      } catch (error) {
        if (callbackPassed) {
          callback(error);
          return;
        }
        throw error;
      }
    }

    const pkg = new EthPM(options.working_directory, host, registry);

    if (options.packages) {
      const promises = options.packages.map(package_name => {
        const pieces = package_name.split("@");
        package_name = pieces[0];

        let version = "*";

        if (pieces.length > 1) version = pieces[1];

        return pkg.installDependency(package_name, version);
      });

      await Promise.all(promises);
      if (options.packages.length > 0) {
        console.log("");
        console.log("Successfully installed the following package(s)...");
        console.log("==================================================");
        options.packages.forEach(singlePackage => {
          console.log(`> ${singlePackage}`);
        });
        console.log("");
      }
      if (callbackPassed) {
        callback();
      }
      return;
    } else {
      let manifest;
      try {
        fs.accessSync(
          path.join(options.working_directory, "ethpm.json"),
          fs.constants.R_OK
        );
      } catch (_error) {
        // If the ethpm.json file doesn't exist, use the config as the manifest.
        manifest = options;
      }
      try {
        await pkg.install(manifest);
        if (callbackPassed) {
          callback();
        }
      } catch (error) {
        if (callbackPassed) {
          callback(error);
          return;
        }
        throw error;
      }
    }
  },

  publish: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    var self = this;

    expect.options(options, [
      "ethpm",
      "working_directory",
      "contracts_directory",
      "networks"
    ]);

    expect.options(options.ethpm, ["registry", "ipfs_host"]);

    // ipfs_port and ipfs_protocol are optinal.

    // When publishing, you need a ropsten network configured.
    var ropsten = options.networks.ropsten;

    if (!ropsten) {
      const message =
        "You need to have a `ropsten` network configured in " +
        "order to publish to the Ethereum Package Registry. See the " +
        "following link for an example configuration:" +
        OS.EOL +
        OS.EOL +
        "    http://trufflesuite.com/tutorials/using-infura-custom-provider" +
        OS.EOL;
      if (callbackPassed) {
        callback(new TruffleError(message));
        return;
      }
      throw new TruffleError(message);
    }

    options.network = "ropsten";

    var provider = options.provider;
    const interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: "ethereum"
    });
    var host = options.ethpm.ipfs_host;

    if (!(host instanceof EthPM.hosts.IPFS)) {
      host = new EthPM.hosts.IPFS(
        options.ethpm.ipfs_host,
        options.ethpm.ipfs_port,
        options.ethpm.ipfs_protocol
      );
    }

    options.logger.log("Finding publishable artifacts...");

    try {
      const artifacts = await self.publishable_artifacts(options);

      const accs = await interfaceAdapter.getAccounts();
      var registry = await EthPMRegistry.use(
        options.ethpm.registry,
        accs[0],
        provider
      );
      var pkg = new EthPM(options.working_directory, host, registry);
      let manifest;
      try {
        fs.accessSync(
          path.join(options.working_directory, "ethpm.json"),
          fs.constants.R_OK
        );
      } catch (error) {
        // If the ethpm.json file doesn't exist, use the config as the manifest.
        manifest = options;
      }

      options.logger.log("Uploading sources and publishing to registry...");

      // TODO: Gather contract_types and deployments
      const lockfile = await pkg.publish(
        artifacts.contract_types,
        artifacts.deployments,
        manifest
      );
      // If we get here, publishing was a success.
      options.logger.log("+ " + lockfile.package_name + "@" + lockfile.version);
      if (callbackPassed) {
        callback();
      }
      return;
    } catch (error) {
      if (callbackPassed) {
        return callback(error);
      }
      throw error;
    }
  },

  digest: function(options, callback) {
    callback(new Error("Not yet implemented"));
  },

  // Return a list of publishable artifacts
  publishable_artifacts: async function(options, callback) {
    const callbackPassed = typeof callback === "function";
    // Filter out "test" and "development" networks.
    const ifReservedNetworks = new Set(["test", "development"]);
    var deployed_networks = Object.keys(options.networks).filter(
      name => !ifReservedNetworks.has(name)
    );

    // Now get the URIs of each network that's been deployed to.
    let result;
    try {
      result = await Networks.asURIs(options, deployed_networks);
    } catch (error) {
      if (callbackPassed) {
        return callback(err);
      }
      throw err;
    }

    var uris = result.uris;

    if (result.failed.length > 0) {
      const message =
        "Could not connect to the following networks: " +
        result.failed.join(", ") +
        ". These networks have deployed " +
        "artifacts that can't be published as a package without an active " +
        "and accessible connection. Please ensure clients for each " +
        "network are up and running prior to publishing, or use the -n " +
        "option to specify specific networks you'd like published.";
      if (callbackPassed) {
        return callback(new Error(message));
      }
      throw new Error(message);
    }

    var files = fs.readdirSync(options.contracts_build_directory);
    files = files.filter(file => file.endsWith(".json"));

    if (!files.length) {
      const message =
        "Could not locate any publishable artifacts in " +
        options.contracts_build_directory +
        ". " +
        "Run `truffle compile` before publishing.";
      if (callbackPassed) {
        return callback(new Error(message));
      }
      throw new Error(message);
    }

    const promises = files.map(file => {
      return new Promise((resolve, reject) => {
        fs.readFile(
          path.join(options.contracts_build_directory, file),
          "utf8",
          (error, data) => {
            if (error) {
              reject(error);
            }
            resolve(JSON.parse(data));
          }
        );
      });
    });

    const contracts = await Promise.all(promises);

    var contract_types = {};
    var deployments = {};

    // contract_types first.
    contracts.forEach(data => {
      contract_types[data.contractName] = {
        contract_name: data.contractName,
        bytecode: data.bytecode,
        abi: data.abi
      };
    });

    //var network_cache = {};
    const matchingPromises = [];

    contracts.forEach(data => {
      Object.keys(data.networks).forEach(network_id => {
        matchingPromises.push(
          new Promise(async (accept, reject) => {
            try {
              // Go through each deployed network and see if this network matches.
              for (const deployedNetwork of deployed_networks) {
                const matches = await Networks.matchesNetwork(
                  network_id,
                  options.networks[deployedNetwork]
                );
                if (matches) {
                  var uri = uris[deployed_network];

                  if (!deployments[uri]) {
                    deployments[uri] = {};
                  }

                  deployments[uri][data.contractName] = {
                    contract_type: data.contractName, // TODO: Handle conflict resolution
                    address: data.networks[network_id].address
                  };

                  accept();
                }
              }
            } catch (error) {
              reject(error);
            }
          })
        );
      });
    });

    try {
      await Promise.all(matchingPromises);
      const toReturn = {
        contract_types: contract_types,
        deployments: deployments
      };
      if (callbackPassed) {
        callback(null, toReturn);
        return;
      }
      return toReturn;
    } catch (error) {
      if (callbackPassed) {
        return callback(error);
      }
      throw error;
    }
  }
};

module.exports = Package;


/***/ }),

/***/ 795614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(120553);

const analytics = {
  send: function(eventObject) {
    const userConfig = Config.getUserConfig();

    if (!userConfig.get("enableAnalytics")) {
      // don't bother with creating a new process if we already
      // know the user doesn't want to send analytics
      return;
    }

    let analyticsPath;
    const path = __webpack_require__(371017);
    if (true) {
      analyticsPath = path.join(__dirname, "analytics.bundled.js");
    } else {}

    const cp = __webpack_require__(532081);
    const child = cp.fork(analyticsPath, { silent: true });
    child.send(eventObject);
  }
};

module.exports = analytics;


/***/ }),

/***/ 569575:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TestCase = __webpack_require__(950210);
const Suite = __webpack_require__(483794);
const Deployer = __webpack_require__(400669);
const { Compile } = __webpack_require__(4273);
const { Shims } = __webpack_require__(529833);
const debug = __webpack_require__(615158)("lib:testing:soliditytest");

const SolidityTest = {
  async define(abstraction, dependencyPaths, runner, mocha) {
    const self = this;

    const suite = new Suite(abstraction.contract_name, {});
    suite.timeout(runner.BEFORE_TIMEOUT);

    // Set up our runner's needs first.
    suite.beforeAll("prepare suite", async function () {
      // This compiles some native contracts (including the assertion library
      // contracts) which need to be compiled before initializing the runner
      await self.compileNewAbstractInterface.bind(this)(runner);
      await runner.initialize.bind(runner)();
      runner.disableChecksOnEventDecoding(); //for handling of test events on Solidity <0.7.6 due to empty string problem
      await self.deployTestDependencies.bind(this)(
        abstraction,
        dependencyPaths,
        runner
      );
    });

    suite.afterAll("clean up", function () {
      runner.reEnableChecksOnEventDecoding();
    });

    suite.beforeEach("before test", async function () {
      await runner.startTest(this);
    });

    // Function that checks transaction logs to see if a test failed.
    async function checkResultForFailure(result) {
      const logs = result.receipt.rawLogs;
      for (const log of logs) {
        const decodings = await runner.decoder.decodeLog(log, {
          disableChecks: true
        });
        for (const decoding of decodings) {
          //check: is this a TestEvent?
          //note: we don't check the argument names
          if (
            decoding.abi.name === "TestEvent" &&
            decoding.arguments.length === 2 &&
            decoding.arguments[0].value.type.typeClass === "bool" &&
            decoding.arguments[0].indexed &&
            decoding.arguments[1].value.type.typeClass === "string" &&
            !decoding.arguments[1].indexed
          ) {
            //if so: did the test fail?
            if (!decoding.arguments[0].value.value.asBoolean) {
              //if so: extract the message
              let messageDecoding = decoding.arguments[1].value;
              let message;
              switch (messageDecoding.value.kind) {
                case "valid":
                  message = messageDecoding.value.asString;
                  break;
                case "malformed":
                  //use buffer to convert hex to string
                  //(this causes malformed UTF-8 to become U+FFFD)
                  message = Buffer.from(
                    messageDecoding.value.asHex.slice(2),
                    "hex"
                  ).toString();
              }
              throw new Error(message);
            }
          }
        }
      }
    }

    // Add functions from test file.
    for (const item of abstraction.abi) {
      if (item.type !== "function") {
        continue;
      }

      const hookTypes = ["beforeAll", "beforeEach", "afterAll", "afterEach"];
      for (const hookType of hookTypes) {
        if (item.name.startsWith(hookType)) {
          suite[hookType](item.name, async () => {
            let deployed = await abstraction.deployed();
            await checkResultForFailure(await deployed[item.name]());
          });
        }
      }

      if (item.name.startsWith("test")) {
        const test = new TestCase(item.name, async () => {
          let deployed = await abstraction.deployed();
          await checkResultForFailure(await deployed[item.name]());
        });

        test.timeout(runner.TEST_TIMEOUT);
        suite.addTest(test);
      }
    }

    suite.afterEach("after test", async function () {
      await runner.endTest(this);
    });

    mocha.suite.addSuite(suite);
  },

  async compileNewAbstractInterface(runner) {
    debug("compiling");
    const config = runner.config;

    const truffleLibraries = [
      "truffle/Assert.sol",
      "truffle/AssertAddress.sol",
      "truffle/AssertAddressArray.sol",
      "truffle/AssertBalance.sol",
      "truffle/AssertBool.sol",
      "truffle/AssertBytes32.sol",
      "truffle/AssertBytes32Array.sol",
      "truffle/AssertGeneral.sol",
      "truffle/AssertInt.sol",
      "truffle/AssertIntArray.sol",
      "truffle/AssertString.sol",
      "truffle/AssertUint.sol",
      "truffle/AssertUintArray.sol",
      "truffle/DeployedAddresses.sol",
      `truffle/SafeSend.sol`
    ];

    const { compilations } = await Compile.sourcesWithDependencies({
      paths: truffleLibraries,
      options: runner.config.with({
        quiet: true
      })
    });
    const contracts = compilations.reduce((a, compilation) => {
      return a.concat(compilation.contracts);
    }, []);

    // Set network values.
    for (let contract of contracts) {
      contract.network_id = config.network_id;
      contract.default_network = config.default_network;
    }

    await config.artifactor.saveAll(
      contracts.map(Shims.NewToLegacy.forContract)
    );
    debug("compiled");
  },

  async deployTestDependencies(abstraction, dependencyPaths, runner) {
    debug("deploying %s", abstraction.contract_name);
    const deployer = new Deployer(
      runner.config.with({
        logger: { log() {} }
      })
    );

    debug("starting deployer");
    await deployer.start();

    const testLibraries = [
      "Assert",
      "AssertAddress",
      "AssertAddressArray",
      "AssertBalance",
      "AssertBool",
      "AssertBytes32",
      "AssertBytes32Array",
      "AssertGeneral",
      "AssertInt",
      "AssertIntArray",
      "AssertString",
      "AssertUint",
      "AssertUintArray",
      "DeployedAddresses"
    ];

    const testAbstractions = testLibraries.map(name =>
      runner.config.resolver.require(`truffle/${name}.sol`)
    );

    const SafeSend = runner.config.resolver.require("SafeSend");

    debug("deploying test libs");
    for (const testLib of testAbstractions) {
      await deployer.deploy(testLib);
      await deployer.link(testLib, abstraction);
    }

    debug("linking dependencies");
    for (const dependencyPath of dependencyPaths) {
      const dependency = runner.config.resolver.require(dependencyPath);

      if (dependency.isDeployed()) {
        await deployer.link(dependency, abstraction);
      }
    }

    debug("deploying contract");
    await deployer.deploy(abstraction);
    const deployed = await abstraction.deployed();
    let balance;
    if (deployed.initialBalance) {
      balance = await deployed.initialBalance.call();
    } else {
      balance = 0;
    }

    if (balance !== 0) {
      await deployer.deploy(SafeSend);
      const safeSend = await SafeSend.deployed();
      await safeSend.deliver(deployed.address, { value: balance });
    }

    debug("deployed %s", abstraction.contract_name);
  }
};

module.exports = SolidityTest;


/***/ }),

/***/ 952422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(183196);
const chai = __webpack_require__(614960);
const path = __webpack_require__(371017);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const Config = __webpack_require__(120553);
const WorkflowCompile = __webpack_require__(577135);
const { Resolver } = __webpack_require__(648511);
const TestRunner = __webpack_require__(68710);
const SolidityTest = __webpack_require__(569575);
const RangeUtils = __webpack_require__(632739);
const expect = __webpack_require__(414096);
const Migrate = __webpack_require__(523459);
const Profiler = __webpack_require__(422860);
const originalrequire = __webpack_require__(344516);
const Codec = __webpack_require__(20102);
const debug = __webpack_require__(615158)("lib:test");
const Debugger = __webpack_require__(692851);

let Mocha; // Late init with "mocha" or "mocha-parallel-tests"

chai.use(__webpack_require__(408580));

const Test = {
  run: async function (options) {
    expect.options(options, [
      "contracts_directory",
      "contracts_build_directory",
      "migrations_directory",
      "test_files",
      "network",
      "network_id",
      "provider"
    ]);

    const config = Config.default().merge(options);

    config.test_files = config.test_files.map(testFile => {
      return path.resolve(testFile);
    });

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.networks[config.network].type
    });

    // `accounts` will be populated before each contract() invocation
    // and passed to it so tests don't have to call it themselves.
    const web3 = new Web3Shim({
      provider: config.provider,
      networkType: config.networks[config.network].type
        ? config.networks[config.network].type
        : "web3js"
    });

    // Override console.warn() because web3 outputs gross errors to it.
    // e.g., https://github.com/ethereum/web3.js/blob/master/lib/web3/allevents.js#L61
    // Output looks like this during tests: https://gist.github.com/tcoulter/1988349d1ec65ce6b958
    const warn = config.logger.warn;
    config.logger.warn = function (message) {
      if (message === "cannot find event for log") {
        return;
      } else {
        if (warn) warn.apply(console, arguments);
      }
    };

    const mocha = this.createMocha(config);

    const jsTests = config.test_files.filter(file => {
      return path.extname(file) !== ".sol";
    });

    const solTests = config.test_files.filter(file => {
      return path.extname(file) === ".sol";
    });

    // Add Javascript tests because there's nothing we need to do with them.
    // Solidity tests will be handled later.
    jsTests.forEach(file => {
      // There's an idiosyncracy in Mocha where the same file can't be run twice
      // unless we delete the `require` cache.
      // https://github.com/mochajs/mocha/issues/995
      delete originalrequire.cache[file];

      mocha.addFile(file);
    });

    const accounts = await this.getAccounts(interfaceAdapter);

    const testResolver = new Resolver(config, {
      includeTruffleSources: true
    });

    const { compilations } = await this.compileContractsWithTestFilesIfNeeded(
      solTests,
      config,
      testResolver
    );

    const testContracts = solTests.map(testFilePath => {
      return testResolver.require(testFilePath);
    });

    const runner = new TestRunner(config);

    if (config.migrateNone || config["migrate-none"]) {
      if (config.events) {
        config.events.emit("test:migration:skipped");
      }
    } else {
      await this.performInitialDeploy(config, testResolver);
    }

    const sourcePaths = []
      .concat(
        ...compilations.map(compilation => compilation.sourceIndexes) //we don't need the indices here, just the paths
      )
      .filter(path => path); //make sure we don't pass in any undefined

    await this.defineSolidityTests(mocha, testContracts, sourcePaths, runner);

    const debuggerCompilations =
      Codec.Compilations.Utils.shimCompilations(compilations);

    //for stack traces, we'll need to set up a light-mode debugger...
    let bugger;
    if (config.stacktrace) {
      debug("stacktraces on!");
      bugger = await Debugger.forProject({
        compilations: debuggerCompilations,
        provider: config.provider,
        lightMode: true
      });
    }

    await this.setJSTestGlobals({
      config,
      web3,
      interfaceAdapter,
      accounts,
      testResolver,
      runner,
      compilations: debuggerCompilations,
      bugger
    });

    // Finally, run mocha.
    process.on("unhandledRejection", reason => {
      throw reason;
    });

    return new Promise(resolve => {
      this.mochaRunner = mocha.run(failures => {
        config.logger.warn = warn;
        resolve(failures);
      });
    });
  },

  createMocha: function (config) {
    // Allow people to specify config.mocha in their config.
    const mochaConfig = config.mocha || {};

    // Propagate --bail option to mocha
    mochaConfig.bail = config.bail;

    // If the command line overrides color usage, use that.
    if (config.color != null) {
      mochaConfig.color = config.color;
    } else if (config.colors != null) {
      // --colors is a mocha alias for --color
      mochaConfig.color = config.colors;
    }

    // Default to true if configuration isn't set anywhere.
    if (mochaConfig.color == null) {
      mochaConfig.color = true;
    }

    Mocha = mochaConfig.package || __webpack_require__(403270);
    delete mochaConfig.package;
    const mocha = new Mocha(mochaConfig);

    return mocha;
  },

  getAccounts: function (interfaceAdapter) {
    return interfaceAdapter.getAccounts();
  },

  compileContractsWithTestFilesIfNeeded: async function (
    solidityTestFiles,
    config,
    testResolver
  ) {
    const updated =
      (await Profiler.updated(config.with({ resolver: testResolver }))) || [];

    const compiler =
      config.compileNone || config["--compile-none"] ? "none" : config.compiler;

    let compileConfig = config.with({
      all: config.compileAll === true,
      compiler,
      files: updated.concat(solidityTestFiles),
      resolver: testResolver,
      quiet: config.runnerOutputOnly || config.quiet,
      quietWrite: true
    });
    if (config.compileAllDebug) {
      let versionString = ((compileConfig.compilers || {}).solc || {}).version;
      versionString = RangeUtils.resolveToRange(versionString);
      if (RangeUtils.rangeContainsAtLeast(versionString, "0.6.3")) {
        compileConfig = compileConfig.merge({
          compilers: {
            solc: {
              settings: {
                debug: {
                  revertStrings: "debug"
                }
              }
            }
          }
        });
      } else {
        config.logger.log(
          `\n${colors.bold(
            "Warning:"
          )} Extra revert string info requires Solidity v0.6.3 or higher. For more\n  information, see release notes <https://github.com/ethereum/solidity/releases/tag/v0.6.3>`
        );
      }
    }

    // Compile project contracts and test contracts
    const { contracts, compilations } = await WorkflowCompile.compileAndSave(
      compileConfig
    );

    return {
      contracts,
      compilations
    };
  },

  performInitialDeploy: function (config, resolver) {
    const migrateConfig = config.with({
      reset: true,
      resolver: resolver,
      quiet: true
    });
    return Migrate.run(migrateConfig);
  },

  defineSolidityTests: async (mocha, contracts, dependencyPaths, runner) => {
    for (const contract of contracts) {
      await SolidityTest.define(contract, dependencyPaths, runner, mocha);
      debug("defined solidity tests for %s", contract.contractName);
    }
  },

  setJSTestGlobals: async function ({
    config,
    web3,
    interfaceAdapter,
    accounts,
    testResolver,
    runner,
    compilations,
    bugger //for stacktracing
  }) {
    global.interfaceAdapter = interfaceAdapter;
    global.web3 = web3;
    global.assert = chai.assert;
    global.expect = chai.expect;
    global.artifacts = {
      require: importPath => {
        let contract = testResolver.require(importPath);
        //HACK: both of the following should go by means
        //of the provisioner, but I'm not sure how to make
        //that work at the moment
        contract.reloadJson = function () {
          const reloaded = testResolver.require(importPath);
          this._json = reloaded._json;
        };
        if (bugger) {
          contract.debugger = bugger;
        }
        return contract;
      }
    };
    global.config = config.normalize(config);

    global[config.debugGlobal] = async operation => {
      if (!config.debug) {
        config.logger.log(
          `${colors.bold(
            "Warning:"
          )} Invoked in-test debugger without --debug flag. ` +
            `Try: \`truffle test --debug\``
        );
        return operation;
      }

      // wrapped inside function so as not to load debugger on every test
      const { CLIDebugHook } = __webpack_require__(212834);

      // note: this.mochaRunner will be available by the time debug()
      // is invoked
      const hook = new CLIDebugHook(config, compilations, this.mochaRunner);

      return await hook.debug(operation);
    };

    const template = function (tests) {
      this.timeout(runner.TEST_TIMEOUT);

      before("prepare suite", async function () {
        this.timeout(runner.BEFORE_TIMEOUT);
        await runner.initialize();
      });

      beforeEach("before test", async function () {
        await runner.startTest();
      });

      afterEach("after test", async function () {
        await runner.endTest(this);
      });

      tests(accounts);
    };

    global.contract = function (name, tests) {
      Mocha.describe("Contract: " + name, function () {
        template.bind(this, tests)();
      });
    };

    global.contract.only = function (name, tests) {
      Mocha.describe.only("Contract: " + name, function () {
        template.bind(this, tests)();
      });
    };

    global.contract.skip = function (name, tests) {
      Mocha.describe.skip("Contract: " + name, function () {
        template.bind(this, tests)();
      });
    };
  }
};

module.exports = Test;


/***/ }),

/***/ 68710:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createInterfaceAdapter } = __webpack_require__(936339);
const web3Utils = __webpack_require__(118269);
const Config = __webpack_require__(120553);
const Migrate = __webpack_require__(523459);
const { Resolver } = __webpack_require__(648511);
const expect = __webpack_require__(414096);
const util = __webpack_require__(473837);
const fs = __webpack_require__(657147);
const path = __webpack_require__(371017);
const debug = __webpack_require__(615158)("lib:testing:testrunner");
const Decoder = __webpack_require__(18852);
const Codec = __webpack_require__(20102);
const OS = __webpack_require__(822037);

class TestRunner {
  constructor(options = {}) {
    expect.options(options, [
      "resolver",
      "provider",
      "contracts_build_directory"
    ]);
    this.config = Config.default().merge(options);
    this.logger = options.logger || console;
    this.provider = options.provider;

    this.can_snapshot = false;
    this.first_snapshot = true;
    this.initial_snapshot = null;
    this.interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    this.decoder = null;

    // For each test
    this.currentTestStartBlock = null;

    this.BEFORE_TIMEOUT =
      (options.mocha && options.mocha.before_timeout) || 120000;
    this.TEST_TIMEOUT = (options.mocha && options.mocha.timeout) || 300000;
  }

  disableChecksOnEventDecoding() {
    this.disableChecks = true; //used by Solidity testing due to empty string problem on Solidity <0.7.6
  }

  reEnableChecksOnEventDecoding() {
    this.disableChecks = false;
  }

  async initialize() {
    debug("initializing");
    this.config.resolver = new Resolver(this.config, {
      includeTruffleSources: true
    });

    if (this.first_snapshot) {
      debug("taking first snapshot");
      try {
        let initial_snapshot = await this.snapshot();
        this.can_snapshot = true;
        this.initial_snapshot = initial_snapshot;
      } catch (error) {
        debug("first snapshot failed");
        debug("Error: %O", error);
      }
      this.first_snapshot = false;
    } else {
      await this.resetState();
    }

    //set up decoder
    let files = fs
      .readdirSync(this.config.contracts_build_directory)
      .filter(file => path.extname(file) === ".json");
    let data = files.map(file =>
      fs.readFileSync(
        path.join(this.config.contracts_build_directory, file),
        "utf8"
      )
    );
    let artifacts = data.map(text => JSON.parse(text));
    this.decoder = await Decoder.forProject({
      provider: this.provider,
      projectInfo: { artifacts }
    });
  }

  async deploy() {
    await Migrate.run(
      this.config.with({
        reset: true,
        quiet: true
      })
    );
  }

  async resetState() {
    if (this.can_snapshot) {
      debug("reverting...");
      await this.revert(this.initial_snapshot);
      this.initial_snapshot = await this.snapshot();
    } else {
      debug("redeploying...");
      await this.deploy();
    }
  }

  async startTest() {
    let blockNumber = await this.interfaceAdapter.getBlockNumber();
    let one = web3Utils.toBN(1);
    blockNumber = web3Utils.toBN(blockNumber);

    // Add one in base 10
    this.currentTestStartBlock = blockNumber.add(one);
  }

  async endTest(mocha) {
    // Skip logging if test passes and `show-events` option is not true
    if (mocha.currentTest.state !== "failed" && !this.config["show-events"]) {
      return;
    }

    function indent(input, indentation, initialPrefix = "") {
      const unindented = input.split(/\r?\n/);
      return unindented
        .map((line, index) =>
          index === 0
            ? initialPrefix + " ".repeat(indentation - initialPrefix) + line
            : " ".repeat(indentation) + line
        )
        .join(OS.EOL);
    }

    function printEvent(decoding, indentation = 0, initialPrefix = "") {
      debug("raw event: %O", decoding);
      const inspected = util.inspect(
        new Codec.Export.LogDecodingInspector(decoding),
        {
          depth: null,
          colors: true,
          maxArrayLength: null,
          breakLength: 80 - indentation //should this include prefix lengths as well?
        }
      );
      return indent(inspected, indentation, initialPrefix);
    }

    const logs = await this.decoder.events({
      //NOTE: block numbers shouldn't be over 2^53 so this
      //should be fine, but should change this once decoder
      //accepts more general types for blocks
      fromBlock: this.currentTestStartBlock.toNumber(),
      extras: "necessary", //include weird decodings if usual ones fail :P
      disableChecks: this.disableChecks //for Solidity testing
    });

    const userDefinedEventLogs = logs.filter(log => {
      return log.decodings.every(decoding => decoding.abi.name !== "TestEvent");
    });

    if (userDefinedEventLogs.length === 0) {
      this.logger.log("    > No events were emitted");
      return;
    }

    this.logger.log("\n    Events emitted during test:");
    this.logger.log("    ---------------------------");
    this.logger.log("");

    for (const log of userDefinedEventLogs) {
      switch (log.decodings.length) {
        case 0:
          this.logger.log(`    Warning: Could not decode event!`);
          this.logger.log("");
          break;
        case 1:
          this.logger.log(printEvent(log.decodings[0], 4));
          this.logger.log("");
          break;
        default:
          this.logger.log(`    Ambiguous event, possible interpretations:`);
          for (const decoding of log.decodings) {
            this.logger.log(printEvent(decoding, 6, "    * "));
          }
          this.logger.log("");
          break;
      }
    }
    this.logger.log("\n    ---------------------------");
  }

  async snapshot() {
    return (await this.rpc("evm_snapshot")).result;
  }

  async revert(snapshot_id) {
    await this.rpc("evm_revert", [snapshot_id]);
  }

  async rpc(method, arg) {
    let request = {
      jsonrpc: "2.0",
      method: method,
      id: Date.now(),
      params: arg
    };

    let result = await util.promisify(this.provider.send)(request);

    if (result.error != null) {
      throw new Error("RPC Error: " + (result.error.message || result.error));
    }

    return result;
  }
}

module.exports = TestRunner;


/***/ }),

/***/ 408580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const web3Utils = __webpack_require__(118269);

module.exports = function (chai, _utils) {
  var assert = chai.assert;
  chai.Assertion.addProperty("address", function () {
    this.assert(
      this._obj.length === 42,
      "expected #{this} to be a 42 character address (0x...)",
      "expected #{this} to not be a 42 character address (0x...)"
    );

    // Convert address to a number. Make sure it's not zero.
    // Controversial: Technically there is that edge case where
    // all zeroes could be a valid address. But: This catches all
    // those cases where Ethereum returns 0x0000... if something fails.
    const number = web3Utils.toBN(this._obj);
    this.assert(
      !number.isZero(),
      "expected address #{this} to not be zero",
      "you shouldn't ever see this."
    );
  });
  assert.isAddress = function (val, exp, msg) {
    return new chai.Assertion(val, msg).to.be.address;
  };
};


/***/ }),

/***/ 287352:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 287352;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 557817:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 557817;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 990670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;
const fc = __importStar(__webpack_require__(696418));
const faker_1 = __importDefault(__webpack_require__(285384));
const change_case_1 = __webpack_require__(377159);
const Parameter = () => fc
    .tuple(fc.record({
    name: ParameterName()
}), TypeRecord())
    .map(([{ name }, type]) => (Object.assign({ name }, type)));
exports.Parameter = Parameter;
const EventParameter = () => fc
    .tuple(fc.record({
    name: ParameterName(),
    indexed: fc.boolean()
}), TypeRecord())
    .map(([{ name, indexed }, type]) => (Object.assign({ name, indexed }, type)));
exports.EventParameter = EventParameter;
const EventEntry = () => fc.record({
    type: fc.constant("event"),
    name: EventName(),
    inputs: fc.array(exports.EventParameter(), { maxLength: 10 }).filter(inputs => {
        if (inputs.filter(({ indexed }) => indexed).length > 3) {
            // only up to 3 params can be indexed
            return false;
        }
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter(name => name !== "");
        return names.length === new Set(names).size;
    }),
    anonymous: fc.boolean()
});
exports.EventEntry = EventEntry;
const ErrorEntry = () => fc.record({
    type: fc.constant("error"),
    name: ErrorName(),
    inputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter(inputs => {
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter(name => name !== "");
        return names.length === new Set(names).size;
    })
});
exports.ErrorEntry = ErrorEntry;
const FunctionEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("function")
}, { withDeletedKeys: true }), fc.record({
    name: FunctionName(),
    inputs: fc.array(exports.Parameter(), { maxLength: 10 })
}), fc.record({
    outputs: fc.array(exports.Parameter(), { maxLength: 10 })
}, { withDeletedKeys: true }), fc
    .tuple(fc.oneof(fc.constant("pure"), fc.constant("view"), fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const constant = stateMutability === "view" || stateMutability === "pure";
    const modern = { stateMutability };
    const legacy = { payable, constant };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(records => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}))
    .filter(entry => {
    const { inputs, outputs = [] } = entry;
    // names that are not blank should be unique
    const names = [...inputs, ...outputs]
        .map(({ name }) => name)
        .filter(name => name !== "");
    return names.length === new Set(names).size;
});
exports.FunctionEntry = FunctionEntry;
const ReceiveEntry = () => fc.record({
    type: fc.constant("receive"),
    stateMutability: fc.constant("payable")
});
exports.ReceiveEntry = ReceiveEntry;
const FallbackEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("fallback")
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const modern = { stateMutability };
    const legacy = { payable };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(([{ type }, mutabilityFields]) => (Object.assign({ type }, mutabilityFields)));
exports.FallbackEntry = FallbackEntry;
const ConstructorEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("constructor"),
    inputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter(inputs => {
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter(name => name !== "");
        return names.length === new Set(names).size;
    })
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const modern = { stateMutability };
    const legacy = { payable };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(([{ type, inputs }, mutabilityFields]) => (Object.assign({ type,
    inputs }, mutabilityFields)));
exports.ConstructorEntry = ConstructorEntry;
const Abi = () => fc
    .tuple(exports.ConstructorEntry(), exports.FallbackEntry(), exports.ReceiveEntry(), fc.array(fc.oneof(exports.FunctionEntry(), exports.EventEntry(), exports.ErrorEntry())))
    .chain(([constructor, fallback, receive, entries]) => fc.shuffledSubarray([constructor, fallback, receive, ...entries]));
exports.Abi = Abi;
var Numerics;
(function (Numerics) {
    // 0 < n <= 32
    // use subtraction so that fast-check treats 32 as simpler than 1
    Numerics.Bytes = () => fc.nat(31).map(k => 32 - k);
    // 0 < n <= 256, 8 | n
    Numerics.Bits = () => Numerics.Bytes().map(k => 8 * k);
    // 0 < n <= 80
    // use fancy math so that fast-check treats 18 as the simplest case
    //
    //     0 ----------------- 79
    //     lines up as:
    //     18 ------ 80, 0 --- 17
    Numerics.DecimalPlaces = () => fc.nat(79).map(k => ((k + 17) % 80) + 1);
    Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());
})(Numerics || (Numerics = {}));
var Primitives;
(function (Primitives) {
    Primitives.Uint = () => Numerics.Bits().map(m => `uint${m}`);
    Primitives.Int = () => Numerics.Bits().map(m => `int${m}`);
    Primitives.Address = () => fc.constant("address");
    Primitives.Bool = () => fc.constant("bool");
    Primitives.Fixed = () => Numerics.Precision().map(([m, n]) => `fixed${m}x${n}`);
    Primitives.Ufixed = () => Numerics.Precision().map(([m, n]) => `ufixed${m}x${n}`);
    Primitives.BytesM = () => Numerics.Bytes().map(m => `bytes${m}`);
    Primitives.Function = () => fc.constant("function");
    Primitives.Bytes = () => fc.constant("bytes");
    Primitives.String = () => fc.constant("string");
    Primitives.Tuple = () => fc.constant("tuple");
})(Primitives || (Primitives = {}));
const Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());
const Type = fc.memo(n => n === 0
    ? Primitive()
    : // we cap this at 3 so that fast-check doesn't blow the stack
        fc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));
const ArrayFixed = fc.memo(n => fc
    .tuple(Type(n - 1), fc.integer(1, 256))
    .map(([type, length]) => `${type}[${length}]`));
const ArrayDynamic = fc.memo(n => Type(n - 1).map(type => `${type}[]`));
const reservedWords = new Set([
    "Error",
    "Panic",
    "_",
    "abi",
    "abstract",
    "addmod",
    "address",
    "after",
    "alias",
    "anonymous",
    "apply",
    "as",
    "assembly",
    "assert",
    "auto",
    "block",
    "blockhash",
    "bool",
    "break",
    "byte",
    "bytes",
    "calldata",
    "case",
    "catch",
    "constant",
    "constructor",
    "continue",
    "contract",
    "copyof",
    "days",
    "default",
    "define",
    "delete",
    "ecrecover",
    "else",
    "emit",
    "enum",
    "error",
    "ether",
    "event",
    "external",
    "fallback",
    "false",
    "final",
    "finney",
    "fixed",
    "for",
    "from",
    "function",
    "gasleft",
    "gwei",
    "hours",
    "if",
    "immutable",
    "implements",
    "import",
    "in",
    "indexed",
    "inline",
    "int",
    "interface",
    "internal",
    "is",
    "keccak256",
    "let",
    "library",
    "log0",
    "log1",
    "log2",
    "log3",
    "log4",
    "macro",
    "mapping",
    "match",
    "memory",
    "minutes",
    "modifier",
    "msg",
    "mulmod",
    "mutable",
    "new",
    "now",
    "null",
    "of",
    "override",
    "partial",
    "payable",
    "pragma",
    "private",
    "promise",
    "public",
    "pure",
    "receive",
    "reference",
    "relocatable",
    "require",
    "return",
    "returns",
    "revert",
    "ripemd160",
    "sealed",
    "seconds",
    "selfdestruct",
    "sha256",
    "sha3",
    "sizeof",
    "static",
    "storage",
    "string",
    "struct",
    "suicide",
    "super",
    "supports",
    "switch",
    "szabo",
    "this",
    "throw",
    "true",
    "try",
    "tx",
    "type",
    "typedef",
    "typeof",
    "ufixed",
    "uint",
    "unchecked",
    "using",
    "var",
    "view",
    "virtual",
    "weeks",
    "wei",
    "while",
    "years"
]);
// borrowed from https://runkit.com/dubzzz/faker-to-fast-check
const fakerToArb = (template, transform = change_case_1.camelCase) => {
    return fc
        .integer()
        .noBias()
        .noShrink()
        .map(seed => {
        faker_1.default.seed(seed);
        return transform(faker_1.default.fake(template));
    })
        .filter(word => !reservedWords.has(word));
};
const ParameterName = () => fc.frequency({ arbitrary: fakerToArb("{{hacker.noun}}"), weight: 9 }, { arbitrary: fc.constant(""), weight: 1 });
const EventName = () => fakerToArb("{{hacker.verb}} {{hacker.noun}}", change_case_1.pascalCase);
const ErrorName = () => fakerToArb("{{hacker.noun}} {{hacker.noun}}", change_case_1.pascalCase);
const FunctionName = () => fakerToArb("{{hacker.verb}} {{hacker.noun}}");
const TypeRecord = () => Type().chain(type => type.startsWith("tuple")
    ? fc.record({
        type: fc.constant(type),
        components: fc
            .array(exports.Parameter().filter(({ name }) => name !== ""), { minLength: 1, maxLength: 5 })
            .filter(items => {
            const names = items
                .map(({ name }) => name)
                .filter(name => name !== "");
            return names.length === new Set(names).size;
        })
    })
    : fc.record({
        type: fc.constant(type)
    }));
//# sourceMappingURL=arbitrary.js.map

/***/ }),

/***/ 207651:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Arbitrary = void 0;
__exportStar(__webpack_require__(851931), exports);
__exportStar(__webpack_require__(857794), exports);
const Arbitrary = __importStar(__webpack_require__(990670));
exports.Arbitrary = Arbitrary;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 857794:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeEntry = exports.normalize = void 0;
const normalize = (looseAbi) => looseAbi.map(exports.normalizeEntry);
exports.normalize = normalize;
const normalizeEntry = (looseEntry) => {
    if (looseEntry.type === "event" || looseEntry.type === "error") {
        // nothing gets normalized for events or errors right now
        return looseEntry;
    }
    const entry = Object.assign(Object.assign(Object.assign({}, looseEntry), normalizeStateMutability(looseEntry)), { type: looseEntry.type || "function" });
    if (entry.type === "function") {
        entry.outputs = entry.outputs || [];
    }
    delete entry.payable;
    delete entry.constant;
    return entry;
};
exports.normalizeEntry = normalizeEntry;
const normalizeStateMutability = ({ stateMutability, payable, constant }) => {
    if (stateMutability) {
        return { stateMutability };
    }
    return {
        stateMutability: payable ? "payable" : constant ? "view" : "nonpayable"
    };
};
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ 851931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 529463:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const contract_schema_1 = __importDefault(__webpack_require__(418370));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const path_1 = __importDefault(__webpack_require__(371017));
const os_1 = __importDefault(__webpack_require__(822037));
const utils_1 = __webpack_require__(437285);
const debug = __webpack_require__(615158)("artifactor");
class Artifactor {
    constructor(destination) {
        this.destination = destination;
    }
    save(artifactObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalizedNewArtifact = contract_schema_1.default.normalize(artifactObject);
            const contractName = normalizedNewArtifact.contractName;
            if (!contractName)
                throw new Error("You must specify a contract name.");
            const outputPath = path_1.default.join(this.destination, `${contractName}.json`);
            try {
                const existingArtifact = fs_extra_1.default.readFileSync(outputPath, "utf8"); // check if artifact already exists
                const existingArtifactObject = JSON.parse(existingArtifact); // parse existing artifact
                const normalizedExistingArtifact = contract_schema_1.default.normalize(existingArtifactObject);
                const completeArtifact = utils_1.finalizeArtifact(normalizedExistingArtifact, normalizedNewArtifact);
                utils_1.writeArtifact(completeArtifact, outputPath);
            }
            catch (e) {
                // if artifact doesn't already exist, write new file
                if (e.code === "ENOENT")
                    return utils_1.writeArtifact(normalizedNewArtifact, outputPath);
                else if (e instanceof SyntaxError)
                    throw e; // catches improperly formatted artifact json
                throw e; // catch all other errors
            }
        });
    }
    saveAll(artifactObjects) {
        return __awaiter(this, void 0, void 0, function* () {
            let newArtifactObjects = {};
            if (Array.isArray(artifactObjects)) {
                const tmpArtifactArray = artifactObjects;
                tmpArtifactArray.forEach(artifactObj => {
                    const contractName = artifactObj.contract_name || artifactObj.contractName;
                    if (newArtifactObjects[contractName]) {
                        console.warn(`${os_1.default.EOL}> Duplicate contract names found for ${contractName}.${os_1.default.EOL}` +
                            `> This can cause errors and unknown behavior. Please rename one of your contracts.`);
                    }
                    newArtifactObjects[contractName] = artifactObj;
                });
            }
            else {
                newArtifactObjects = artifactObjects;
            }
            try {
                fs_extra_1.default.statSync(this.destination); // check if destination exists
            }
            catch (e) {
                if (e.code === "ENOENT")
                    // if destination doesn't exist, throw error
                    throw new Error(`Destination "${this.destination}" doesn't exist!`);
                throw e; // throw on all other errors
            }
            Object.keys(newArtifactObjects).forEach(contractName => {
                let artifactObject = newArtifactObjects[contractName];
                this.save(artifactObject);
            });
        });
    }
}
module.exports = Artifactor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 437285:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.finalizeArtifact = exports.writeArtifact = void 0;
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const merge_1 = __importDefault(__webpack_require__(894853));
const assign_1 = __importDefault(__webpack_require__(75006));
function writeArtifact(completeArtifact, outputPath) {
    completeArtifact.updatedAt = new Date().toISOString();
    fs_extra_1.default.writeFileSync(outputPath, JSON.stringify(completeArtifact, null, 2), "utf8");
}
exports.writeArtifact = writeArtifact;
function finalizeArtifact(normalizedExistingArtifact, normalizedNewArtifact) {
    const knownNetworks = merge_1.default({}, normalizedExistingArtifact.networks, normalizedNewArtifact.networks);
    const completeArtifact = assign_1.default({}, normalizedExistingArtifact, normalizedNewArtifact, { networks: knownNetworks });
    return completeArtifact;
}
exports.finalizeArtifact = finalizeArtifact;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 986317:
/***/ ((module) => {

"use strict";

const Blockchain = {
    getBlockByNumber(blockNumber, provider, callback) {
        const params = [blockNumber, true];
        provider.send({
            jsonrpc: "2.0",
            method: "eth_getBlockByNumber",
            params,
            id: Date.now()
        }, callback);
    },
    getBlockByHash(blockHash, provider, callback) {
        const params = [blockHash, true];
        provider.send({
            jsonrpc: "2.0",
            method: "eth_getBlockByHash",
            params,
            id: Date.now()
        }, callback);
    },
    parse(uri) {
        const parsed = {};
        if (uri.indexOf("blockchain://") !== 0)
            return parsed;
        const cleanUri = uri.replace("blockchain://", "");
        const pieces = cleanUri.split("/block/");
        parsed.genesis_hash = `0x${pieces[0]}`;
        parsed.block_hash = `0x${pieces[1]}`;
        return parsed;
    },
    asURI(provider) {
        return new Promise((resolve, reject) => {
            let genesis, latest;
            this.getBlockByNumber("0x0", provider, (err, { result }) => {
                if (err)
                    return reject(err);
                genesis = result;
                this.getBlockByNumber("latest", provider, (err, { result }) => {
                    if (err)
                        return reject(err);
                    latest = result;
                    const url = `blockchain://${genesis.hash.replace("0x", "")}/block/${latest.hash.replace("0x", "")}`;
                    resolve(url);
                });
            });
        });
    },
    matches(uri, provider) {
        return new Promise((resolve, reject) => {
            const parsedUri = this.parse(uri);
            const expectedGenesis = parsedUri.genesis_hash;
            const expectedBlock = parsedUri.block_hash;
            this.getBlockByNumber("0x0", provider, (err, { result }) => {
                if (err)
                    return reject(err);
                const block = result;
                if (block.hash !== expectedGenesis)
                    return resolve(false);
                this.getBlockByHash(expectedBlock, provider, (err, { result }) => {
                    // Treat an error as if the block didn't exist. This is because
                    // some clients respond differently.
                    const block = result;
                    if (err || block == null) {
                        return resolve(false);
                    }
                    resolve(true);
                });
            });
        });
    }
};
module.exports = Blockchain;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 908135:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseCode = void 0;
const opcodes_1 = __importDefault(__webpack_require__(489537));
const cbor = __importStar(__webpack_require__(82141));
/**
 * parseCode - return a list of instructions given a 0x-prefixed code string.
 *
 * If numInstructions is not passed in, we attempt to strip contract
 * metadata.  This won't work very well if the code is for a constructor or a
 * contract that can create other contracts, but it's better than nothing.
 *
 * WARNING: Don't invoke the function that way if you're dealing with a
 * constructor with arguments attached!  Then you could get disaster!
 *
 * If you pass in numInstructions (hint: count the semicolons in the source
 * map, then add one) this is used to exclude metadata instead.
 *
 * @param  {String} hexString Hex string representing the code
 * @return Array               Array of instructions
 */
function parseCode(hexString, numInstructions = null) {
    // Convert to an array of bytes
    let code = new Uint8Array((hexString.slice(2).match(/(..?)/g) || []).map(hex => parseInt(hex, 16)));
    const stripMetadata = numInstructions === null;
    if (stripMetadata && code.length >= 2) {
        // Remove the contract metadata; last two bytes encode its length (not
        // including those two bytes)
        const metadataLength = (code[code.length - 2] << 8) + code[code.length - 1];
        //check: is this actually valid CBOR?
        if (metadataLength + 2 <= code.length) {
            const metadata = code.subarray(-(metadataLength + 2), -2);
            if (isValidCBOR(metadata)) {
                code = code.subarray(0, -(metadataLength + 2));
            }
        }
    }
    let instructions = [];
    for (let pc = 0; pc < code.length &&
        (stripMetadata || instructions.length < numInstructions); pc++) {
        let opcode = {
            pc,
            name: opcodes_1.default(code[pc])
        };
        if (opcode.name.slice(0, 4) === "PUSH") {
            const length = code[pc] - 0x60 + 1; //0x60 is code for PUSH1
            let pushData = code.subarray(pc + 1, pc + length + 1);
            if (pushData.length < length) {
                //if we run out of bytes for our pushdata, fill the rest
                //with zeroes
                pushData = Uint8Array.from([
                    ...pushData,
                    ...new Uint8Array(length - pushData.length)
                ]);
            }
            // convert pushData to hex
            opcode.pushData = `0x${Buffer.from(pushData).toString("hex")}`;
            pc += length;
        }
        instructions.push(opcode);
    }
    return instructions;
}
exports.parseCode = parseCode;
exports["default"] = {
    //for compatibility
    parseCode
};
function isValidCBOR(metadata) {
    try {
        //attempt to decode but discard the value
        //note this *will* throw if there's data left over,
        //which is what we want it to do
        cbor.decodeFirstSync(metadata);
    }
    catch (_a) {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 489537:
/***/ ((module) => {

"use strict";

const codes = {
    0x00: "STOP",
    0x01: "ADD",
    0x02: "MUL",
    0x03: "SUB",
    0x04: "DIV",
    0x05: "SDIV",
    0x06: "MOD",
    0x07: "SMOD",
    0x08: "ADDMOD",
    0x09: "MULMOD",
    0x0a: "EXP",
    0x0b: "SIGNEXTEND",
    // 0x10 range - bit ops
    0x10: "LT",
    0x11: "GT",
    0x12: "SLT",
    0x13: "SGT",
    0x14: "EQ",
    0x15: "ISZERO",
    0x16: "AND",
    0x17: "OR",
    0x18: "XOR",
    0x19: "NOT",
    0x1a: "BYTE",
    0x1b: "SHL",
    0x1c: "SHR",
    0x1d: "SAR",
    // 0x20 range - crypto
    0x20: "SHA3",
    // 0x30 range - closure state
    0x30: "ADDRESS",
    0x31: "BALANCE",
    0x32: "ORIGIN",
    0x33: "CALLER",
    0x34: "CALLVALUE",
    0x35: "CALLDATALOAD",
    0x36: "CALLDATASIZE",
    0x37: "CALLDATACOPY",
    0x38: "CODESIZE",
    0x39: "CODECOPY",
    0x3a: "GASPRICE",
    0x3b: "EXTCODESIZE",
    0x3c: "EXTCODECOPY",
    0x3d: "RETURNDATASIZE",
    0x3e: "RETURNDATACOPY",
    0x3f: "EXTCODEHASH",
    // 0x40 range - block operations
    0x40: "BLOCKHASH",
    0x41: "COINBASE",
    0x42: "TIMESTAMP",
    0x43: "NUMBER",
    0x44: "DIFFICULTY",
    0x45: "GASLIMIT",
    0x46: "CHAINID",
    0x47: "SELFBALANCE",
    0x48: "BASEFEE",
    // 0x50 range - 'storage' and execution
    0x50: "POP",
    0x51: "MLOAD",
    0x52: "MSTORE",
    0x53: "MSTORE8",
    0x54: "SLOAD",
    0x55: "SSTORE",
    0x56: "JUMP",
    0x57: "JUMPI",
    0x58: "PC",
    0x59: "MSIZE",
    0x5a: "GAS",
    0x5b: "JUMPDEST",
    // 0x60 & 0x70 range - pushes
    0x60: "PUSH1",
    0x61: "PUSH2",
    0x62: "PUSH3",
    0x63: "PUSH4",
    0x64: "PUSH5",
    0x65: "PUSH6",
    0x66: "PUSH7",
    0x67: "PUSH8",
    0x68: "PUSH9",
    0x69: "PUSH10",
    0x6a: "PUSH11",
    0x6b: "PUSH12",
    0x6c: "PUSH13",
    0x6d: "PUSH14",
    0x6e: "PUSH15",
    0x6f: "PUSH16",
    0x70: "PUSH17",
    0x71: "PUSH18",
    0x72: "PUSH19",
    0x73: "PUSH20",
    0x74: "PUSH21",
    0x75: "PUSH22",
    0x76: "PUSH23",
    0x77: "PUSH24",
    0x78: "PUSH25",
    0x79: "PUSH26",
    0x7a: "PUSH27",
    0x7b: "PUSH28",
    0x7c: "PUSH29",
    0x7d: "PUSH30",
    0x7e: "PUSH31",
    0x7f: "PUSH32",
    // 0x80 range - duplication
    0x80: "DUP1",
    0x81: "DUP2",
    0x82: "DUP3",
    0x83: "DUP4",
    0x84: "DUP5",
    0x85: "DUP6",
    0x86: "DUP7",
    0x87: "DUP8",
    0x88: "DUP9",
    0x89: "DUP10",
    0x8a: "DUP11",
    0x8b: "DUP12",
    0x8c: "DUP13",
    0x8d: "DUP14",
    0x8e: "DUP15",
    0x8f: "DUP16",
    // 0x90 range - swaps
    0x90: "SWAP1",
    0x91: "SWAP2",
    0x92: "SWAP3",
    0x93: "SWAP4",
    0x94: "SWAP5",
    0x95: "SWAP6",
    0x96: "SWAP7",
    0x97: "SWAP8",
    0x98: "SWAP9",
    0x99: "SWAP10",
    0x9a: "SWAP11",
    0x9b: "SWAP12",
    0x9c: "SWAP13",
    0x9d: "SWAP14",
    0x9e: "SWAP15",
    0x9f: "SWAP16",
    // '0xa0' range - logging
    0xa0: "LOG0",
    0xa1: "LOG1",
    0xa2: "LOG2",
    0xa3: "LOG3",
    0xa4: "LOG4",
    // '0xf0' range - closures
    0xf0: "CREATE",
    0xf1: "CALL",
    0xf2: "CALLCODE",
    0xf3: "RETURN",
    0xf4: "DELEGATECALL",
    0xf5: "CREATE2",
    0xfa: "STATICCALL",
    0xfd: "REVERT",
    //(we can omit 0xfe INVALID)
    0xff: "SELFDESTRUCT"
};
module.exports = (op) => (codes[op] ? codes[op] : "INVALID");
//# sourceMappingURL=opcodes.js.map

/***/ }),

/***/ 151325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:allocate");
exports.Utils = __importStar(__webpack_require__(865700));
const Import = __importStar(__webpack_require__(753137));
const AbiDataUtils = __importStar(__webpack_require__(785941));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const Evm = __importStar(__webpack_require__(149218));
const Common = __importStar(__webpack_require__(299987));
const Conversion = __importStar(__webpack_require__(152714));
const Ast = __importStar(__webpack_require__(114442));
const import_1 = __webpack_require__(560013);
const Format = __importStar(__webpack_require__(429965));
const partition_1 = __importDefault(__webpack_require__(698069));
exports.FallbackOutputAllocation = {
    kind: "returnmessage",
    selector: new Uint8Array(),
    allocationMode: "full"
};
function getAbiAllocations(userDefinedTypes) {
    let allocations = {};
    for (const dataType of Object.values(userDefinedTypes)) {
        if (dataType.typeClass === "struct") {
            try {
                allocations = allocateStruct(dataType, userDefinedTypes, allocations);
            }
            catch (_) {
                //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                //note: a better way of handling this would probably be to *mark* it
                //as failed rather than throwing an exception as that would lead to less
                //recomputation, but this is simpler and I don't think the recomputation
                //should really be a problem
            }
        }
    }
    return allocations;
}
exports.getAbiAllocations = getAbiAllocations;
function allocateStruct(dataType, userDefinedTypes, existingAllocations) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);
}
//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's
//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)
function allocateMembers(parentId, members, userDefinedTypes, existingAllocations, start = 0) {
    let dynamic = false;
    //note that we will mutate the start argument also!
    //don't allocate things that have already been allocated
    if (parentId in existingAllocations) {
        return existingAllocations;
    }
    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    let memberAllocations = [];
    for (const member of members) {
        let length;
        let dynamicMember;
        ({
            size: length,
            dynamic: dynamicMember,
            allocations
        } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));
        //vomit on illegal types in calldata -- note the short-circuit!
        if (length === undefined) {
            allocations[parentId] = null;
            return allocations;
        }
        let pointer = {
            location: "abi",
            start,
            length
        };
        memberAllocations.push({
            name: member.name,
            type: member.type,
            pointer
        });
        start += length;
        dynamic = dynamic || dynamicMember;
    }
    allocations[parentId] = {
        members: memberAllocations,
        length: dynamic ? Evm.Utils.WORD_SIZE : start,
        dynamic
    };
    return allocations;
}
//first return value is the actual size.
//second return value is whether the type is dynamic
//both will be undefined if type is a mapping or internal function
//third return value is resulting allocations, INCLUDING the ones passed in
function abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {
    switch (dataType.typeClass) {
        case "bool":
        case "address":
        case "contract":
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
        case "enum":
        case "userDefinedValueType":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: false,
                allocations: existingAllocations
            };
        case "string":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: true,
                allocations: existingAllocations
            };
        case "bytes":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: dataType.kind === "dynamic",
                allocations: existingAllocations
            };
        case "mapping":
            return {
                allocations: existingAllocations
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    return {
                        size: Evm.Utils.WORD_SIZE,
                        dynamic: false,
                        allocations: existingAllocations
                    };
                case "internal":
                    return {
                        allocations: existingAllocations
                    };
            }
        case "array": {
            switch (dataType.kind) {
                case "dynamic":
                    return {
                        size: Evm.Utils.WORD_SIZE,
                        dynamic: true,
                        allocations: existingAllocations
                    };
                case "static":
                    if (dataType.length.isZero()) {
                        //arrays of length 0 are static regardless of base type
                        return {
                            size: 0,
                            dynamic: false,
                            allocations: existingAllocations
                        };
                    }
                    const { size: baseSize, dynamic, allocations } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);
                    return {
                        //WARNING!  The use of toNumber() here may throw an exception!
                        //I'm judging this OK since if you have arrays that large we have bigger problems :P
                        size: dataType.length.toNumber() * baseSize,
                        dynamic,
                        allocations
                    };
            }
        }
        case "struct": {
            let allocations = existingAllocations;
            let allocation = allocations[dataType.id];
            if (allocation === undefined) {
                //if we don't find an allocation, we'll have to do the allocation ourselves
                const storedType = (userDefinedTypes[dataType.id]);
                if (!storedType) {
                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                }
                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                allocation = allocations[storedType.id];
            }
            //having found our allocation, if it's not null, we can just look up its size and dynamicity
            if (allocation !== null) {
                return {
                    size: allocation.length,
                    dynamic: allocation.dynamic,
                    allocations
                };
            }
            //if it is null, this type doesn't go in the abi
            else {
                return {
                    allocations
                };
            }
        }
        case "tuple": {
            //Warning! Yucky wasteful recomputation here!
            let size = 0;
            let dynamic = false;
            //note that we don't just invoke allocateStruct here!
            //why not? because it has no ID to store the result in!
            //and we can't use a fake like -1 because there might be a recursive call to it,
            //and then the results would overwrite each other
            //I mean, we could do some hashing thing or something, but I think it's easier to just
            //copy the logic in this one case (sorry)
            for (let member of dataType.memberTypes) {
                let { size: memberSize, dynamic: memberDynamic } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);
                size += memberSize;
                dynamic = dynamic || memberDynamic;
            }
            return { size, dynamic, allocations: existingAllocations };
        }
    }
}
//assumes you've already done allocation! don't use if you haven't!
/**
 * @protected
 */
function abiSizeInfo(dataType, allocations) {
    let { size, dynamic } = abiSizeAndAllocate(dataType, null, allocations);
    //the above line should work fine... as long as allocation is already done!
    //the middle argument, userDefinedTypes, is only needed during allocation
    //again, this function is only for use if allocation is done, so it's safe to pass null here
    return { size, dynamic };
}
exports.abiSizeInfo = abiSizeInfo;
//allocates an external call
//NOTE: returns just a single allocation; assumes primary allocation is already complete!
//NOTE: returns undefined if attempting to allocate a constructor but we don't have the
//bytecode for the constructor
function allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {
    //first: determine the corresponding function node
    //(simultaneously: determine the offset)
    let node = undefined;
    let inputParametersFull;
    let outputParametersFull;
    let inputParametersAbi;
    let outputParametersAbi;
    let offset; //refers to INPUT offset; output offset is always 0
    debug("allocating calldata and returndata");
    switch (abiEntry.type) {
        case "constructor":
            if (!constructorContext) {
                return undefined;
            }
            let rawLength = constructorContext.binary.length;
            offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring
            //for a constructor, we only want to search the particular contract
            if (contractNode) {
                node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(
                //note this needn't actually be a function node, but then it will
                //return false (well, unless it's a getter node!)
                abiEntry, functionNode, referenceDeclarations));
            }
            //if we can't find it, we'll handle this below
            break;
        case "function":
            offset = Evm.Utils.SELECTOR_SIZE;
            //search through base contracts, from most derived (left) to most base (right)
            if (contractNode) {
                const linearizedBaseContracts = contractNode.linearizedBaseContracts;
                debug("linearized: %O", linearizedBaseContracts);
                node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!
                debug("found node: %o", Boolean(node));
            }
            break;
    }
    //now: get the parameters (both full-mode & ABI)
    if (node) {
        switch (node.nodeType) {
            case "FunctionDefinition":
                //normal case
                inputParametersFull = node.parameters.parameters;
                outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!
                break;
            case "VariableDeclaration":
                //getter case
                ({ inputs: inputParametersFull, outputs: outputParametersFull } =
                    Ast.Utils.getterParameters(node, referenceDeclarations));
                break;
        }
    }
    else {
        inputParametersFull = undefined;
        outputParametersFull = undefined;
    }
    inputParametersAbi = abiEntry.inputs;
    switch (abiEntry.type) {
        case "function":
            outputParametersAbi = abiEntry.outputs;
            break;
        case "constructor":
            //we just leave this empty for constructors
            outputParametersAbi = [];
            break;
    }
    //now: do the allocation!
    let { allocation: abiAllocationInput, mode: inputMode } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);
    let { allocation: abiAllocationOutput, mode: outputMode } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler
    //note no offset
    );
    debug("modes: %s in, %s out", inputMode, outputMode);
    //finally: transform the allocation appropriately
    let inputArgumentsAllocation = abiAllocationInput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "calldata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    let outputArgumentsAllocation = abiAllocationOutput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "returndata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    let inputsAllocation = {
        abi: abiEntry,
        offset,
        arguments: inputArgumentsAllocation,
        allocationMode: inputMode
    };
    let outputsAllocation;
    switch (abiEntry.type) {
        case "function":
            outputsAllocation = {
                selector: new Uint8Array(),
                arguments: outputArgumentsAllocation,
                allocationMode: outputMode,
                kind: "return"
            };
            break;
        case "constructor":
            outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);
            break;
    }
    return {
        input: inputsAllocation,
        output: outputsAllocation
    }; //TS chokes on this for some reason
}
//note: allocateEvent doesn't use this because it needs additional
//handling for indexed parameters (maybe these can be unified in
//the future though?)
function allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler, offset = 0) {
    let allocationMode = fullModeParameters ? "full" : "abi"; //can degrade
    let parameterTypes;
    let abiAllocation;
    if (allocationMode === "full") {
        let id = "-1"; //fake ID that doesn't matter
        parameterTypes = fullModeParameters.map(parameter => ({
            name: parameter.name,
            type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!
        }));
        debug("parameterTypes: %O", parameterTypes);
        //now: perform the allocation!
        try {
            abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];
        }
        catch (_a) {
            //if something goes wrong, switch to ABI mdoe
            debug("falling back to ABI due to exception!");
            allocationMode = "abi";
        }
    }
    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        //this is the ABI case.  we end up here EITHER
        //if node doesn't exist, OR if something went wrong
        //during allocation
        let id = "-1"; //fake irrelevant ID
        parameterTypes = abiParameters.map(parameter => ({
            name: parameter.name,
            type: Import.abiParameterToType(parameter)
        }));
        abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];
    }
    return { allocation: abiAllocation, mode: allocationMode };
}
//allocates an event
//NOTE: returns just a single allocation; assumes primary allocation is already complete!
function allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let parameterTypes;
    let nodeId;
    let id;
    //first: determine the corresponding event node
    //search through base contracts, from most derived (right) to most base (left)
    let node = undefined;
    let definedIn = undefined;
    let allocationMode = "full"; //degrade to abi as needed
    debug("allocating ABI: %O", abiEntry);
    if (contractNode) {
        //first: check same contract for the event
        node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(
        //note this needn't actually be an event node, but then it will
        //return false
        abiEntry, eventNode, referenceDeclarations));
        //if we found the node, great!  If not...
        if (!node) {
            debug("didn't find node in base contract...");
            //let's search for the node among the base contracts.
            //but if we find it...
            //[note: the following code is overcomplicated; it was used
            //when we were trying to get the actual node, it's overcomplicated
            //now that we're just determining its presence.  oh well]
            let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
            linearizedBaseContractsMinusSelf.shift(); //remove self
            debug("checking contracts: %o", linearizedBaseContractsMinusSelf);
            node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(
            //note this needn't actually be a event node, but then it will return false
            abiEntry, eventNode, referenceDeclarations)
            //don't pass deriveContractNode here, we're not checking the contract itself
            ).node; //may be undefined! that's OK!
            if (node) {
                //...if we find the node in an ancestor, we
                //deliberately *don't* allocate!  instead such cases
                //will be handled during a later combination step
                debug("bailing out for later handling!");
                debug("ABI: %O", abiEntry);
                return undefined;
            }
        }
    }
    //otherwise, leave node undefined
    if (node) {
        debug("found node");
        //if we found the node, let's also turn it into a type
        definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler)); //can skip reference declarations argument here
        //...and set the ID
        id = import_1.makeTypeId(node.id, compilationId);
    }
    else {
        //if no node, have to fall back into ABI mode
        debug("falling back to ABI because no node");
        allocationMode = "abi";
    }
    //now: construct the list of parameter types, attaching indexedness info
    //and overall position (for later reconstruction)
    let indexed;
    let nonIndexed;
    let abiAllocation; //the untransformed allocation for the non-indexed parameters
    if (allocationMode === "full") {
        nodeId = node.id.toString();
        let parameters = node.parameters.parameters;
        parameterTypes = parameters.map(definition => ({
            //note: if node is defined, compiler had better be defined, too!
            type: Ast.Import.definitionToType(definition, compilationId, compiler),
            name: definition.name,
            indexed: definition.indexed
        }));
        //now: split the list of parameters into indexed and non-indexed
        [indexed, nonIndexed] = partition_1.default(parameterTypes, (parameter) => parameter.indexed);
        try {
            //now: perform the allocation for the non-indexed parameters!
            abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair
        }
        catch (_a) {
            allocationMode = "abi";
        }
    }
    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        nodeId = "-1"; //fake irrelevant ID
        parameterTypes = abiEntry.inputs.map(abiParameter => ({
            type: Import.abiParameterToType(abiParameter),
            name: abiParameter.name,
            indexed: abiParameter.indexed
        }));
        //now: split the list of parameters into indexed and non-indexed
        [indexed, nonIndexed] = partition_1.default(parameterTypes, (parameter) => parameter.indexed);
        //now: perform the allocation for the non-indexed parameters!
        abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair
    }
    //now: transform the result appropriately
    const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "eventdata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    //now: allocate the indexed parameters
    const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0
    const indexedArgumentsAllocation = indexed.map(({ type, name }, position) => ({
        type,
        name,
        pointer: {
            location: "eventtopic",
            topic: startingTopic + position
        }
    }));
    //finally: weave these back together
    let argumentsAllocation = [];
    for (let parameter of parameterTypes) {
        let arrayToGrabFrom = parameter.indexed
            ? indexedArgumentsAllocation
            : nonIndexedArgumentsAllocation;
        argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
    }
    //...and return
    return {
        abi: abiEntry,
        contextHash: undefined,
        definedIn,
        id,
        arguments: argumentsAllocation,
        allocationMode,
        anonymous: abiEntry.anonymous
    };
}
function allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    //first: if we got passed just a node & no abi entry,
    let id = undefined;
    let definedIn = undefined;
    let parametersFull = undefined;
    const parametersAbi = abiEntry.inputs;
    if (errorNode) {
        //first, set parametersFull
        parametersFull = errorNode.parameters.parameters;
        //now, set id
        id = import_1.makeTypeId(errorNode.id, compilationId);
        //now, set definedIn
        let contractNode = null;
        for (const node of Object.values(referenceDeclarations)) {
            if (node.nodeType === "ContractDefinition") {
                if (node.nodes.some((subNode) => subNode.id === errorNode.id)) {
                    contractNode = node;
                    break;
                }
            }
            //if we didn't find it, then contractNode is null
            //(and thus so will be definedIn)
        }
        if (contractNode === null) {
            definedIn = null;
        }
        else {
            definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler));
        }
    }
    //otherwise, leave parametersFull, id, and definedIn undefined
    const { allocation: abiAllocation, mode: allocationMode } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector
    );
    //finally: transform the allocation appropriately
    const argumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "returndata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));
    return {
        kind: "revert",
        selector,
        abi: abiEntry,
        id,
        definedIn,
        arguments: argumentsAllocation,
        allocationMode
    };
}
function getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let allocations = {
        constructorAllocation: undefined,
        //(if it doesn't then it will remain as default)
        functionAllocations: {}
    };
    if (!abi) {
        //if no ABI, can't do much!
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        return allocations;
    }
    for (let abiEntry of abi) {
        if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) ||
            AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {
            //the first of these conditions is a hack workaround for a Solidity bug.
            //the second of these is because... seriously? we're not handling these
            //(at least not for now!) (these only exist prior to Solidity 0.5.6,
            //thankfully)
            continue;
        }
        switch (abiEntry.type) {
            case "constructor":
                allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                debug("constructor alloc: %O", allocations.constructorAllocation);
                break;
            case "function":
                allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                break;
            default:
                //skip over fallback, error, and event
                break;
        }
    }
    if (!allocations.constructorAllocation) {
        //set a default constructor allocation if we haven't allocated one yet
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        debug("default constructor alloc: %O", allocations.constructorAllocation);
    }
    return allocations;
}
function defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {
    if (!constructorContext) {
        return undefined;
    }
    const rawLength = constructorContext.binary.length;
    const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring
    const input = {
        offset,
        abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,
        arguments: [],
        allocationMode: "full"
    };
    const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, "full"); //assume full, degrade as necessary
    return { input, output };
}
//note: context should be deployed context!
function constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {
    if (!context) {
        //just return a default abi mode result
        return {
            selector: new Uint8Array(),
            allocationMode: "abi",
            kind: "bytecode",
            delegatecallGuard: false
        };
    }
    const { immutableReferences, compilationId, compiler, contractKind, binary } = context;
    let immutables;
    if (allocationMode === "full" && immutableReferences) {
        if (contractNode) {
            debug("allocating immutables");
            immutables = [];
            for (const [id, references] of Object.entries(immutableReferences)) {
                if (references.length === 0) {
                    continue; //don't allocate immutables that don't exist
                }
                const astId = parseInt(id);
                //get the corresponding variable node; potentially fail
                const { node: definition, contract: definedIn } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);
                if (!definition || definition.nodeType !== "VariableDeclaration") {
                    debug("didn't find definition for %d!", astId);
                    allocationMode = "abi";
                    immutables = undefined;
                    break;
                }
                const definedInClass = (Ast.Import.definitionToStoredType(definedIn, compilationId, compiler)); //can skip reference declarations argument here
                const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
                immutables.push({
                    name: definition.name,
                    definedIn: definedInClass,
                    type: dataType,
                    pointer: {
                        location: "returndata",
                        start: references[0].start,
                        length: references[0].length
                    }
                });
            }
        }
        else if (Object.entries(immutableReferences).length > 0) {
            //if there are immutables, but no contract mode, go to abi mode
            debug("immutables but no node!");
            allocationMode = "abi";
        }
    }
    else {
        debug("no immutables");
    }
    //now, is there a delegatecall guard?
    let delegatecallGuard = false;
    if (contractKind === "library") {
        //note: I am relying on this being present!
        //(also this part is a bit HACKy)
        const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //"73"
        const delegateCallGuardString = "0x" + pushAddressInstruction + "..".repeat(Evm.Utils.ADDRESS_SIZE);
        if (binary.startsWith(delegateCallGuardString)) {
            delegatecallGuard = true;
        }
    }
    return {
        selector: new Uint8Array(),
        allocationMode,
        kind: "bytecode",
        immutables,
        delegatecallGuard
    };
}
function getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    let allocations = {
        constructorAllocations: {},
        functionAllocations: {}
    };
    for (let contract of contracts) {
        const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);
        if (contract.constructorContext) {
            allocations.constructorAllocations[contract.constructorContext.context] =
                contractAllocations.constructorAllocation;
        }
        if (contract.deployedContext) {
            allocations.functionAllocations[contract.deployedContext.context] =
                contractAllocations.functionAllocations;
            //set this up under both constructor *and* deployed! this is to handle
            //constructor returndata decoding
            allocations.constructorAllocations[contract.deployedContext.context] =
                contractAllocations.constructorAllocation;
        }
    }
    return allocations;
}
exports.getCalldataAllocations = getCalldataAllocations;
function getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let useAst = Boolean(contractNode && contractNode.usedErrors);
    if (useAst) {
        const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);
        let abis;
        try {
            abis = errorNodes.map(errorNode => (Ast.Utils.definitionToAbi(errorNode, referenceDeclarations)));
        }
        catch (_a) {
            useAst = false;
        }
        if (useAst) {
            //i.e. if the above operation succeeded
            return contractNode.usedErrors
                .map(errorNodeId => referenceDeclarations[errorNodeId])
                .map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));
        }
    }
    if (!useAst && abi) {
        //deliberately *not* an else!
        return abi
            .filter((abiEntry) => abiEntry.type === "error")
            .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround
            .map((abiEntry) => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));
    }
    //otherwise just return nothing
    return [];
}
function getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    let allContexts = []
        .concat(...contracts.map(({ deployedContext, constructorContext }) => [
        deployedContext,
        constructorContext
    ]))
        .filter(x => x) //filter out nonexistent contexts
        .map(context => context.context);
    allContexts.push(""); //HACK: add fictional empty-string context to represent no-context
    //holds allocations for a given context
    let selfAllocations = {};
    //holds allocations for *other* contexts
    let additionalAllocations = {};
    //now: process the allocations for each contract. we'll add each contract's
    //allocations to *its* entries in allocations, and to every *other* entry
    //in additionalAllocations.
    for (const contract of contracts) {
        const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);
        const contexts = [
            //contexts for this contract
            contract.deployedContext,
            contract.constructorContext
        ]
            .filter(x => x) //filter out nonexistent contexts
            .map(context => context.context);
        const otherContexts = allContexts.filter(
        //contexts for all other contracts
        contextHash => !contexts.includes(contextHash));
        //add them to selfAllocations
        for (const contextHash of contexts) {
            selfAllocations[contextHash] = contractAllocations;
        }
        //add them to additionalAllocations
        for (const contextHash of otherContexts) {
            if (additionalAllocations[contextHash] === undefined) {
                additionalAllocations[contextHash] = [];
            }
            additionalAllocations[contextHash] =
                additionalAllocations[contextHash].concat(contractAllocations);
        }
    }
    let allocations = Object.assign({}, ...allContexts.map(contextHash => ({ [contextHash]: {} })));
    //now: perform coalescense!
    for (const contract of contracts) {
        //we're setting up contexts again, sorry >_>
        const contexts = [
            //contexts for this contract
            contract.deployedContext,
            contract.constructorContext
        ]
            .filter(x => x) //filter out nonexistent contexts
            .map(context => context.context);
        for (const contextHash of contexts) {
            allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);
            debug("allocations: %O", allocations[contextHash]);
        }
    }
    //...also coalesce the fake "" context
    allocations[""] = coalesceReturndataAllocations([], additionalAllocations[""] || []);
    debug("error allocations: %O", allocations);
    return allocations;
}
exports.getReturndataAllocations = getReturndataAllocations;
function coalesceReturndataAllocations(selfAllocations, additionalAllocations) {
    let bySelector = {};
    //start with the additional allocations; we want to process
    //the self allocations last, due to special handling of no-ID allocations there
    for (const allocation of additionalAllocations) {
        const signature = AbiDataUtils.abiSignature(allocation.abi);
        const selector = web3_utils_1.default.soliditySha3({
            type: "string",
            value: signature
        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string
        if (bySelector[selector]) {
            //note: at this point, for any given signature, there should only be a
            //no-ID allocation for that signature if it's the only one
            if (allocation.id !== undefined) {
                //delete anything with that signature but w/o an ID, or with this same ID
                bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&
                    (id === undefined || id === allocation.id)));
                //add this allocation
                bySelector[selector].push(allocation);
            }
            else if (!bySelector[selector].some(({ abi }) => AbiDataUtils.abiSignature(abi) === signature)) {
                //only add ID-less ones if there isn't anything of that signature already
                bySelector[selector].push(allocation);
            }
        }
        else {
            //if there's nothing there thus far, add it
            bySelector[selector] = [allocation];
        }
    }
    //now we're going to perform a modified version of this procedure for the self allocations:
    //1. we're going to add to the front, not the back
    //2. we can add an ID-less one even if there are already ones with IDs there
    //(sorry for the copypaste)
    for (const allocation of selfAllocations) {
        const signature = AbiDataUtils.abiSignature(allocation.abi);
        const selector = web3_utils_1.default.soliditySha3({
            type: "string",
            value: signature
        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string
        if (bySelector[selector]) {
            //delete anything with that signature but w/o an ID, or with this same ID
            //(if this alloc has no ID, this will only delete ID-less ones :) )
            bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&
                (id === undefined || id === allocation.id)));
            //add this allocation to front, not back!
            bySelector[selector].unshift(allocation);
        }
        else {
            //if there's nothing there thus far, add it
            bySelector[selector] = [allocation];
        }
    }
    return bySelector;
}
function getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    if (!abi) {
        //can't do much if no ABI!
        return [];
    }
    return abi
        .filter((abiEntry) => abiEntry.type === "event")
        .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround
        .map((abiEntry) => ({
        selector: AbiDataUtils.abiSelector(abiEntry),
        anonymous: abiEntry.anonymous,
        topics: AbiDataUtils.topicsCount(abiEntry),
        allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)
    }));
    //note we do *not* filter out undefined allocations; we need these as placeholders
}
//WARNING: this function is full of hacks... sorry
function getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations, allowConstructorEvents = false) {
    //first: do allocations for individual contracts
    let individualAllocations = {};
    let groupedAllocations = {};
    let contextSwapMap = {}; //maps deployed to constructor & vice versa
    let allocations = {};
    for (const { abi, deployedContext, constructorContext, contractNode, compilationId, compiler } of contracts) {
        if (!deployedContext && !constructorContext && !contractNode) {
            //we'll need *one* of these at least
            continue;
        }
        const contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);
        const key = makeContractKey(deployedContext || constructorContext, contractNode ? contractNode.id : undefined, compilationId);
        if (individualAllocations[key] === undefined) {
            individualAllocations[key] = {};
        }
        for (const allocationTemporary of contractAllocations) {
            //we'll use selector *even for anonymous* here, because it's just
            //for determining what overrides what at this point
            individualAllocations[key][allocationTemporary.selector] = {
                context: deployedContext || constructorContext,
                contractNode,
                allocationTemporary,
                compilationId
            };
        }
        //also: set up the swap map
        if (deployedContext && constructorContext) {
            contextSwapMap[deployedContext.context] = constructorContext.context;
            contextSwapMap[constructorContext.context] = deployedContext.context;
        }
    }
    //now: put things together for inheritance
    //note how we always put things in order from most derived to most base
    for (let contextOrId in individualAllocations) {
        groupedAllocations[contextOrId] = {};
        for (let selector in individualAllocations[contextOrId]) {
            let { context, contractNode, allocationTemporary, compilationId } = individualAllocations[contextOrId][selector];
            debug("allocationTemporary: %O", allocationTemporary);
            let allocationsTemporary = allocationTemporary.allocation
                ? [allocationTemporary]
                : []; //filter out undefined allocations
            //first, copy from individual allocations
            groupedAllocations[contextOrId][selector] = {
                context,
                contractNode,
                allocationsTemporary
            };
            //if no contract node, that's all.  if there is...
            if (contractNode) {
                //...we have to do inheritance processing
                debug("contract Id: %d", contractNode.id);
                debug("base contracts: %o", contractNode.linearizedBaseContracts);
                let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
                linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors
                for (let baseId of linearizedBaseContractsMinusSelf) {
                    debug("checking baseId: %d", baseId);
                    let baseNode = referenceDeclarations[compilationId][baseId];
                    if (!baseNode || baseNode.nodeType !== "ContractDefinition") {
                        debug("failed to find node for baseId: %d", baseId);
                        break; //not a continue!
                        //if we can't find the base node, it's better to stop the loop,
                        //rather than continue to potentially erroneous things
                    }
                    //note: we're not actually going to *use* the baseNode here.
                    //we're just checking for whether we can *find* it
                    //why? because if we couldn't find it, that means that events defined in
                    //base contracts *weren't* skipped earlier, and so we shouldn't now add them in
                    let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId &&
                        contractAllocationInfo.contractNode &&
                        contractAllocationInfo.contractNode.id === baseId);
                    if (!baseContractInfo) {
                        //similar to above... this failure case can happen when there are
                        //two contracts with the same name and you attempt to use the
                        //artifacts; say you have contracts A, B, and B', where A inherits
                        //from B, and B and B' have the same name, and B' is the one that
                        //gets the artifact; B will end up in reference declarations and so
                        //get found above, but it won't appear in contracts, causing the
                        //problem here.  Unfortunately I don't know any great way to handle this,
                        //so, uh, we treat it as a failure same as above.
                        debug("failed to find contract info for baseId: %d", baseId);
                        break;
                    }
                    let baseContext = baseContractInfo.deployedContext ||
                        baseContractInfo.constructorContext;
                    let baseKey = makeContractKey(baseContext, baseId, compilationId);
                    if (individualAllocations[baseKey][selector] !== undefined) {
                        let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;
                        debug("(probably) pushing inherited alloc from baseId: %d", baseId);
                        if (baseAllocation.allocation) {
                            //don't push undefined!
                            groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);
                        }
                    }
                }
            }
        }
    }
    //finally: transform into final form & return,
    //filtering out things w/o a context
    for (let contractKey in groupedAllocations) {
        if (!hasContext(contractKey)) {
            continue;
            //(this filters out ones that had no context and therefore were
            //given by ID; we needed these at the previous stage but from
            //here on they're irrelevant)
        }
        let contextHash = contextHashForKey(contractKey);
        for (let selector in groupedAllocations[contextHash]) {
            let { allocationsTemporary, context } = groupedAllocations[contextHash][selector];
            for (let { anonymous, topics, allocation } of allocationsTemporary) {
                let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK
                if (contractKind !== "library") {
                    contractKind = "contract"; //round off interfaces to being contracts for our purposes :P
                }
                allocation = Object.assign(Object.assign({}, allocation), { contextHash }); //the allocation's context hash at this point depends on where it was defined, but
                //that's not what we want going in the final allocation table!
                if (allocations[topics] === undefined) {
                    allocations[topics] = {
                        bySelector: {},
                        anonymous: { contract: {}, library: {} }
                    };
                }
                if (!anonymous) {
                    if (allocations[topics].bySelector[selector] === undefined) {
                        allocations[topics].bySelector[selector] = {
                            contract: {},
                            library: {}
                        };
                    }
                    //push the allocation (non-anonymous case)
                    if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {
                        allocations[topics].bySelector[selector][contractKind][contextHash] = [];
                    }
                    allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);
                    //...and push it in the swapped context too if that exists
                    //HACK: don't do this for libraries! library events are already
                    //considered always in play, so including them *twice* would cause
                    //problems... fortunately library constructors don't emit events!
                    if (allowConstructorEvents &&
                        contextHash in contextSwapMap &&
                        contractKind !== "library") {
                        const swappedHash = contextSwapMap[contextHash];
                        if (allocations[topics].bySelector[selector][contractKind][swappedHash] === undefined) {
                            allocations[topics].bySelector[selector][contractKind][swappedHash] = [];
                        }
                        allocations[topics].bySelector[selector][contractKind][swappedHash].push(allocation);
                    }
                }
                else {
                    //push the allocation (anonymous case)
                    if (allocations[topics].anonymous[contractKind][contextHash] ===
                        undefined) {
                        allocations[topics].anonymous[contractKind][contextHash] = [];
                    }
                    allocations[topics].anonymous[contractKind][contextHash].push(allocation);
                    //...and push it in the swapped context too if that exists
                    //(and it's not a library, see above)
                    if (allowConstructorEvents &&
                        contextHash in contextSwapMap &&
                        contractKind !== "library") {
                        const swappedHash = contextSwapMap[contextHash];
                        if (allocations[topics].anonymous[contractKind][swappedHash] ===
                            undefined) {
                            allocations[topics].anonymous[contractKind][swappedHash] = [];
                        }
                        allocations[topics].anonymous[contractKind][swappedHash].push(allocation);
                    }
                }
            }
        }
    }
    return allocations;
}
exports.getEventAllocations = getEventAllocations;
//if derivedContractNode is passed, we check that before referenceDeclarations
function findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {
    const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {
        if (foundNodeAndContract !== undefined) {
            return foundNodeAndContract; //once we've found something, we don't need to keep looking
        }
        debug("searching contract %d", baseContractId);
        let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id
            ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision
            : referenceDeclarations[baseContractId];
        if (baseContractNode === undefined ||
            baseContractNode.nodeType !== "ContractDefinition") {
            debug("bad contract node!");
            return null; //return null rather than undefined so that this will propagate through
            //(i.e. by returning null here we give up the search)
            //(we don't want to continue due to possibility of grabbing the wrong override)
        }
        const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!
        if (node) {
            debug("found node: %o", node);
            return {
                node,
                contract: baseContractNode
            };
        }
        else {
            return undefined;
        }
    }, undefined //start with no node found
    );
    return searchResult || { node: undefined, contract: undefined };
}
function makeContractKey(context, id, compilationId) {
    return context ? context.context : id + ":" + compilationId; //HACK!
}
function hasContext(key) {
    return key.startsWith("0x"); //HACK!
}
function contextHashForKey(key) {
    return hasContext(key)
        ? key //HACK!
        : undefined;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 865700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectAllocationInfo = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:allocate:utils");
const Compilations = __importStar(__webpack_require__(89752));
const compile_common_1 = __webpack_require__(529833);
const Contexts = __importStar(__webpack_require__(697938));
const Abi = __importStar(__webpack_require__(207651));
function collectAllocationInfo(compilations) {
    let contexts = {};
    let deployedContexts = {};
    let contractsAndContexts = [];
    for (const compilation of compilations) {
        for (const contract of compilation.contracts) {
            const node = Compilations.Utils.getContractNode(contract, compilation);
            let deployedContext = undefined;
            let constructorContext = undefined;
            const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
            const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);
            if (deployedBytecode && deployedBytecode !== "0x") {
                deployedContext = Contexts.Utils.makeContext(contract, node, compilation);
                contexts[deployedContext.context] = deployedContext;
                //note that we don't set up deployedContexts until after normalization!
            }
            if (bytecode && bytecode !== "0x") {
                constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);
                contexts[constructorContext.context] = constructorContext;
            }
            contractsAndContexts.push({
                contract,
                node,
                deployedContext,
                constructorContext,
                compilationId: compilation.id
            });
        }
    }
    debug("known contexts: %o", Object.keys(contexts));
    contexts = Contexts.Utils.normalizeContexts(contexts);
    deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? { [context.context]: context } : {}));
    for (const contractAndContexts of contractsAndContexts) {
        //change everything to normalized version
        if (contractAndContexts.deployedContext) {
            contractAndContexts.deployedContext =
                contexts[contractAndContexts.deployedContext.context]; //get normalized version
        }
        if (contractAndContexts.constructorContext) {
            contractAndContexts.constructorContext =
                contexts[contractAndContexts.constructorContext.context]; //get normalized version
        }
    }
    const allocationInfo = contractsAndContexts.map(({ contract: { abi, compiler, immutableReferences }, compilationId, node, deployedContext, constructorContext }) => ({
        abi: Abi.normalize(abi),
        compilationId,
        compiler,
        contractNode: node,
        deployedContext,
        constructorContext,
        immutableReferences
    }));
    return {
        contexts,
        deployedContexts,
        contractsAndContexts,
        allocationInfo
    };
}
exports.collectAllocationInfo = collectAllocationInfo;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 607343:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const Format = __importStar(__webpack_require__(429965));
const Evm = __importStar(__webpack_require__(149218));
const allocate_1 = __webpack_require__(151325);
const errors_1 = __webpack_require__(672325);
function* decodeAbi(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType) ||
        dataType.typeClass === "tuple") {
        //I don't want tuples to be considered a reference type, but it makes sense
        //to group them for this purpose
        let dynamic;
        try {
            dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;
        }
        catch (error) {
            return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);
        }
        if (dynamic) {
            return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);
        }
        else {
            return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);
        }
    }
    else {
        debug("pointer %o", pointer);
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
    }
}
exports.decodeAbi = decodeAbi;
function* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {
    let { strictAbiMode: strict, abiPointerBase: base, lengthOverride } = options;
    base = base || 0; //in case base was undefined
    const { allocations: { abi: allocations }, state } = info;
    debug("pointer %o", pointer);
    //this variable holds the location we should look to *next*
    //stack pointers point to calldata; other pointers point to same location
    const location = pointer.location === "stack" || pointer.location === "stackliteral"
        ? "calldata"
        : pointer.location;
    if (pointer.location !== "stack" && pointer.location !== "stackliteral") {
        //length overrides are only applicable when you're decoding a pointer
        //from the stack!  otherwise they must be ignored!
        lengthOverride = undefined;
    }
    let rawValue;
    try {
        rawValue = yield* read_1.default(pointer, state);
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error, strict);
    }
    let rawValueAsBN = Conversion.toBN(rawValue);
    debug("rawValue: %O", rawValue);
    debug("rawValueAsBN: %O", rawValueAsBN);
    let rawValueAsNumber;
    try {
        rawValueAsNumber = rawValueAsBN.toNumber();
    }
    catch (_a) {
        let error = {
            kind: "OverlargePointersNotImplementedError",
            pointerAsBN: rawValueAsBN
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            //again with the TS failures...
            type: dataType,
            kind: "error",
            error
        };
    }
    let startPosition = rawValueAsNumber + base;
    debug("startPosition %d", startPosition);
    let dynamic;
    let size;
    try {
        ({ dynamic, size } = allocate_1.abiSizeInfo(dataType, allocations));
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error, strict);
    }
    if (!dynamic) {
        //this will only come up when called from stack.ts
        let staticPointer = {
            location,
            start: startPosition,
            length: size
        };
        return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);
    }
    let length;
    let lengthAsBN;
    let rawLength;
    switch (dataType.typeClass) {
        case "bytes":
        case "string":
            //initial word contains length (unless an override was given)
            if (lengthOverride !== undefined) {
                lengthAsBN = lengthOverride;
                //note in this case we do *not* increment start position;
                //if a length override is given, that means the given start
                //position skips over the length word!
            }
            else {
                try {
                    rawLength = yield* read_1.default({
                        location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return errors_1.handleDecodingError(dataType, error, strict);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length
                //so it'll be set up to read the data
            }
            if (strict && lengthAsBN.gtn(state[location].length)) {
                //you may notice that the comparison is a bit crude; that's OK, this is
                //just to prevent huge numbers from DOSing us, other errors will still
                //be caught regardless
                throw new errors_1.StopDecodingError({
                    kind: "OverlongArrayOrStringStrictModeError",
                    lengthAsBN,
                    dataLength: state[location].length
                });
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_b) {
                //note: if we're in this situation, we can assume we're not in strict mode,
                //as the strict case was handled above
                return {
                    //again with the TS failures...
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let childPointer = {
                location,
                start: startPosition,
                length
            };
            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);
        case "array":
            if (dataType.kind === "static") {
                //static-length array
                lengthAsBN = dataType.length;
                //note we don't increment start position; static arrays don't
                //include a length word!
            }
            else if (lengthOverride !== undefined) {
                debug("override: %o", lengthOverride);
                //dynamic-length array, but with length override
                lengthAsBN = lengthOverride;
                //we don't increment start position; if a length override was
                //given, that means the pointer skipped the length word!
            }
            else {
                //dynamic-length array, read length from data
                //initial word contains array length
                try {
                    rawLength = yield* read_1.default({
                        location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return errors_1.handleDecodingError(dataType, error, strict);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                //to next word, as first word was used for length
            }
            if (strict && lengthAsBN.gtn(state[location].length)) {
                //you may notice that the comparison is a bit crude; that's OK, this is
                //just to prevent huge numbers from DOSing us, other errors will still
                //be caught regardless
                throw new errors_1.StopDecodingError({
                    kind: "OverlongArraysAndStringsNotImplementedError",
                    lengthAsBN,
                    dataLength: state[location].length
                });
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_c) {
                //again, if we get here, we can assume we're not in strict mode
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            //note: I've written this fairly generically, but it is worth noting that
            //since this array is of dynamic type, we know that if it's static length
            //then size must be EVM.WORD_SIZE
            let baseSize;
            try {
                baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error, strict);
            }
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeAbi(dataType.baseType, {
                    location,
                    start: startPosition + index * baseSize,
                    length: baseSize
                }, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))); //pointer base is always start of list, never the length
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren
            };
        case "struct":
            return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);
        case "tuple":
            return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);
    }
}
exports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;
function* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {
    debug("static");
    debug("pointer %o", pointer);
    const location = pointer.location;
    switch (dataType.typeClass) {
        case "array":
            //we're in the static case, so we know the array must be statically sized
            const lengthAsBN = dataType.length;
            let length;
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_a) {
                //note: since this is the static case, we don't bother including the stronger
                //strict-mode guard against getting DOSed by large array sizes, since in this
                //case we're not reading the size from the input; if there's a huge static size
                //array, well, we'll just have to deal with it
                let error = {
                    kind: "OverlongArraysAndStringsNotImplementedError",
                    lengthAsBN
                };
                if (options.strictAbiMode) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            let baseSize;
            try {
                baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);
            }
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeAbi(dataType.baseType, {
                    location,
                    start: pointer.start + index * baseSize,
                    length: baseSize
                }, info, options));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren
            };
        case "struct":
            return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);
        case "tuple":
            return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);
    }
}
exports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;
//note that this function takes the start position as a *number*; it does not take a pointer
function* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {
    const { allocations: { abi: allocations } } = info;
    const typeLocation = location === "calldata" ? "calldata" : null; //other abi locations are not valid type locations
    const typeId = dataType.id;
    const structAllocation = allocations[typeId];
    if (!structAllocation) {
        let error = {
            kind: "UserDefinedTypeNotFoundError",
            type: dataType
        };
        if (options.strictAbiMode || options.allowRetry) {
            throw new errors_1.StopDecodingError(error, true);
            //note that we allow a retry if we couldn't locate the allocation!
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    let decodedMembers = [];
    for (let index = 0; index < structAllocation.members.length; index++) {
        const memberAllocation = structAllocation.members[index];
        const memberPointer = memberAllocation.pointer;
        const childPointer = {
            location,
            start: startPosition + memberPointer.start,
            length: memberPointer.length
        };
        let memberName = memberAllocation.name;
        let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);
        decodedMembers.push({
            name: memberName,
            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))
            //note that the base option is only needed in the dynamic case, but we're being indiscriminate
        });
    }
    return {
        type: dataType,
        kind: "value",
        value: decodedMembers
    };
}
//note that this function takes the start position as a *number*; it does not take a pointer
function* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {
    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!
    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder
    //However it may be worth revisiting this in the future if performance turns out to be a problem
    //(changing this may be pretty hard though)
    let decodedMembers = [];
    let position = startPosition;
    for (const { name, type: memberType } of dataType.memberTypes) {
        const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;
        const childPointer = {
            location,
            start: position,
            length: memberSize
        };
        decodedMembers.push({
            name,
            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))
            //note that the base option is only needed in the dynamic case, but we're being indiscriminate
        });
        position += memberSize;
    }
    return {
        type: dataType,
        kind: "value",
        value: decodedMembers
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 554840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeTupleAbiWithSelector = exports.encodeTupleAbi = exports.encodeAbi = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:encode");
const Conversion = __importStar(__webpack_require__(152714));
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const Evm = __importStar(__webpack_require__(149218));
const allocate_1 = __webpack_require__(151325);
const sum_1 = __importDefault(__webpack_require__(265666));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * @Category Encoding (low-level)
 */
function encodeAbi(input, allocations) {
    //errors can't be encoded
    if (input.kind === "error") {
        return undefined;
    }
    let bytes;
    //TypeScript can at least infer in the rest of this that we're looking
    //at a value, not an error!  But that's hardly enough...
    switch (input.type.typeClass) {
        case "mapping":
        case "magic":
        case "type":
            //none of these can go in the ABI
            return undefined;
        case "bytes":
            switch (input.type.kind) {
                case "static":
                    return Basic.Encode.encodeBasic(input);
                case "dynamic":
                    bytes = Bytes.Encode.encodeBytes(input);
                    return padAndPrependLength(bytes);
            }
        case "string":
            bytes = Bytes.Encode.encodeBytes(input);
            return padAndPrependLength(bytes);
        case "function": {
            switch (input.type.visibility) {
                case "internal":
                    return undefined; //internal functions can't go in the ABI!
                //Yes, technically we could defer to encodeBasic here, but,
                //c'mon, that's not how the function's supposed to be used
                case "external":
                    return Basic.Encode.encodeBasic(input);
            }
        }
        //now for the serious cases
        case "array": {
            let coercedInput = (input);
            if (coercedInput.reference !== undefined) {
                return undefined; //circular values can't be encoded
            }
            let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);
            switch (input.type.kind) {
                case "static":
                    return staticEncoding;
                case "dynamic":
                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length
                    encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand
                    let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);
                    encoded.set(lengthBytes); //and now we set the length
                    return encoded;
            }
        }
        case "struct": {
            let coercedInput = (input);
            if (coercedInput.reference !== undefined) {
                return undefined; //circular values can't be encoded
            }
            return encodeTupleAbi(coercedInput.value.map(({ value }) => value), allocations);
        }
        case "tuple":
            //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!
            //(That may not be apparent from this one line, but it's true)
            //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder
            //However it may be worth revisiting this in the future if performance turns out to be a problem
            return encodeTupleAbi(input.value.map(({ value }) => value), allocations);
        default:
            return Basic.Encode.encodeBasic(input);
    }
}
exports.encodeAbi = encodeAbi;
/**
 * @Category Encoding (low-level)
 */
function padAndPrependLength(bytes) {
    let length = bytes.length;
    let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);
    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);
    encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand
    let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);
    encoded.set(lengthBytes); //and now we set the length
    return encoded;
}
/**
 * @Category Encoding (low-level)
 */
function encodeTupleAbi(tuple, allocations) {
    let elementEncodings = tuple.map(element => encodeAbi(element, allocations));
    if (elementEncodings.some(element => element === undefined)) {
        return undefined;
    }
    let elementSizeInfo = tuple.map(element => allocate_1.abiSizeInfo(element.type, allocations));
    //heads and tails here are as discussed in the ABI docs;
    //for a static type the head is the encoding and the tail is empty,
    //for a dynamic type the head is the pointer and the tail is the encoding
    let heads = [];
    let tails = [];
    //but first, we need to figure out where the first tail will start,
    //by adding up the sizes of all the heads (we can easily do this in
    //advance via elementSizeInfo, without needing to know the particular
    //values of the heads)
    let startOfNextTail = sum_1.default(elementSizeInfo.map(elementInfo => elementInfo.size));
    for (let i = 0; i < tuple.length; i++) {
        let head;
        let tail;
        if (!elementSizeInfo[i].dynamic) {
            //static case
            head = elementEncodings[i];
            tail = new Uint8Array(); //empty array
        }
        else {
            //dynamic case
            head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);
            tail = elementEncodings[i];
        }
        heads.push(head);
        tails.push(tail);
        startOfNextTail += tail.length;
    }
    //finally, we need to concatenate everything together!
    //since we're dealing with Uint8Arrays, we have to do this manually
    let totalSize = startOfNextTail;
    let encoded = new Uint8Array(totalSize);
    let position = 0;
    for (let head of heads) {
        encoded.set(head, position);
        position += head.length;
    }
    for (let tail of tails) {
        encoded.set(tail, position);
        position += tail.length;
    }
    return encoded;
}
exports.encodeTupleAbi = encodeTupleAbi;
/**
 * @Category Encoding (low-level)
 */
function encodeTupleAbiWithSelector(tuple, selector, allocations) {
    const encodedTuple = encodeTupleAbi(tuple, allocations);
    if (!encodedTuple) {
        return undefined;
    }
    const encoded = new Uint8Array(selector.length + encodedTuple.length);
    encoded.set(selector);
    encoded.set(encodedTuple, selector.length);
    return encoded;
}
exports.encodeTupleAbiWithSelector = encodeTupleAbiWithSelector;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 753137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abiParameterToType = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:import");
const bn_js_1 = __importDefault(__webpack_require__(213550));
function abiParameterToType(abi) {
    let typeName = abi.type;
    let typeHint = abi.internalType;
    //first: is it an array?
    let arrayMatch = typeName.match(/(.*)\[(\d*)\]$/);
    if (arrayMatch) {
        let baseTypeName = arrayMatch[1];
        let lengthAsString = arrayMatch[2]; //may be empty!
        let baseAbi = Object.assign(Object.assign({}, abi), { type: baseTypeName });
        let baseType = abiParameterToType(baseAbi);
        if (lengthAsString === "") {
            return {
                typeClass: "array",
                kind: "dynamic",
                baseType,
                typeHint
            };
        }
        else {
            let length = new bn_js_1.default(lengthAsString);
            return {
                typeClass: "array",
                kind: "static",
                length,
                baseType,
                typeHint
            };
        }
    }
    //otherwise, here are the simple cases
    let typeClass = typeName.match(/^([^0-9]+)/)[1];
    switch (typeClass) {
        case "uint":
        case "int": {
            let bits = typeName.match(/^u?int([0-9]+)/)[1];
            return {
                typeClass,
                bits: parseInt(bits),
                typeHint
            };
        }
        case "bytes":
            let length = typeName.match(/^bytes([0-9]*)/)[1];
            if (length === "") {
                return {
                    typeClass,
                    kind: "dynamic",
                    typeHint
                };
            }
            else {
                return {
                    typeClass,
                    kind: "static",
                    length: parseInt(length),
                    typeHint
                };
            }
        case "address":
            return {
                typeClass,
                kind: "general",
                typeHint
            };
        case "string":
        case "bool":
            return {
                typeClass,
                typeHint
            };
        case "fixed":
        case "ufixed": {
            let [_, bits, places] = typeName.match(/^u?fixed([0-9]+)x([0-9]+)/);
            return {
                typeClass,
                bits: parseInt(bits),
                places: parseInt(places),
                typeHint
            };
        }
        case "function":
            return {
                typeClass,
                visibility: "external",
                kind: "general",
                typeHint
            };
        case "tuple":
            let memberTypes = abi.components.map(component => ({
                name: component.name || undefined,
                type: abiParameterToType(component)
            }));
            return {
                typeClass,
                memberTypes,
                typeHint
            };
    }
}
exports.abiParameterToType = abiParameterToType;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20907:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For allocation, encoding, and decoding of locations related to the ABI
 * (calldata in Solidity, events, etc.)
 *
 * @category ABI data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Import = exports.Decode = exports.Encode = exports.Allocate = void 0;
const Allocate = __importStar(__webpack_require__(151325));
exports.Allocate = Allocate;
const Encode = __importStar(__webpack_require__(554840));
exports.Encode = Encode;
const Decode = __importStar(__webpack_require__(607343));
exports.Decode = Decode;
const Import = __importStar(__webpack_require__(753137));
exports.Import = Import;
__exportStar(__webpack_require__(526365), exports); //can't do 'export type *'
const Utils = __importStar(__webpack_require__(785941));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 526365:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 785941:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiSelector = exports.abiTupleSignature = exports.abiSignature = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abi-data:utils");
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const Evm = __importStar(__webpack_require__(149218));
const Ast = __importStar(__webpack_require__(114442));
exports.DEFAULT_CONSTRUCTOR_ABI = {
    type: "constructor",
    inputs: [],
    stateMutability: "nonpayable"
};
//note the return value only includes functions!
function computeSelectors(abi) {
    if (abi === undefined) {
        return undefined;
    }
    return Object.assign({}, ...abi
        .filter((abiEntry) => abiEntry.type === "function")
        .map((abiEntry) => ({
        [abiSelector(abiEntry)]: abiEntry
    })));
}
exports.computeSelectors = computeSelectors;
//does this ABI have a payable fallback (or receive) function?
function abiHasPayableFallback(abi) {
    if (abi === undefined) {
        return undefined;
    }
    return abi.some(abiEntry => (abiEntry.type === "fallback" || abiEntry.type === "receive") &&
        abiEntry.stateMutability === "payable");
}
exports.abiHasPayableFallback = abiHasPayableFallback;
//NOTE: this function returns the written out SIGNATURE, not the SELECTOR
function abiSignature(abiEntry) {
    return abiEntry.name + abiTupleSignature(abiEntry.inputs);
}
exports.abiSignature = abiSignature;
function abiTupleSignature(parameters) {
    let components = parameters.map(abiTypeSignature);
    return "(" + components.join(",") + ")";
}
exports.abiTupleSignature = abiTupleSignature;
function abiTypeSignature(parameter) {
    let tupleMatch = parameter.type.match(/tuple(.*)/);
    if (tupleMatch === null) {
        //does not start with "tuple"
        return parameter.type;
    }
    else {
        let tail = tupleMatch[1]; //everything after "tuple"
        let tupleSignature = abiTupleSignature(parameter.components);
        return tupleSignature + tail;
    }
}
function abiSelector(abiEntry) {
    let signature = abiSignature(abiEntry);
    //NOTE: web3's soliditySha3 has a problem if the empty
    //string is passed in.  Fortunately, that should never happen here.
    let hash = web3_utils_1.default.soliditySha3({ type: "string", value: signature });
    switch (abiEntry.type) {
        case "event":
            return hash;
        case "function":
        case "error":
            return hash.slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string
    }
}
exports.abiSelector = abiSelector;
//note: undefined does not match itself :P
function abisMatch(entry1, entry2) {
    //we'll consider two abi entries to match if they have the same
    //type, name (if applicable), and inputs (if applicable).
    //since there's already a signature function, we can just use that.
    if (!entry1 || !entry2) {
        return false;
    }
    if (entry1.type !== entry2.type) {
        return false;
    }
    switch (entry1.type) {
        case "function":
        case "event":
        case "error":
            return (abiSignature(entry1) ===
                abiSignature(entry2));
        case "constructor":
            return (abiTupleSignature(entry1.inputs) ===
                abiTupleSignature(entry2.inputs));
        case "fallback":
        case "receive":
            return true;
    }
}
exports.abisMatch = abisMatch;
function definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {
    try {
        return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));
    }
    catch (_) {
        return false; //if an exception occurs, well, that's not a match!
    }
}
exports.definitionMatchesAbi = definitionMatchesAbi;
function topicsCount(abiEntry) {
    let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector
    return (abiEntry.inputs.filter(({ indexed }) => indexed).length + selectorCount);
}
exports.topicsCount = topicsCount;
function abiEntryIsObviouslyIllTyped(abiEntry) {
    switch (abiEntry.type) {
        case "fallback":
        case "receive":
            return false;
        case "constructor":
        case "event":
        case "error":
            return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);
        case "function":
            return (abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) ||
                abiEntry.outputs.some(abiParameterIsObviouslyIllTyped));
    }
}
exports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;
function abiParameterIsObviouslyIllTyped(abiParameter) {
    const legalBaseTypeClasses = [
        "uint",
        "int",
        "fixed",
        "ufixed",
        "bool",
        "address",
        "bytes",
        "string",
        "function",
        "tuple"
    ];
    const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];
    const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);
    if (abiParameter.components) {
        return (abiParameter.components.some(abiParameterIsObviouslyIllTyped) ||
            baseTypeClassIsObviouslyWrong);
    }
    else {
        return baseTypeClassIsObviouslyWrong;
    }
}
function abiEntryHasStorageParameters(abiEntry) {
    const isStorage = (parameter) => parameter.type.endsWith(" storage");
    return (abiEntry.type === "function" &&
        (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)));
    //Note the lack of recursion!  Storage parameters can only occur at
    //top level so there's no need to recurse here
    //(they can also only occur for functions)
}
exports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 57320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:abify");
const Format = __importStar(__webpack_require__(429965));
const Common = __importStar(__webpack_require__(299987));
const Conversion = __importStar(__webpack_require__(152714));
/** @category ABIfication */
function abifyType(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        //we only need to specially handle types that don't go in
        //the ABI, or that have some information loss when going
        //in the ABI
        //note that we do need to handle arrays, due to recursion!
        //First: types that do not go in the ABI
        case "mapping":
        case "magic":
        case "type":
        case "options":
            return undefined;
        //Next: address & contract, these can get handled together
        case "address":
        case "contract":
            return {
                typeClass: "address",
                kind: "general",
                typeHint: Format.Types.typeString(dataType)
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    return {
                        typeClass: "function",
                        visibility: "external",
                        kind: "general",
                        typeHint: Format.Types.typeString(dataType)
                    };
                case "internal": //these don't go in the ABI
                    return undefined;
            }
            break; //to satisfy TypeScript
        //the complex cases: struct & enum
        case "struct": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.memberTypes) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            const memberTypes = fullType.memberTypes.map(({ name, type: memberType }) => ({
                name,
                type: abifyType(memberType, userDefinedTypes)
            }));
            return {
                typeClass: "tuple",
                typeHint: Format.Types.typeString(fullType),
                memberTypes
            };
        }
        case "enum": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.options) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            let numOptions = fullType.options.length;
            let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);
            return {
                typeClass: "uint",
                bits,
                typeHint: Format.Types.typeString(fullType)
            };
        }
        case "userDefinedValueType": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.underlyingType) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);
            return Object.assign(Object.assign({}, abifiedUnderlying), { typeHint: Format.Types.typeStringWithoutLocation(dataType) });
        }
        //finally: arrays
        case "array":
            return Object.assign(Object.assign({}, dataType), { typeHint: Format.Types.typeString(dataType), baseType: abifyType(dataType.baseType, userDefinedTypes) });
        //default case: just leave as-is
        default:
            return dataType;
    }
}
exports.abifyType = abifyType;
/** @category ABIfication */
function abifyResult(result, userDefinedTypes) {
    switch (result.type.typeClass) {
        case "mapping": //doesn't go in ABI
        case "magic": //doesn't go in ABI
        case "type": //doesn't go in ABI
            return undefined;
        case "address":
            //abify the type but leave the value alone
            return Object.assign(Object.assign({}, result), { type: abifyType(result.type, userDefinedTypes) });
        case "contract": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    return {
                        type: (abifyType(result.type, userDefinedTypes)),
                        kind: "value",
                        value: {
                            asAddress: coercedResult.value.address,
                            rawAsHex: coercedResult.value.rawAddress
                        }
                    };
                case "error":
                    switch (coercedResult.error.kind) {
                        case "ContractPaddingError":
                            return {
                                type: (abifyType(result.type, userDefinedTypes)),
                                kind: "error",
                                error: {
                                    kind: "AddressPaddingError",
                                    paddingType: coercedResult.error.paddingType,
                                    raw: coercedResult.error.raw
                                }
                            };
                        default:
                            //other contract errors are generic errors!
                            //but TS doesn't know this so we coerce
                            return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
                    }
            }
            break; //to satisfy typescript
        }
        case "function":
            switch (result.type.visibility) {
                case "external": {
                    let coercedResult = result;
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
                }
                case "internal": //these don't go in the ABI
                    return undefined;
            }
            break; //to satisfy TypeScript
        case "struct": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    if (coercedResult.reference !== undefined) {
                        return undefined; //no circular values in the ABI!
                    }
                    let abifiedMembers = coercedResult.value.map(({ name, value: member }) => ({
                        name,
                        value: abifyResult(member, userDefinedTypes)
                    }));
                    return {
                        kind: "value",
                        type: (abifyType(result.type, userDefinedTypes)),
                        value: abifiedMembers
                    };
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) //note: may throw exception
                     });
            }
        }
        case "userDefinedValueType": {
            const coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    return abifyResult(coercedResult.value, userDefinedTypes);
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: abifyType(result.type, userDefinedTypes) });
            }
            break; //to satisfy TS :P
        }
        case "enum": {
            //NOTE: this is the one case where errors are converted to non-error values!!
            //(other than recursively, I mean)
            //be aware!
            let coercedResult = result;
            let uintType = (abifyType(result.type, userDefinedTypes)); //may throw exception
            switch (coercedResult.kind) {
                case "value":
                    return {
                        type: uintType,
                        kind: "value",
                        value: {
                            asBN: coercedResult.value.numericAsBN.clone()
                        }
                    };
                case "error":
                    switch (coercedResult.error.kind) {
                        case "EnumOutOfRangeError":
                            return {
                                type: uintType,
                                kind: "value",
                                value: {
                                    asBN: coercedResult.error.rawAsBN.clone()
                                }
                            };
                        case "EnumPaddingError":
                            return {
                                type: uintType,
                                kind: "error",
                                error: {
                                    kind: "UintPaddingError",
                                    paddingType: coercedResult.error.paddingType,
                                    raw: coercedResult.error.raw
                                }
                            };
                        case "EnumNotFoundDecodingError":
                            let numericValue = coercedResult.error.rawAsBN.clone();
                            if (numericValue.bitLength() <= uintType.bits) {
                                return {
                                    type: uintType,
                                    kind: "value",
                                    value: {
                                        asBN: numericValue
                                    }
                                };
                            }
                            else {
                                return {
                                    type: uintType,
                                    kind: "error",
                                    error: {
                                        kind: "UintPaddingError",
                                        paddingType: "left",
                                        raw: Conversion.toHexString(numericValue)
                                    }
                                };
                            }
                        default:
                            return {
                                type: uintType,
                                kind: "error",
                                error: coercedResult.error
                            };
                    }
            }
        }
        case "array": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    if (coercedResult.reference !== undefined) {
                        return undefined; //no circular values in the ABI!
                    }
                    let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));
                    return {
                        kind: "value",
                        type: (abifyType(result.type, userDefinedTypes)),
                        value: abifiedMembers
                    };
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
            }
        }
        default:
            return result; //just coerce :-/
    }
}
exports.abifyResult = abifyResult;
/** @category ABIfication */
function abifyCalldataDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    switch (decoding.kind) {
        case "function":
        case "constructor":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
        default:
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi" });
    }
}
exports.abifyCalldataDecoding = abifyCalldataDecoding;
/** @category ABIfication */
function abifyLogDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
}
exports.abifyLogDecoding = abifyLogDecoding;
/** @category ABIfication */
function abifyReturndataDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    switch (decoding.kind) {
        case "return":
        case "revert":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
        case "bytecode":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", immutables: undefined });
        default:
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi" });
    }
}
exports.abifyReturndataDecoding = abifyReturndataDecoding;
//# sourceMappingURL=abify.js.map

/***/ }),

/***/ 575511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeConstant = void 0;
/**
 * @protected
 *
 * @packageDocumentation
 */
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:ast:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const errors_1 = __webpack_require__(672325);
function* decodeConstant(dataType, pointer, info) {
    debug("pointer %o", pointer);
    //normally, we just dispatch to decodeBasic or decodeBytes.
    //for statically-sized bytes, however, we need to make a special case.
    //you see, decodeBasic expects to find the bytes at the *beginning*
    //of the word, but readDefinition will put them at the *end* of the
    //word.  So we'll have to adjust things ourselves.
    //(if the constant is a string constant, it'll be *just* the bytes, so
    //we have to pad it...)
    if (dataType.typeClass === "bytes" && dataType.kind === "static") {
        const size = dataType.length;
        let word;
        try {
            word = yield* read_1.default(pointer, info.state);
        }
        catch (error) {
            return errors_1.handleDecodingError(dataType, error);
        }
        debug("got word: %O", word);
        //not bothering to check padding; shouldn't be necessary
        const bytes = word.slice(-size); //isolate the bytes we want (works in both cases, even if string literal is short)
        return {
            type: dataType,
            kind: "value",
            value: {
                asHex: Conversion.toHexString(bytes, size, true) //padding in case of short string literal
            }
        }; //we'll skip including a raw value, as that would be meaningless
    }
    //otherwise, as mentioned, just dispatch to decodeBasic or decodeBytes
    debug("not a static bytes");
    if (dataType.typeClass === "bytes" || dataType.typeClass === "string") {
        return yield* Bytes.Decode.decodeBytes(dataType, pointer, info);
    }
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
}
exports.decodeConstant = decodeConstant;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 488132:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For reading/decoding constants expressed as AST nodes
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decode = exports.Read = void 0;
const Read = __importStar(__webpack_require__(538130));
exports.Read = Read;
const Decode = __importStar(__webpack_require__(575511));
exports.Decode = Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 538130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readDefinition = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:ast:read");
const Conversion = __importStar(__webpack_require__(152714));
const Evm = __importStar(__webpack_require__(149218));
const Ast = __importStar(__webpack_require__(114442));
const errors_1 = __webpack_require__(672325);
function readDefinition(pointer) {
    const definition = pointer.definition;
    debug("definition %o", definition);
    switch (Ast.Utils.typeClass(definition)) {
        case "rational":
            let numericalValue = Ast.Utils.rationalValue(definition);
            return Conversion.toBytes(numericalValue, Evm.Utils.WORD_SIZE);
        //you may be wondering, why do we not just use definition.value here,
        //like we do below? answer: because if this isn't a literal, that may not
        //exist
        case "stringliteral":
            return Conversion.toBytes(definition.hexValue);
        default:
            //unfortunately, other types of constants are just too complicated to
            //handle right now.  sorry.
            debug("unsupported constant definition type");
            throw new errors_1.DecodingError({
                kind: "UnsupportedConstantError",
                definition
            });
    }
}
exports.readDefinition = readDefinition;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 849965:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.definitionToStoredType = exports.definitionToType = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:ast:import");
const bn_js_1 = __importDefault(__webpack_require__(213550));
const Compiler = __importStar(__webpack_require__(884159));
const Utils = __importStar(__webpack_require__(707656));
const import_1 = __webpack_require__(560013);
//NOTE: the following function will *not* work for arbitrary nodes! It will,
//however, work well enough for what we need.  I.e., it will:
//1. work when given the actual variable definition as the node,
//2. work when given an elementary type as the node,
//3. work when given a user-defined type as the node,
//4. produce something of the correct size in all cases.
//Use beyond that is at your own risk!
//NOTE: set forceLocation to *null* to force no location. leave it undefined
//to not force a location.
function definitionToType(definition, compilationId, compiler, forceLocation) {
    let typeClass = Utils.typeClass(definition);
    let typeHint = Utils.typeStringWithoutLocation(definition);
    switch (typeClass) {
        case "bool":
            return {
                typeClass,
                typeHint
            };
        case "address": {
            switch (Compiler.Utils.solidityFamily(compiler)) {
                case "unknown": //I guess?
                case "pre-0.5.0":
                    return {
                        typeClass,
                        kind: "general",
                        typeHint
                    };
                default:
                    return {
                        typeClass,
                        kind: "specific",
                        payable: Utils.typeIdentifier(definition) === "t_address_payable"
                    };
            }
            break; //to satisfy typescript
        }
        case "uint": {
            let bytes = Utils.specifiedSize(definition);
            return {
                typeClass,
                bits: bytes * 8,
                typeHint
            };
        }
        case "int": {
            //typeScript won't let me group these for some reason
            let bytes = Utils.specifiedSize(definition);
            return {
                typeClass,
                bits: bytes * 8,
                typeHint
            };
        }
        case "fixed": {
            //typeScript won't let me group these for some reason
            let bytes = Utils.specifiedSize(definition);
            let places = Utils.decimalPlaces(definition);
            return {
                typeClass,
                bits: bytes * 8,
                places,
                typeHint
            };
        }
        case "ufixed": {
            let bytes = Utils.specifiedSize(definition);
            let places = Utils.decimalPlaces(definition);
            return {
                typeClass,
                bits: bytes * 8,
                places,
                typeHint
            };
        }
        case "string": {
            if (forceLocation === null) {
                return {
                    typeClass,
                    typeHint
                };
            }
            let location = forceLocation || Utils.referenceType(definition);
            return {
                typeClass,
                location,
                typeHint
            };
        }
        case "bytes": {
            let length = Utils.specifiedSize(definition);
            if (length !== null) {
                return {
                    typeClass,
                    kind: "static",
                    length,
                    typeHint
                };
            }
            else {
                if (forceLocation === null) {
                    return {
                        typeClass,
                        kind: "dynamic",
                        typeHint
                    };
                }
                let location = forceLocation || Utils.referenceType(definition);
                return {
                    typeClass,
                    kind: "dynamic",
                    location,
                    typeHint
                };
            }
        }
        case "array": {
            let baseDefinition = Utils.baseDefinition(definition);
            let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);
            let location = forceLocation || Utils.referenceType(definition);
            if (Utils.isDynamicArray(definition)) {
                if (forceLocation !== null) {
                    return {
                        typeClass,
                        baseType,
                        kind: "dynamic",
                        location,
                        typeHint
                    };
                }
                else {
                    return {
                        typeClass,
                        baseType,
                        kind: "dynamic",
                        typeHint
                    };
                }
            }
            else {
                let length = new bn_js_1.default(Utils.staticLengthAsString(definition));
                if (forceLocation !== null) {
                    return {
                        typeClass,
                        baseType,
                        kind: "static",
                        length,
                        location,
                        typeHint
                    };
                }
                else {
                    return {
                        typeClass,
                        baseType,
                        kind: "static",
                        length,
                        typeHint
                    };
                }
            }
        }
        case "mapping": {
            let keyDefinition = Utils.keyDefinition(definition);
            //note that we can skip the scopes argument here! that's only needed when
            //a general node, rather than a declaration, is being passed in
            let keyType = (definitionToType(keyDefinition, compilationId, compiler, null));
            //suppress the location on the key type (it'll be given as memory but
            //this is meaningless)
            //also, we have to tell TypeScript ourselves that this will be an elementary
            //type; it has no way of knowing that
            debug("definition: %O", definition);
            let valueDefinition = Utils.valueDefinition(definition);
            let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);
            if (forceLocation === null) {
                return {
                    typeClass,
                    keyType,
                    valueType
                };
            }
            return {
                typeClass,
                keyType,
                valueType,
                location: "storage"
            };
        }
        case "function": {
            //WARNING! This case will not work unless given the actual
            //definition!  It should return something *roughly* usable, though.
            let visibility = Utils.visibility(definition); //undefined if bad node
            let mutability = Utils.mutability(definition); //undefined if bad node
            let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK
            //note: don't force a location on these! use the listed location!
            let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));
            let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));
            switch (visibility) {
                case "internal":
                    return {
                        typeClass,
                        visibility,
                        mutability,
                        inputParameterTypes,
                        outputParameterTypes
                    };
                case "external":
                    return {
                        typeClass,
                        visibility,
                        kind: "specific",
                        mutability,
                        inputParameterTypes,
                        outputParameterTypes
                    };
            }
            break; //to satisfy typescript
        }
        case "struct": {
            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);
            let qualifiedName = typeHint.match(/struct (.*)/)[1];
            let definingContractName;
            let typeName;
            if (qualifiedName.includes(".")) {
                [definingContractName, typeName] = qualifiedName.split(".");
            }
            else {
                typeName = qualifiedName;
                //leave definingContractName undefined
            }
            if (forceLocation === null) {
                if (definingContractName) {
                    return {
                        typeClass,
                        kind: "local",
                        id,
                        typeName,
                        definingContractName
                    };
                }
                else {
                    return {
                        typeClass,
                        kind: "global",
                        id,
                        typeName
                    };
                }
            }
            let location = forceLocation || Utils.referenceType(definition);
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    location
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName,
                    location
                };
            }
        }
        case "enum": {
            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);
            let qualifiedName = typeHint.match(/enum (.*)/)[1];
            let definingContractName;
            let typeName;
            if (qualifiedName.includes(".")) {
                [definingContractName, typeName] = qualifiedName.split(".");
            }
            else {
                typeName = qualifiedName;
                //leave definingContractName undefined
            }
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName
                };
            }
        }
        case "userDefinedValueType": {
            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);
            let definingContractName;
            let typeName;
            if (typeHint.includes(".")) {
                [definingContractName, typeName] = typeHint.split(".");
            }
            else {
                typeName = typeHint;
                //leave definingContractName undefined
            }
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName
                };
            }
        }
        case "contract": {
            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);
            let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2];
            //note: we use the type string rather than the type identifier
            //in order to avoid having to deal with the underscore problem
            let contractKind = Utils.contractKind(definition);
            return {
                typeClass,
                kind: "native",
                id,
                typeName,
                contractKind
            };
        }
        case "magic": {
            let typeIdentifier = Utils.typeIdentifier(definition);
            let variable = (typeIdentifier.match(/^t_magic_(.*)$/)[1]);
            return {
                typeClass,
                variable
            };
        }
    }
}
exports.definitionToType = definitionToType;
//whereas the above takes variable definitions, this takes the actual type
//definition
function definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {
    switch (definition.nodeType) {
        case "StructDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            const memberTypes = definition.members.map(member => ({
                name: member.name,
                type: definitionToType(member, compilationId, compiler, null)
            }));
            if (definingContract) {
                return {
                    typeClass: "struct",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    memberTypes
                };
            }
            else {
                return {
                    typeClass: "struct",
                    kind: "global",
                    id,
                    typeName,
                    memberTypes
                };
            }
        }
        case "EnumDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            const options = definition.members.map(member => member.name);
            if (definingContract) {
                return {
                    typeClass: "enum",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    options
                };
            }
            else {
                return {
                    typeClass: "enum",
                    kind: "global",
                    id,
                    typeName,
                    options
                };
            }
        }
        case "UserDefinedValueTypeDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            let underlyingType = definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here
            if (definingContract) {
                return {
                    typeClass: "userDefinedValueType",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    underlyingType
                };
            }
            else {
                return {
                    typeClass: "userDefinedValueType",
                    kind: "global",
                    id,
                    typeName,
                    underlyingType
                };
            }
        }
        case "ContractDefinition": {
            let id = import_1.makeTypeId(definition.id, compilationId);
            let typeName = definition.name;
            let contractKind = definition.contractKind;
            let payable = Utils.isContractPayable(definition);
            return {
                typeClass: "contract",
                kind: "native",
                id,
                typeName,
                contractKind,
                payable
            };
        }
    }
}
exports.definitionToStoredType = definitionToStoredType;
function getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {
    const id = import_1.makeTypeId(definition.id, compilationId);
    let definingContractName;
    let typeName;
    if (definition.canonicalName) {
        if (definition.canonicalName.includes(".")) {
            [definingContractName, typeName] = definition.canonicalName.split(".");
        }
        else {
            typeName = definition.canonicalName;
        }
    }
    else {
        //due to a bug, in 0.8.8 UDVTs lack a canonicalName.
        //so we'll set typeName based on name instead of canonicalName,
        //and set definingContractName below based on definingContract.
        //(this does mean that we'll mess up a bit if referenceDeclarations
        //is not passed... but realistically that shouldn't come up?  really the
        //same kind of hapepns for every type)
        typeName = definition.name;
    }
    let definingContract = undefined;
    ;
    if (referenceDeclarations) {
        let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === "ContractDefinition" &&
            node.nodes.some((subNode) => import_1.makeTypeId(subNode.id, compilationId) === id));
        if (contractDefinition) {
            definingContract = (definitionToStoredType(contractDefinition, compilationId, compiler)); //can skip reference declarations
            if (!definingContractName) {
                definingContractName = contractDefinition.name;
            }
        }
    }
    return {
        definingContract,
        definingContractName,
        typeName,
        id
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 114442:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = exports.Utils = void 0;
__exportStar(__webpack_require__(765786), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(707656));
exports.Utils = Utils;
const Import = __importStar(__webpack_require__(849965));
exports.Import = Import;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 765786:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 707656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionClass = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:ast:utils");
const Common = __importStar(__webpack_require__(299987));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const cloneDeep_1 = __importDefault(__webpack_require__(927311));
/** @category Definition Reading */
function typeIdentifier(definition) {
    return definition.typeDescriptions.typeIdentifier;
}
exports.typeIdentifier = typeIdentifier;
/** @category Definition Reading */
function typeString(definition) {
    return definition.typeDescriptions.typeString;
}
exports.typeString = typeString;
/**
 * Returns the type string, but with location (if any) stripped off the end
 * @category Definition Reading
 */
function typeStringWithoutLocation(definition) {
    if (definition.nodeType === "YulTypedName") {
        //for handling Yul variables
        return "bytes32";
    }
    return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, "");
}
exports.typeStringWithoutLocation = typeStringWithoutLocation;
/**
 * returns basic type class for a variable definition node
 * e.g.:
 *  `t_uint256` becomes `uint`
 *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
 * @category Definition Reading
 */
function typeClass(definition) {
    if (definition.nodeType === "YulTypedName") {
        //for handling Yul variables
        return "bytes";
    }
    return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
}
exports.typeClass = typeClass;
/**
 * similar to typeClass, but includes any numeric qualifiers
 * e.g.:
 * `t_uint256` becomes `uint256`
 * @category Definition Reading
 */
function typeClassLongForm(definition) {
    return typeIdentifier(definition).match(/t_([^$_]+)/)[1];
}
exports.typeClassLongForm = typeClassLongForm;
/**
 * for user-defined types -- structs, enums, contracts
 * often you can get these from referencedDeclaration, but not
 * always
 * @category Definition Reading
 */
function typeId(definition) {
    debug("definition %O", definition);
    return parseInt(typeIdentifier(definition).match(/\$(\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);
}
exports.typeId = typeId;
/**
 * For function types; returns internal or external
 * (not for use on other types! will cause an error!)
 * should only return "internal" or "external"
 * @category Definition Reading
 */
function visibility(definition) {
    return ((definition.typeName
        ? definition.typeName.visibility
        : definition.visibility));
}
exports.visibility = visibility;
/**
 * e.g. uint48 -> 6
 * @return size in bytes for explicit type size, or `null` if not stated
 * @category Definition Reading
 */
function specifiedSize(definition) {
    if (definition.nodeType === "YulTypedName") {
        return 32; //for handling Yul variables
    }
    let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);
    if (!specified) {
        return null;
    }
    let num = parseInt(specified[1]);
    switch (typeClass(definition)) {
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
            return num / 8;
        case "bytes":
            return num;
        default:
            debug("Unknown type for size specification: %s", typeIdentifier(definition));
    }
}
exports.specifiedSize = specifiedSize;
/**
 * for fixed-point types, obviously
 * @category Definition Reading
 */
function decimalPlaces(definition) {
    return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);
}
exports.decimalPlaces = decimalPlaces;
/** @category Definition Reading */
function isArray(definition) {
    return typeIdentifier(definition).match(/^t_array/) != null;
}
exports.isArray = isArray;
/** @category Definition Reading */
function isDynamicArray(definition) {
    return (isArray(definition) &&
        //NOTE: we do this by parsing the type identifier, rather than by just
        //checking the length field, because we might be using this on a faked-up
        //definition
        typeIdentifier(definition).match(/\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null);
}
exports.isDynamicArray = isDynamicArray;
/**
 * length of a statically sized array -- please only use for arrays
 * already verified to be static!
 * @category Definition Reading
 */
function staticLength(definition) {
    //NOTE: we do this by parsing the type identifier, rather than by just
    //checking the length field, because we might be using this on a faked-up
    //definition
    return parseInt(staticLengthAsString(definition));
}
exports.staticLength = staticLength;
/**
 * see staticLength for explanation
 * @category Definition Reading
 */
function staticLengthAsString(definition) {
    return typeIdentifier(definition).match(/\$(\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];
}
exports.staticLengthAsString = staticLengthAsString;
/** @category Definition Reading */
function isStruct(definition) {
    return typeIdentifier(definition).match(/^t_struct/) != null;
}
exports.isStruct = isStruct;
/** @category Definition Reading */
function isMapping(definition) {
    return typeIdentifier(definition).match(/^t_mapping/) != null;
}
exports.isMapping = isMapping;
/** @category Definition Reading */
function isEnum(definition) {
    return typeIdentifier(definition).match(/^t_enum/) != null;
}
exports.isEnum = isEnum;
/** @category Definition Reading */
function isReference(definition) {
    return (typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null);
}
exports.isReference = isReference;
/**
 * note: only use this on things already verified to be references
 * @category Definition Reading
 */
function referenceType(definition) {
    return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];
}
exports.referenceType = referenceType;
/**
 * only for contract types, obviously! will yield nonsense otherwise!
 * @category Definition Reading
 */
function contractKind(definition) {
    return typeString(definition).split(" ")[0];
}
exports.contractKind = contractKind;
/**
 * stack size, in words, of a given type
 * note: this function assumes that UDVTs only ever take up
 * a single word, which is currently true
 * @category Definition Reading
 */
function stackSize(definition) {
    if (typeClass(definition) === "function" &&
        visibility(definition) === "external") {
        return 2;
    }
    if (isReference(definition) && referenceType(definition) === "calldata") {
        if (typeClass(definition) === "string" ||
            typeClass(definition) === "bytes") {
            return 2;
        }
        if (isDynamicArray(definition)) {
            return 2;
        }
    }
    return 1;
}
exports.stackSize = stackSize;
/** @category Definition Reading */
function isSimpleConstant(definition) {
    const types = ["stringliteral", "rational"];
    return types.includes(typeClass(definition));
}
exports.isSimpleConstant = isSimpleConstant;
/**
 * definition: a storage reference definition
 * location: the location you want it to refer to instead
 * @category Definition Reading
 */
function spliceLocation(definition, location) {
    debug("definition %O", definition);
    return Object.assign(Object.assign({}, definition), { typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), { typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, "_" + location) }) });
}
exports.spliceLocation = spliceLocation;
/**
 * adds "_ptr" on to the end of type identifiers that might need it; note that
 * this operates on identifiers, not definitions
 * @category Definition Reading
 */
function regularizeTypeIdentifier(identifier) {
    return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, "$1_ptr" //this used to use lookbehind for clarity, but Firefox...
    //(see: https://github.com/trufflesuite/truffle/issues/3068 )
    );
}
exports.regularizeTypeIdentifier = regularizeTypeIdentifier;
/**
 * extract the actual numerical value from a node of type rational.
 * currently assumes result will be integer (currently returns BN)
 * @category Definition Reading
 */
function rationalValue(definition) {
    let identifier = typeIdentifier(definition);
    let absoluteValue = identifier.match(/_(\d+)_by_1$/)[1];
    let isNegative = identifier.match(/_minus_/) != null;
    return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);
}
exports.rationalValue = rationalValue;
/** @category Definition Reading */
function baseDefinition(definition) {
    if (definition.typeName && definition.typeName.baseType) {
        return definition.typeName.baseType;
    }
    if (definition.baseType) {
        return definition.baseType;
    }
    //otherwise, we'll have to spoof it up ourselves
    let baseIdentifier = typeIdentifier(definition).match(/^t_array\$_(.*)_\$/)[1];
    //greedy match to extract everything from first to last dollar sign
    // HACK - internal types for memory or storage also seem to be pointers
    baseIdentifier = regularizeTypeIdentifier(baseIdentifier);
    // another HACK - we get away with it because we're only using that one property
    let result = cloneDeep_1.default(definition);
    result.typeDescriptions.typeIdentifier = baseIdentifier;
    return result;
    //WARNING -- these hacks do *not* correctly handle all cases!
    //they do, however, handle the cases we currently need.
}
exports.baseDefinition = baseDefinition;
/**
 * for use for mappings and arrays only!
 * for arrays, fakes up a uint definition
 * @category Definition Reading
 */
function keyDefinition(definition, scopes) {
    let result;
    switch (typeClass(definition)) {
        case "mapping":
            //first: is there a key type already there? if so just use that
            if (definition.keyType) {
                return definition.keyType;
            }
            if (definition.typeName && definition.typeName.keyType) {
                return definition.typeName.keyType;
            }
            //otherwise: is there a referencedDeclaration? if so try using that
            let baseDeclarationId = definition.referencedDeclaration;
            debug("baseDeclarationId %d", baseDeclarationId);
            //if there's a referencedDeclaration, we'll use that
            if (baseDeclarationId !== undefined) {
                let baseDeclaration = scopes[baseDeclarationId].definition;
                return baseDeclaration.keyType || baseDeclaration.typeName.keyType;
            }
            //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;
            //we'll have to spoof it up ourselves
            let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\$_(.*?)_\$_/)[1];
            //use *non*-greedy match; note that if the key type could include
            //the sequence "_$_", this could cause a problem, but they can't; the only
            //valid key types that include dollar signs at all are user-defined types,
            //which contain both "$_" and "_$" but never "_$_".
            // HACK - internal types for memory or storage also seem to be pointers
            keyIdentifier = regularizeTypeIdentifier(keyIdentifier);
            let keyString = typeString(definition).match(/mapping\((.*?) => .*\)( storage)?$/)[1];
            //use *non*-greedy match; note that if the key type could include
            //"=>", this could cause a problem, but mappings are not allowed as key
            //types, so this can't come up
            // another HACK - we get away with it because we're only using that one property
            result = cloneDeep_1.default(definition);
            result.typeDescriptions = {
                typeIdentifier: keyIdentifier,
                typeString: keyString
            };
            return result;
        case "array":
            //HACK -- again we should get away with it because for a uint256 we don't
            //really need to inspect the other properties
            result = cloneDeep_1.default(definition);
            result.typeDescriptions = {
                typeIdentifier: "t_uint256",
                typeString: "uint256"
            };
            return result;
        default:
            debug("unrecognized index access!");
    }
}
exports.keyDefinition = keyDefinition;
/**
 * for use for mappings only!
 * @category Definition Reading
 */
function valueDefinition(definition, scopes) {
    let result;
    //first: is there a value type already there? if so just use that
    if (definition.valueType) {
        return definition.valueType;
    }
    if (definition.typeName && definition.typeName.valueType) {
        return definition.typeName.valueType;
    }
    //otherwise: is there a referencedDeclaration? if so try using that
    let baseDeclarationId = definition.referencedDeclaration;
    debug("baseDeclarationId %d", baseDeclarationId);
    //if there's a referencedDeclaration, we'll use that
    if (baseDeclarationId !== undefined) {
        let baseDeclaration = scopes[baseDeclarationId].definition;
        return baseDeclaration.valueType || baseDeclaration.typeName.valueType;
    }
    //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;
    //we'll have to spoof it up ourselves
    let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\$_.*?_\$_(.*)_\$/)[1];
    //use *non*-greedy match on the key; note that if the key type could include
    //the sequence "_$_", this could cause a problem, but they can't; the only
    //valid key types that include dollar signs at all are user-defined types,
    //which contain both "$_" and "_$" but never "_$_".
    // HACK - internal types for memory or storage also seem to be pointers
    valueIdentifier = regularizeTypeIdentifier(valueIdentifier);
    let valueString = typeString(definition).match(/mapping\(.*? => (.*)\)( storage)?$/)[1];
    //use *non*-greedy match; note that if the key type could include
    //"=>", this could cause a problem, but mappings are not allowed as key
    //types, so this can't come up
    // another HACK - we get away with it because we're only using that one property
    result = cloneDeep_1.default(definition);
    result.typeDescriptions = {
        typeIdentifier: valueIdentifier,
        typeString: valueString
    };
    return result;
}
exports.valueDefinition = valueDefinition;
/**
 * returns input parameters, then output parameters
 * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE
 * NOT FOR FUNCTION DEFINITIONS
 * @category Definition Reading
 */
function parameters(definition) {
    let typeObject = definition.typeName || definition;
    if (typeObject.parameterTypes && typeObject.returnParameterTypes) {
        return [
            typeObject.parameterTypes.parameters,
            typeObject.returnParameterTypes.parameters
        ];
    }
    else {
        return undefined;
    }
}
exports.parameters = parameters;
/**
 * compatibility function, since pre-0.5.0 functions don't have node.kind
 * returns undefined if you don't put in a function node
 * @category Definition Reading
 */
function functionKind(node) {
    if (node.nodeType !== "FunctionDefinition") {
        return undefined;
    }
    if (node.kind !== undefined) {
        //if we're dealing with 0.5.x, we can just read node.kind
        return node.kind;
    }
    //otherwise, we need this little shim
    if (node.isConstructor) {
        return "constructor";
    }
    return node.name === "" ? "fallback" : "function";
}
exports.functionKind = functionKind;
//this is kind of a weird one, it exposes some Solidity internals.
//for internal functions it'll return "internal".
//for external functions it'll return "external".
//for library functions it'll return "delegatecall".
//and for builtin functions, it'll return an internal name for
//that particular builtin function.
//(there are more possibilities but I'm not going to list them all here)
function functionClass(node) {
    const match = typeIdentifier(node).match(/^t_function_([^_]+)_/);
    return match ? match[1] : undefined;
}
exports.functionClass = functionClass;
/**
 * similar compatibility function for mutability for pre-0.4.16 versions
 * returns undefined if you don't give it a FunctionDefinition or
 * VariableDeclaration
 * @category Definition Reading
 */
function mutability(node) {
    node = node.typeName || node;
    if (node.nodeType !== "FunctionDefinition" &&
        node.nodeType !== "FunctionTypeName") {
        return undefined;
    }
    if (node.stateMutability !== undefined) {
        //if we're dealing with 0.4.16 or later, we can just read node.stateMutability
        return node.stateMutability;
    }
    //otherwise, we need this little shim
    if (node.payable) {
        return "payable";
    }
    if (node.constant) {
        //yes, it means "view" even if you're looking at a variable declaration!
        //old Solidity was weird!
        return "view";
    }
    return "nonpayable";
}
exports.mutability = mutability;
/**
 * takes a contract definition and asks, does it have a payable fallback
 * function?
 * @category Definition Reading
 */
function isContractPayable(definition) {
    return definition.nodes.some(node => node.nodeType === "FunctionDefinition" &&
        (functionKind(node) === "fallback" || functionKind(node) === "receive") &&
        mutability(node) === "payable");
}
exports.isContractPayable = isContractPayable;
/**
 * the main function. just does some dispatch.
 * returns undefined on bad input
 */
function definitionToAbi(node, referenceDeclarations) {
    switch (node.nodeType) {
        case "FunctionDefinition":
            if (node.visibility === "public" || node.visibility === "external") {
                return functionDefinitionToAbi(node, referenceDeclarations);
            }
            else {
                return undefined;
            }
        case "EventDefinition":
            return eventDefinitionToAbi(node, referenceDeclarations);
        case "ErrorDefinition":
            return errorDefinitionToAbi(node, referenceDeclarations);
        case "VariableDeclaration":
            if (node.visibility === "public") {
                return getterDefinitionToAbi(node, referenceDeclarations);
            }
            else {
                return undefined;
            }
        default:
            return undefined;
    }
}
exports.definitionToAbi = definitionToAbi;
//note: not for FunctionTypeNames or VariableDeclarations
function functionDefinitionToAbi(node, referenceDeclarations) {
    let kind = functionKind(node);
    let stateMutability = mutability(node);
    let payable = stateMutability === "payable";
    let inputs;
    switch (kind) {
        case "function":
            let name = node.name;
            let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);
            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
            return {
                type: "function",
                name,
                inputs,
                outputs,
                stateMutability
            };
        case "constructor":
            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
            //note: need to coerce because of mutability restrictions
            return {
                type: "constructor",
                inputs,
                stateMutability,
                payable
            };
        case "fallback":
            //note: need to coerce because of mutability restrictions
            return {
                type: "fallback",
                stateMutability,
                payable
            };
        case "receive":
            //note: need to coerce because of mutability restrictions
            return {
                type: "receive",
                stateMutability,
                payable
            };
    }
}
function eventDefinitionToAbi(node, referenceDeclarations) {
    let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
    let name = node.name;
    let anonymous = node.anonymous;
    return {
        type: "event",
        inputs,
        name,
        anonymous
    };
}
function errorDefinitionToAbi(node, referenceDeclarations) {
    let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
    let name = node.name;
    return {
        type: "error",
        inputs,
        name
    };
}
function parametersToAbi(nodes, referenceDeclarations) {
    return nodes.map(node => parameterToAbi(node, referenceDeclarations));
}
//NOTE: This function is only for types that could potentially go in the ABI!
//(otherwise it could, say, loop infinitely)
//currently it will only ever be called on those because it's only called from
//definitionToAbi, which filters out any definitions that are not for
//this that *actually* go in the ABI
//if you want to expand it to handle those (by throwing an exception, say),
//you'll need to give it a way to detect circularities
function parameterToAbi(node, referenceDeclarations) {
    let name = node.name; //may be the empty string... or even undefined for a base type
    let components;
    let internalType = typeStringWithoutLocation(node);
    //is this an array? if so use separate logic
    if (typeClass(node) === "array") {
        let baseType = node.typeName ? node.typeName.baseType : node.baseType;
        let baseAbi = parameterToAbi(baseType, referenceDeclarations);
        let arraySuffix = isDynamicArray(node) ? `[]` : `[${staticLength(node)}]`;
        const parameter = {
            name,
            type: baseAbi.type + arraySuffix,
            components: baseAbi.components,
            internalType
        };
        if ("indexed" in node) {
            return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });
        }
        else {
            return parameter;
        }
    }
    let abiTypeString = toAbiType(node, referenceDeclarations);
    //otherwise... is it a struct? if so we need to populate components
    if (typeClass(node) === "struct") {
        let id = typeId(node);
        let referenceDeclaration = referenceDeclarations[id];
        if (referenceDeclaration === undefined) {
            let typeToDisplay = typeString(node);
            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);
        }
        components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);
    }
    const parameter = {
        name,
        type: abiTypeString,
        components,
        internalType
    };
    if ("indexed" in node) {
        return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });
    }
    else {
        return parameter;
    }
}
//note: this is only meant for non-array types that can go in the ABI
//it returns how that type is notated in the ABI -- just the string,
//to be clear, not components of tuples
//again, NOT FOR ARRAYS
function toAbiType(node, referenceDeclarations) {
    let basicType = typeClassLongForm(node); //get that whole first segment!
    switch (basicType) {
        case "contract":
            return "address";
        case "struct":
            return "tuple"; //the more detailed checking will be handled elsewhere
        case "enum": {
            const referenceId = typeId(node);
            const referenceDeclaration = referenceDeclarations[referenceId];
            if (referenceDeclaration === undefined) {
                const typeToDisplay = typeString(node);
                throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);
            }
            const numOptions = referenceDeclaration.members.length;
            const bits = 8 * Math.ceil(Math.log2(numOptions) / 8);
            return `uint${bits}`;
        }
        case "userDefinedValueType": {
            const referenceId = typeId(node);
            const referenceDeclaration = referenceDeclarations[referenceId];
            if (referenceDeclaration === undefined) {
                const typeToDisplay = typeString(node);
                throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);
            }
            const underlyingType = referenceDeclaration.underlyingType;
            return toAbiType(underlyingType, referenceDeclarations);
        }
        default:
            return basicType;
        //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;
        //address will have "payable" left off;
        //external functions will be reduced to "function" (and internal functions shouldn't
        //be passed in!)
        //(mappings shouldn't be passed in either obviously)
        //(nor arrays :P )
    }
}
function getterDefinitionToAbi(node, referenceDeclarations) {
    debug("getter node: %O", node);
    let name = node.name;
    let { inputs, outputs } = getterParameters(node, referenceDeclarations);
    let inputsAbi = parametersToAbi(inputs, referenceDeclarations);
    let outputsAbi = parametersToAbi(outputs, referenceDeclarations);
    return {
        type: "function",
        name,
        inputs: inputsAbi,
        outputs: outputsAbi,
        stateMutability: "view"
    };
}
//how getter parameters work:
//INPUT:
//types other than arrays and mappings take no input.
//array getters take uint256 input. mapping getters take input of their key type.
//if arrays, mappings, stacked, then takes multiple inputs, in order from outside
//to in.
//These parameters are unnamed.
//OUTPUT:
//if base type (beneath mappings & arrays) is not a struct, returns that.
//(This return parameter has no name -- it is *not* named for the variable!)
//if it is a struct, returns multiple outputs, one for each member of the struct,
//*except* arrays and mappings.  (And they have names, the names of the members.)
//important note: inner structs within a struct are just returned, not
//partially destructured like the outermost struct!  Yes, this is confusing.
function getterParameters(node, referenceDeclarations) {
    let baseNode = node.typeName || node;
    let inputs = [];
    while (typeClass(baseNode) === "array" || typeClass(baseNode) === "mapping") {
        let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition
        inputs.push(Object.assign(Object.assign({}, keyNode), { name: "" })); //again, getter input params have no name
        switch (typeClass(baseNode)) {
            case "array":
                baseNode = baseNode.baseType;
                break;
            case "mapping":
                baseNode = baseNode.valueType;
                break;
        }
    }
    //at this point, baseNode should hold the base type
    //now we face the question: is it a struct?
    if (typeClass(baseNode) === "struct") {
        let id = typeId(baseNode);
        let referenceDeclaration = referenceDeclarations[id];
        if (referenceDeclaration === undefined) {
            let typeToDisplay = typeString(baseNode);
            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);
        }
        let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== "array" && typeClass(member) !== "mapping");
        return { inputs, outputs }; //no need to wash name!
    }
    else {
        //only one output; it's just the base node, with its name washed
        return { inputs, outputs: [Object.assign(Object.assign({}, baseNode), { name: "" })] };
    }
}
exports.getterParameters = getterParameters;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 849107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.byteLength = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:basic:allocate");
const Common = __importStar(__webpack_require__(299987));
const Evm = __importStar(__webpack_require__(149218));
const Format = __importStar(__webpack_require__(429965));
//only for direct types!
function byteLength(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        case "bool":
            return 1;
        case "address":
        case "contract":
            return Evm.Utils.ADDRESS_SIZE;
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
            return dataType.bits / 8;
        case "function":
            switch (dataType.visibility) {
                case "internal":
                    return Evm.Utils.PC_SIZE * 2;
                case "external":
                    return Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE;
            }
        case "bytes": //we assume we're in the static case
            return dataType.length;
        case "enum": {
            const storedType = userDefinedTypes[dataType.id];
            if (!storedType || !storedType.options) {
                throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
            }
            const numValues = storedType.options.length;
            return Math.ceil(Math.log2(numValues) / 8);
        }
        case "userDefinedValueType": {
            const storedType = userDefinedTypes[dataType.id];
            if (!storedType || !storedType.underlyingType) {
                throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
            }
            const { underlyingType } = storedType;
            return byteLength(underlyingType, userDefinedTypes);
        }
    }
}
exports.byteLength = byteLength;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 257939:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:basic:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const Format = __importStar(__webpack_require__(429965));
const Contexts = __importStar(__webpack_require__(697938));
const Evm = __importStar(__webpack_require__(149218));
const errors_1 = __webpack_require__(672325);
const allocate_1 = __webpack_require__(849107);
function* decodeBasic(dataType, pointer, info, options = {}) {
    const { state } = info;
    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so it's OK
    const paddingMode = options.paddingMode || "default";
    let bytes;
    let rawBytes;
    try {
        bytes = yield* read_1.default(pointer, state);
    }
    catch (error) {
        debug("segfault, pointer %o, state: %O", pointer, state);
        return errors_1.handleDecodingError(dataType, error, strict);
    }
    rawBytes = bytes;
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    switch (dataType.typeClass) {
        case "userDefinedValueType": {
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            if (!fullType.underlyingType) {
                const error = {
                    kind: "UserDefinedTypeNotFoundError",
                    type: fullType
                };
                if (strict || options.allowRetry) {
                    throw new errors_1.StopDecodingError(error, true);
                    //note that we allow a retry if we couldn't locate the underlying type!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
            const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);
            switch (underlyingResult.kind //yes this switch is a little unnecessary :P
            ) {
                case "value":
                    //wrap the value and return
                    return {
                        //no idea why need coercion here
                        type: fullType,
                        kind: "value",
                        value: underlyingResult
                    };
                case "error":
                    //wrap the error and return an error result!
                    //this is inconsistent with how we handle other container types
                    //(structs, arrays, mappings), where having an error in one element
                    //does not cause an error in the whole thing, but to do that here
                    //would cause problems for the type system :-/
                    //so we'll just be inconsistent
                    return {
                        //TS is being bad again :-/
                        type: fullType,
                        kind: "error",
                        error: {
                            kind: "WrappedError",
                            error: underlyingResult
                        }
                    };
            }
            break; //to satisfy TS :P
        }
        case "bool": {
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "BoolPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            //note: the use of the BN is a little silly here,
            //but, kind of stuck with it for now
            const numeric = Conversion.toBN(bytes);
            if (numeric.eqn(0)) {
                return {
                    type: dataType,
                    kind: "value",
                    value: { asBoolean: false }
                };
            }
            else if (numeric.eqn(1)) {
                return {
                    type: dataType,
                    kind: "value",
                    value: { asBoolean: true }
                };
            }
            else {
                let error = {
                    kind: "BoolOutOfRangeError",
                    rawAsBN: numeric
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
        }
        case "uint":
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "UintPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN: Conversion.toBN(bytes),
                    rawAsBN: Conversion.toBN(rawBytes)
                }
            };
        case "int":
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "IntPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN: Conversion.toSignedBN(bytes),
                    rawAsBN: Conversion.toSignedBN(rawBytes)
                }
            };
        case "address":
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "AddressPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asAddress: Evm.Utils.toAddress(bytes),
                    rawAsHex: Conversion.toHexString(rawBytes)
                }
            };
        case "contract":
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "ContractPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            const contractValueInfo = yield* decodeContract(bytes, info);
            return {
                type: fullType,
                kind: "value",
                value: contractValueInfo
            };
        case "bytes":
            //NOTE: we assume this is a *static* bytestring,
            //because this is decodeBasic! dynamic ones should
            //go to decodeBytes!
            let coercedDataType = dataType;
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "BytesPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: coercedDataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: coercedDataType,
                kind: "value",
                value: {
                    asHex: Conversion.toHexString(bytes),
                    rawAsHex: Conversion.toHexString(rawBytes)
                }
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    if (!checkPadding(bytes, dataType, paddingMode)) {
                        const error = {
                            kind: "FunctionExternalNonStackPaddingError",
                            paddingType: getPaddingType(dataType, paddingMode),
                            raw: Conversion.toHexString(bytes)
                        };
                        if (strict) {
                            throw new errors_1.StopDecodingError(error);
                        }
                        return {
                            type: dataType,
                            kind: "error",
                            error
                        };
                    }
                    bytes = removePadding(bytes, dataType, paddingMode);
                    const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);
                    const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);
                    return {
                        type: dataType,
                        kind: "value",
                        value: yield* decodeExternalFunction(address, selector, info)
                    };
                case "internal":
                    //note: we used to error if we hit this point with strict === true,
                    //since internal function pointers don't go in the ABI, and strict
                    //mode is intended for ABI decoding.  however, there are times when
                    //we want to use strict mode to decode immutables, and immutables can
                    //include internal function pointers.  so now we allow this.  yes,
                    //this is a bit of an abuse of strict mode, which was after all meant
                    //for ABI decoding, but oh well.
                    if (!checkPadding(bytes, dataType, paddingMode)) {
                        const error = {
                            kind: "FunctionInternalPaddingError",
                            paddingType: getPaddingType(dataType, paddingMode),
                            raw: Conversion.toHexString(bytes)
                        };
                        if (strict) {
                            throw new errors_1.StopDecodingError(error);
                        }
                        return {
                            type: dataType,
                            kind: "error",
                            error
                        };
                    }
                    bytes = removePadding(bytes, dataType, paddingMode);
                    const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);
                    const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);
                    return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);
            }
            break; //to satisfy TypeScript
        case "enum": {
            let numeric = Conversion.toBN(bytes);
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            if (!fullType.options) {
                let error = {
                    kind: "EnumNotFoundDecodingError",
                    type: fullType,
                    rawAsBN: numeric
                };
                if (strict || options.allowRetry) {
                    throw new errors_1.StopDecodingError(error, true);
                    //note that we allow a retry if we couldn't locate the enum type!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
            //note: I'm doing the padding checks a little more manually on this one
            //so that we can have the right type of error
            const numOptions = fullType.options.length;
            const numBytes = Math.ceil(Math.log2(numOptions) / 8);
            const paddingType = getPaddingType(dataType, paddingMode);
            if (!checkPaddingDirect(bytes, numBytes, paddingType)) {
                let error = {
                    kind: "EnumPaddingError",
                    type: fullType,
                    paddingType,
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePaddingDirect(bytes, numBytes, paddingType);
            numeric = Conversion.toBN(bytes); //alter numeric!
            if (numeric.ltn(numOptions)) {
                const name = fullType.options[numeric.toNumber()];
                //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an
                //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have
                //an enum with that many options in the first place, we have bigger problems!
                return {
                    type: fullType,
                    kind: "value",
                    value: {
                        name,
                        numericAsBN: numeric
                    }
                };
            }
            else {
                let error = {
                    kind: "EnumOutOfRangeError",
                    type: fullType,
                    rawAsBN: numeric
                };
                if (strict) {
                    //note:
                    //if the enum is merely out of range rather than out of the ABI range,
                    //we do NOT throw an error here!  instead we simply return an error value,
                    //which we normally avoid doing in strict mode.  (the error will be caught
                    //later at the re-encoding step instead.)  why?  because we might be running
                    //in ABI mode, so we may need to abify this "value" rather than just throwing
                    //it out.
                    throw new errors_1.StopDecodingError(error);
                    //note that we do NOT allow a retry here!
                    //if we *can* find the enum type but the value is out of range,
                    //we *know* that it is invalid!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
        }
        case "fixed": {
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "FixedPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            let asBN = Conversion.toSignedBN(bytes);
            let rawAsBN = Conversion.toSignedBN(rawBytes);
            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);
            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBig,
                    rawAsBig
                }
            };
        }
        case "ufixed": {
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "UfixedPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            let asBN = Conversion.toBN(bytes);
            let rawAsBN = Conversion.toBN(rawBytes);
            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);
            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBig,
                    rawAsBig
                }
            };
        }
    }
}
exports.decodeBasic = decodeBasic;
//NOTE that this function returns a ContractValueInfo, not a ContractResult
function* decodeContract(addressBytes, info) {
    return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;
}
exports.decodeContract = decodeContract;
function* decodeContractAndContext(addressBytes, info) {
    let address = Evm.Utils.toAddress(addressBytes);
    let rawAddress = Conversion.toHexString(addressBytes);
    let codeBytes = yield {
        type: "code",
        address
    };
    let code = Conversion.toHexString(codeBytes);
    let context = Contexts.Utils.findContext(info.contexts, code);
    if (context !== null) {
        return {
            context,
            contractInfo: {
                kind: "known",
                address,
                rawAddress,
                class: Contexts.Import.contextToType(context)
            }
        };
    }
    else {
        return {
            context,
            contractInfo: {
                kind: "unknown",
                address,
                rawAddress
            }
        };
    }
}
//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes
//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult
function* decodeExternalFunction(addressBytes, selectorBytes, info) {
    let { contractInfo: contract, context } = yield* decodeContractAndContext(addressBytes, info);
    let selector = Conversion.toHexString(selectorBytes);
    if (contract.kind === "unknown") {
        return {
            kind: "unknown",
            contract,
            selector
        };
    }
    let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;
    if (abiEntry === undefined) {
        return {
            kind: "invalid",
            contract,
            selector
        };
    }
    return {
        kind: "known",
        contract,
        selector,
        abi: abiEntry
    };
}
exports.decodeExternalFunction = decodeExternalFunction;
//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult
function decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {
    const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();
    const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();
    const context = Contexts.Import.contextToType(info.currentContext);
    //before anything else: do we even have an internal functions table?
    //if not, we'll just return the info we have without really attemting to decode
    if (!info.internalFunctionsTable) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "unknown",
                context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    }
    //also before we continue: is the PC zero? if so let's just return that
    if (deployedPc === 0 && constructorPc === 0) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "exception",
                context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    }
    //another check: is only the deployed PC zero?
    if (deployedPc === 0 && constructorPc !== 0) {
        const error = {
            kind: "MalformedInternalFunctionError",
            context,
            deployedProgramCounter: 0,
            constructorProgramCounter: constructorPc
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    //one last pre-check: is this a deployed-format pointer in a constructor?
    if (info.currentContext.isConstructor && constructorPc === 0) {
        const error = {
            kind: "DeployedFunctionInConstructorError",
            context,
            deployedProgramCounter: deployedPc,
            constructorProgramCounter: 0
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    //otherwise, we get our function
    const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;
    const functionEntry = info.internalFunctionsTable[pc];
    if (!functionEntry) {
        //if it's not zero and there's no entry... error!
        const error = {
            kind: "NoSuchInternalFunctionError",
            context,
            deployedProgramCounter: deployedPc,
            constructorProgramCounter: constructorPc
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    if (functionEntry.isDesignatedInvalid) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "exception",
                context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    }
    const name = functionEntry.name;
    const mutability = functionEntry.mutability;
    const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null
    const id = Evm.Import.makeInternalFunctionId(functionEntry);
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "function",
            context,
            deployedProgramCounter: deployedPc,
            constructorProgramCounter: constructorPc,
            name,
            id,
            definedIn,
            mutability
        }
    };
}
function checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {
    const length = allocate_1.byteLength(dataType, userDefinedTypes);
    const paddingType = getPaddingType(dataType, paddingMode);
    if (paddingMode === "permissive") {
        switch (dataType.typeClass) {
            case "bool":
            case "enum":
            case "function":
                //these three types are checked even in permissive mode
                return checkPaddingDirect(bytes, length, paddingType);
            default:
                return true;
        }
    }
    else {
        return checkPaddingDirect(bytes, length, paddingType);
    }
}
function removePadding(bytes, dataType, paddingMode, userDefinedTypes) {
    const length = allocate_1.byteLength(dataType, userDefinedTypes);
    const paddingType = getPaddingType(dataType, paddingMode);
    return removePaddingDirect(bytes, length, paddingType);
}
function removePaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "right":
            return bytes.slice(0, length);
        default:
            return bytes.slice(-length);
    }
}
function checkPaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "left":
            return checkPaddingLeft(bytes, length);
        case "right":
            return checkPaddingRight(bytes, length);
        case "signed":
            return checkPaddingSigned(bytes, length);
        case "signedOrLeft":
            return (checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length));
    }
}
function getPaddingType(dataType, paddingMode) {
    switch (paddingMode) {
        case "right":
            return "right";
        case "default":
        case "permissive":
            return defaultPaddingType(dataType);
        case "zero": {
            const defaultType = defaultPaddingType(dataType);
            return defaultType === "signed" ? "left" : defaultType;
        }
        case "defaultOrZero": {
            const defaultType = defaultPaddingType(dataType);
            return defaultType === "signed" ? "signedOrLeft" : defaultType;
        }
    }
}
function defaultPaddingType(dataType) {
    switch (dataType.typeClass) {
        case "bytes":
            return "right";
        case "int":
        case "fixed":
            return "signed";
        case "function":
            if (dataType.visibility === "external") {
                return "right";
            }
        //otherwise, fall through to default
        default:
            return "left";
    }
}
function checkPaddingRight(bytes, length) {
    let padding = bytes.slice(length); //cut off the first length bytes
    return padding.every(paddingByte => paddingByte === 0);
}
//exporting this one for use in stack.ts
function checkPaddingLeft(bytes, length) {
    let padding = bytes.slice(0, -length); //cut off the last length bytes
    return padding.every(paddingByte => paddingByte === 0);
}
exports.checkPaddingLeft = checkPaddingLeft;
function checkPaddingSigned(bytes, length) {
    let padding = bytes.slice(0, -length); //padding is all but the last length bytes
    let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes
    let signByte = value[0] & 0x80 ? 0xff : 0x00;
    return padding.every(paddingByte => paddingByte === signByte);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 151561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBasic = void 0;
const Conversion = __importStar(__webpack_require__(152714));
const Evm = __importStar(__webpack_require__(149218));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * Handles encoding of basic types; yes the input type is broader than
 * it should be but it's hard to fix this without causing other problems,
 * sorry!
 * @Category Encoding (low-level)
 */
function encodeBasic(input) {
    let bytes;
    switch (input.type.typeClass) {
        case "userDefinedValueType":
            return encodeBasic(input.value);
        case "uint":
        case "int":
            return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);
        case "enum":
            return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);
        case "bool": {
            bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes
            if (input.value.asBoolean) {
                bytes[Evm.Utils.WORD_SIZE - 1] = 1;
            }
            return bytes;
        }
        case "bytes":
            switch (input.type.kind) {
                //deliberately not handling dynamic case!
                case "static":
                    bytes = Conversion.toBytes(input.value.asHex);
                    let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes
                    padded.set(bytes);
                    return padded;
            }
        case "address":
            return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);
        case "contract":
            return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);
        case "function": {
            switch (input.type.visibility) {
                //for our purposes here, we will NOT count internal functions as a
                //basic type!  so no handling of internal case
                case "external":
                    let coercedInput = input;
                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s
                    let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length
                    let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length
                    encoded.set(addressBytes);
                    encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address
                    return encoded;
            }
            break; //to satisfy TS
        }
        case "fixed":
        case "ufixed":
            let bigValue = (input).value.asBig;
            let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);
            return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);
    }
}
exports.encodeBasic = encodeBasic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 553928:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For decoding of primitives and constants
 *
 * @protected
 *
 * @packageDocumentation
 */
//Category: Common data location
//[NOT making this an actual category for now
//since there's nothing public in it]
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Allocate = exports.Encode = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(257939));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(151561));
exports.Encode = Encode;
const Allocate = __importStar(__webpack_require__(849107));
exports.Allocate = Allocate;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 59495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeString = exports.decodeBytes = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:bytes:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const errors_1 = __webpack_require__(672325);
const utf8_1 = __importDefault(__webpack_require__(957458));
function* decodeBytes(dataType, pointer, info, options = {}) {
    const { state } = info;
    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so OK
    let bytes;
    try {
        bytes = yield* read_1.default(pointer, state);
    }
    catch (error) {
        debug("segfault, pointer %o, state: %O", pointer, state);
        return errors_1.handleDecodingError(dataType, error, strict);
    }
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    //note: this function does not check padding
    switch (dataType.typeClass) {
        case "bytes":
            //we assume this is a dynamic bytestring!
            //static ones should go to decodeBasic!
            return {
                type: dataType,
                kind: "value",
                value: {
                    asHex: Conversion.toHexString(bytes)
                }
            };
        case "string":
            return {
                type: dataType,
                kind: "value",
                value: decodeString(bytes)
            };
    }
}
exports.decodeBytes = decodeBytes;
function decodeString(bytes) {
    //the following line takes our UTF-8 string... and interprets each byte
    //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.
    let badlyEncodedString = String.fromCharCode.apply(undefined, bytes);
    try {
        //this will throw an error if we have malformed UTF-8
        let correctlyEncodedString = utf8_1.default.decode(badlyEncodedString);
        //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding
        //here, because that handles malformed UTF-8 by means of replacement characters
        //(U+FFFD).  That loses information.  So we use the utf8 package instead,
        //and... well, see the catch block below.
        return {
            kind: "valid",
            asString: correctlyEncodedString
        };
    }
    catch (_a) {
        //we're going to ignore the precise error and just assume it's because
        //the string was malformed (what else could it be?)
        let hexString = Conversion.toHexString(bytes);
        return {
            kind: "malformed",
            asHex: hexString
        };
    }
}
exports.decodeString = decodeString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 553951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBytes = void 0;
const Conversion = __importStar(__webpack_require__(152714));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * Encodes without padding, length, etc!
 *
 * @Category Encoding (low-level)
 */
function encodeBytes(input) {
    switch (input.type.typeClass) {
        case "bytes":
            return Conversion.toBytes(input.value.asHex);
        case "string": {
            let coercedInput = (input);
            switch (coercedInput.value.kind) {
                case "valid":
                    return Conversion.stringToBytes(coercedInput.value.asString);
                case "malformed":
                    return Conversion.toBytes(coercedInput.value.asHex);
            }
        }
    }
}
exports.encodeBytes = encodeBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 767689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Contains functions for dealing with raw bytestrings
 * @protected
 *
 * @packageDocumentation
 */
//Category: Common data location
//[NOT making this an actual category for now
//since there's nothing public in it]
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Encode = exports.Decode = exports.Read = void 0;
const Read = __importStar(__webpack_require__(720281));
exports.Read = Read;
const Decode = __importStar(__webpack_require__(59495));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(553951));
exports.Encode = Encode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 720281:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readBytes = exports.readCode = void 0;
const Evm = __importStar(__webpack_require__(149218));
const errors_1 = __webpack_require__(672325);
function* readCode(pointer, state) {
    let code = state.code;
    if (!code) {
        code = yield {
            type: "code",
            address: Evm.Utils.toAddress(state.specials.this)
        };
    }
    return readBytes(pointer, Object.assign(Object.assign({}, state), { code }));
}
exports.readCode = readCode;
function readBytes(pointer, state) {
    let sourceBytes = state[pointer.location];
    const { start: offset, length } = pointer;
    if (!Number.isSafeInteger(offset + length)) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorBytes",
            location: pointer.location,
            start: offset,
            length
        });
    }
    // grab `length` bytes no matter what, here fill this array
    var bytes = new Uint8Array(length);
    bytes.fill(0); //fill it wil zeroes to start
    //if the start is beyond the end of the source, just return those 0s
    if (offset >= sourceBytes.length) {
        return bytes;
    }
    // if we're reading past the end of the source, truncate the length to read
    let excess = offset + length - sourceBytes.length;
    let readLength;
    if (excess > 0) {
        readLength = sourceBytes.length - offset;
    }
    else {
        readLength = length;
    }
    //get the (truncated) bytes
    let existing = new Uint8Array(sourceBytes.buffer, offset, readLength);
    //copy it into our buffer
    bytes.set(existing);
    return bytes;
}
exports.readBytes = readBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 299987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(299147), exports); //can't do 'export type *' :-/
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 299147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownUserDefinedTypeError = void 0;
/**
 * This error indicates that the decoder was unable to locate a user-defined
 * type (struct, enum, or contract type) via its ID.  Unfortunately, we can't
 * always avoid this at the moment; we're hoping to make this more robust in
 * the future with Truffle DB.  In the meantime, it is at least worth noting that
 * you should not encounter this error if your entire project was written in
 * Solidity and all compiled at once.  Sorry.
 *
 * @Category Errors
 */
class UnknownUserDefinedTypeError extends Error {
    constructor(id, typeString) {
        const message = `Cannot locate definition for ${typeString} (ID ${id})`;
        super(message);
        this.name = "UnknownUserDefinedTypeError";
        this.id = id;
        this.typeString = typeString;
    }
}
exports.UnknownUserDefinedTypeError = UnknownUserDefinedTypeError;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 89752:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
__exportStar(__webpack_require__(309612), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(372972));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 309612:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 372972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:compilations:utils");
const Ast = __importStar(__webpack_require__(114442));
const compile_common_1 = __webpack_require__(529833);
const Format = __importStar(__webpack_require__(429965));
const errors_1 = __webpack_require__(672325);
function shimCompilations(inputCompilations, shimmedCompilationIdPrefix = "shimmedcompilation") {
    return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));
}
exports.shimCompilations = shimCompilations;
function shimCompilation(inputCompilation, shimmedCompilationId = "shimmedcompilation") {
    return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {
        files: inputCompilation.sourceIndexes,
        sources: inputCompilation.sources,
        shimmedCompilationId,
        compiler: inputCompilation.compiler
    })), { compiler: inputCompilation.compiler });
}
exports.shimCompilation = shimCompilation;
/**
 * wrapper around shimContracts that just returns
 * the result in a one-element array (keeping the old name
 * shimArtifacts for compatibility)
 */
function shimArtifacts(artifacts, files, shimmedCompilationId = "shimmedcompilation") {
    return [shimContracts(artifacts, { files, shimmedCompilationId })];
}
exports.shimArtifacts = shimArtifacts;
/**
 * shims a bunch of contracts ("artifacts", though not necessarily)
 * to a compilation.  usually used via one of the above functions.
 * Note: if you pass in options.sources, options.files will be ignored.
 * Note: if you pass in options.sources, sources will not have
 * compiler set unless you also pass in options.compiler; in this case
 * you should set that up separately, as in shimCompilation().
 */
function shimContracts(artifacts, options = {}) {
    const { files, sources: inputSources } = options;
    const shimmedCompilationId = options.shimmedCompilationId || "shimmedcompilation";
    let contracts = [];
    let sources = [];
    let unreliableSourceOrder = false;
    for (let artifact of artifacts) {
        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources } = artifact;
        if (artifact.contract_name) {
            //just in case
            contractName = artifact.contract_name;
            //dunno what's up w/ the type of contract_name, but it needs coercing
        }
        debug("contractName: %s", contractName);
        let contractObject = {
            contractName,
            bytecode,
            sourceMap,
            deployedBytecode,
            deployedSourceMap,
            immutableReferences,
            abi,
            generatedSources: normalizeGeneratedSources(generatedSources, compiler),
            deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),
            compiler
        };
        let sourceObject = {
            sourcePath,
            source,
            ast: ast,
            compiler,
            language: inferLanguage(ast, compiler, sourcePath)
        };
        //ast needs to be coerced because schema doesn't quite match our types here...
        //if files or sources was passed, trust that to determine the source index
        //(assuming we have a sourcePath! currently it will be absent when dealing with
        //Solidity versions <0.4.9; presumably we will fix this if we ever properly
        //support versions that old, but for now this is necessary to get debug -x to work)
        if ((files || inputSources) && sourcePath) {
            //note: we never set the unreliableSourceOrder flag in this branch;
            //we just trust files/sources.  If this info is bad, then, uh, too bad.
            debug("inputSources: %O", inputSources);
            debug("files: %O", files);
            debug("sourcePath: %O", sourcePath);
            const index = inputSources
                ? inputSources.findIndex(source => source.sourcePath === sourcePath)
                : files.indexOf(sourcePath);
            if (!inputSources) {
                //if inputSources was passed, we'll handle this separately below
                sourceObject.id = index.toString(); //HACK
                sources[index] = sourceObject;
            }
            debug("files || inputSources; index: %d", index);
            contractObject.primarySourceId = index.toString(); //HACK
        }
        else {
            //if neither was passed, attempt to determine it from the ast
            let index;
            let needsAdding;
            if (sourceObject.ast) {
                //note: this works for both Solidity and Vyper
                index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons
            }
            else if (compiler && compiler.name === "vyper") {
                index = 0; //if it's Vyper but there's no AST, we can
                //assume that it was compiled alone and therefore has index 0
            }
            //if that didn't work, try the source map
            if (index === undefined && (sourceMap || deployedSourceMap)) {
                const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
                index = extractPrimarySource(sourceMapString);
            }
            //else leave undefined for now
            ({ index, needsAdding, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));
            if (needsAdding) {
                //if we're in this case, inputSources was not passed
                sourceObject.id = index.toString(); //HACK
                sources[index] = sourceObject;
                debug("else; index: %d", index);
            }
            //whether needed adding or not, set the source ID on the contract object
            contractObject.primarySourceId = index.toString(); //HACK
            debug("(no index unless mentioned)");
        }
        contracts.push(contractObject);
    }
    //now: check for id overlap with internal sources
    //(don't bother if inputSources or files was passed)
    if (!inputSources && !files) {
        for (let contract of contracts) {
            const { generatedSources, deployedGeneratedSources } = contract;
            for (let index in generatedSources) {
                if (index in sources) {
                    unreliableSourceOrder = true;
                }
            }
            for (let index in deployedGeneratedSources) {
                if (index in sources) {
                    unreliableSourceOrder = true;
                }
            }
        }
    }
    let compiler;
    if (options.compiler) {
        compiler = options.compiler;
    }
    else if (!unreliableSourceOrder && contracts.length > 0) {
        //if things were actually compiled together, we should just be able
        //to pick an arbitrary one
        compiler = contracts[0].compiler;
    }
    //if input sources was passed, set up the sources object directly :)
    if (inputSources) {
        sources = inputSources.map(({ sourcePath, contents: source, ast, language }, index) => ({
            sourcePath,
            source,
            ast: ast,
            language,
            id: index.toString(),
            compiler //redundant but let's include it
        }));
    }
    return {
        id: shimmedCompilationId,
        unreliableSourceOrder,
        sources,
        contracts,
        compiler
    };
}
exports.shimContracts = shimContracts;
//note: this works for Vyper too!
function sourceIndexForAst(ast) {
    if (Array.isArray(ast)) {
        //special handling for old Vyper versions
        ast = ast[0];
    }
    if (!ast) {
        return undefined;
    }
    return parseInt(ast.src.split(":")[2]);
    //src is given as start:length:file.
    //we want just the file.
}
function getContractNode(contract, compilation) {
    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;
    const { unreliableSourceOrder, sources } = compilation;
    let sourcesToCheck;
    //we will attempt to locate the primary source;
    //if we can't find it, we'll just check every source in this
    //compilation.
    if (primarySourceId !== undefined) {
        sourcesToCheck = [
            sources.find(source => source && source.id === primarySourceId)
        ];
    }
    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {
        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
        let sourceId = extractPrimarySource(sourceMapString);
        sourcesToCheck = [sources[sourceId]];
    }
    else {
        //WARNING: if we end up in this case, we could get the wrong contract!
        //(but we shouldn't end up here)
        sourcesToCheck = sources;
    }
    return sourcesToCheck.reduce((foundNode, source) => {
        if (foundNode || !source) {
            return foundNode;
        }
        if (!source.ast || source.language !== "Solidity") {
            //ignore non-Solidity ASTs for now, we don't support them yet
            return undefined;
        }
        return source.ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName);
    }, undefined);
}
exports.getContractNode = getContractNode;
/**
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 */
function extractPrimarySource(sourceMap) {
    if (!sourceMap) {
        //HACK?
        return 0; //in this case (e.g. a Vyper contract with an old-style
        //source map) we infer that it was compiled by itself
    }
    return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || "0");
}
function normalizeGeneratedSources(generatedSources, compiler) {
    if (!generatedSources) {
        return [];
    }
    if (!isGeneratedSources(generatedSources)) {
        return generatedSources; //if already normalizeed, leave alone
    }
    let sources = []; //output
    for (let source of generatedSources) {
        sources[source.id] = {
            id: source.id.toString(),
            sourcePath: source.name,
            source: source.contents,
            //ast needs to be coerced because schema doesn't quite match our types here...
            ast: source.ast,
            compiler: compiler,
            language: source.language
        };
    }
    return sources;
}
//HACK
function isGeneratedSources(sources) {
    //note: for some reason arr.includes(undefined) returns true on sparse arrays
    //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization
    return (sources.length > 0 &&
        !sources.includes(undefined) &&
        (sources[0].contents !== undefined ||
            sources[0].name !== undefined));
}
//HACK, maybe?
function inferLanguage(ast, compiler, sourcePath) {
    if (ast) {
        if (ast.nodeType === "SourceUnit") {
            return "Solidity";
        }
        else if (ast.nodeType && ast.nodeType.startsWith("Yul")) {
            //Every Yul source I've seen has YulBlock as the root, but
            //I'm not sure that that's *always* the case
            return "Yul";
        }
        else if (Array.isArray(ast) || ast.ast_type === "Module") {
            return "Vyper";
        }
    }
    else if (compiler) {
        if (compiler.name === "vyper") {
            return "Vyper";
        }
        else if (compiler.name === "solc") {
            //assuming sources compiled with solc without sourcePath are Solidity
            if (sourcePath && sourcePath.endsWith(".yul")) {
                return "Yul";
            }
            else {
                return "Solidity";
            }
        }
        else {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
function getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {
    //first: is this already there? only add it if it's not.
    //(we determine this by sourcePath if present, and the actual source
    //contents if not)
    debug("sourcePath: %s", sourceObject.sourcePath);
    debug("given index: %d", index);
    debug("sources: %o", sources.map(source => source.sourcePath));
    if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath ||
        (!sourceObject.sourcePath &&
            !existingSource.sourcePath &&
            existingSource.source !== sourceObject.source))) {
        if (unreliableSourceOrder || index === undefined || index in sources) {
            //if we can't add it at the correct spot, set the
            //unreliable source order flag
            debug("collision!");
            unreliableSourceOrder = true;
        }
        //otherwise, just leave things alone
        if (unreliableSourceOrder) {
            //in case of unreliable source order, we'll ignore what indices
            //things are *supposed* to have and just append things to the end
            index = sources.length;
        }
        return {
            index,
            needsAdding: true,
            unreliableSourceOrder
        };
    }
    else {
        //return index: null indicates don't add this because it's
        //already present
        debug("already present, not adding");
        return {
            index,
            needsAdding: false,
            unreliableSourceOrder
        };
    }
}
/**
 * convert Vyper source maps to solidity ones
 * (note we won't bother handling the case where the compressed
 * version doesn't exist; that will have to wait for a later version)
 */
function simpleShimSourceMap(sourceMap) {
    if (sourceMap === undefined) {
        return undefined; //undefined case
    }
    else if (typeof sourceMap === "object") {
        return sourceMap.pc_pos_map_compressed; //Vyper object case
    }
    else {
        try {
            return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case
        }
        catch (_) {
            return sourceMap; //Solidity case
        }
    }
}
exports.simpleShimSourceMap = simpleShimSourceMap;
/**
 * collects user defined types & tagged outputs for a given set of compilations,
 * returning both the definition nodes and (for the types) the type objects
 *
 * "Tagged outputs" means user-defined things that are output by a contract
 * (not input to a contract), and which are distinguished by (potentially
 * ambiguous) selectors.  So, events and custom errors are tagged outputs.
 * Function arguments are not tagged outputs (they're not outputs).
 * Return values are not tagged outputs (they don't have a selector).
 * Built-in errors (Error(string) and Panic(uint))... OK I guess those could
 * be considered tagged outputs, but we're only looking at user-defined ones
 * here.
 */
function collectUserDefinedTypesAndTaggedOutputs(compilations) {
    let references = {};
    let types = {};
    for (const compilation of compilations) {
        references[compilation.id] = {};
        types[compilation.id] = {
            compiler: compilation.compiler,
            types: {}
        };
        for (const source of compilation.sources) {
            if (!source) {
                continue; //remember, sources could be empty if shimmed!
            }
            const { ast, compiler, language } = source;
            if (language === "Solidity" && ast) {
                //don't check Yul or Vyper sources!
                for (const node of ast.nodes) {
                    if (node.nodeType === "StructDefinition" ||
                        node.nodeType === "EnumDefinition" ||
                        node.nodeType === "UserDefinedValueTypeDefinition" ||
                        node.nodeType === "ContractDefinition") {
                        references[compilation.id][node.id] = node;
                        //we don't have all the references yet, but we actually don't need them :)
                        const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);
                        types[compilation.id].types[dataType.id] = dataType;
                    }
                    else if (node.nodeType === "EventDefinition" ||
                        node.nodeType === "ErrorDefinition") {
                        references[compilation.id][node.id] = node;
                    }
                    if (node.nodeType === "ContractDefinition") {
                        for (const subNode of node.nodes) {
                            if (subNode.nodeType === "StructDefinition" ||
                                subNode.nodeType === "EnumDefinition" ||
                                subNode.nodeType === "UserDefinedValueTypeDefinition") {
                                references[compilation.id][subNode.id] = subNode;
                                //we don't have all the references yet, but we only need the
                                //reference to the defining contract, which we just added above!
                                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);
                                types[compilation.id].types[dataType.id] = dataType;
                            }
                            else if (subNode.nodeType === "EventDefinition" ||
                                subNode.nodeType === "ErrorDefinition") {
                                references[compilation.id][subNode.id] = subNode;
                            }
                        }
                    }
                }
            }
        }
    }
    return {
        definitions: references,
        typesByCompilation: types,
        types: Format.Types.forgetCompilations(types)
    };
}
exports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;
/**
 * Given a list of compilations, and an artifact appearing in one
 * of those compilations, finds the compilation and the corresponding
 * contract object
 * (these may be undefined if they can't be found)
 */
function findCompilationAndContract(compilations, artifact) {
    const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);
    const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);
    let firstNameMatch;
    let multipleNameMatches = false;
    for (const compilation of compilations) {
        for (const contract of compilation.contracts) {
            const nameMatches = contract.contractName ===
                (artifact.contractName || artifact.contract_name);
            if (nameMatches) {
                if (bytecode) {
                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {
                        return { compilation, contract };
                    }
                }
                else if (deployedBytecode) {
                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) ===
                        deployedBytecode) {
                        return { compilation, contract };
                    }
                }
                else if (!firstNameMatch) {
                    //if we have a name match, but no bytecode to go by, record this one.
                    //if it turns out to be the only one, we'll return it later.
                    firstNameMatch = { compilation, contract };
                }
                else if (!multipleNameMatches) {
                    //on the other hand, if there *is* an existing name match already,
                    //record that we've got multiple.
                    multipleNameMatches = true;
                }
            }
        }
    }
    //once the loop is done, if we haven't returned a bytecode match,
    //check if we've got a unique name match, and return it if so
    if (firstNameMatch && !multipleNameMatches) {
        return firstNameMatch;
    }
    //otherwise, if there's no bytecode match, and either no name match
    //or multiple name matches, just return a default fallback
    const defaultContract = {
        contractName: artifact.contractName || artifact.contract_name,
        abi: artifact.abi
    };
    const defaultCompilation = {
        id: "defaultCompilation",
        sources: [],
        contracts: [defaultContract]
    };
    return {
        compilation: defaultCompilation,
        contract: defaultContract
    };
}
exports.findCompilationAndContract = findCompilationAndContract;
function projectInfoIsCodecStyle(info) {
    return Boolean(info.compilations);
}
function projectInfoIsCommonStyle(info) {
    return Boolean(info.commonCompilations);
}
function projectInfoIsArtifacts(info) {
    return Boolean(info.artifacts);
}
function infoToCompilations(projectInfo) {
    if (!projectInfo) {
        throw new errors_1.NoProjectInfoError();
    }
    if (projectInfoIsCodecStyle(projectInfo)) {
        return projectInfo.compilations;
    }
    else if (projectInfoIsCommonStyle(projectInfo)) {
        return shimCompilations(projectInfo.commonCompilations);
    }
    else if (projectInfoIsArtifacts(projectInfo)) {
        return shimArtifacts(projectInfo.artifacts);
    }
}
exports.infoToCompilations = infoToCompilations;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 884159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
__exportStar(__webpack_require__(716041), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(919228));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 716041:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 919228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.solidityFamily = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:compiler:utils");
const semver_1 = __importDefault(__webpack_require__(266781));
function solidityFamily(compiler) {
    if (!compiler || compiler.name !== "solc") {
        return "unknown";
    }
    if (semver_1.default.satisfies(compiler.version, ">=0.8.9", {
        includePrerelease: true
    })) {
        return "0.8.9+";
    }
    else if (semver_1.default.satisfies(compiler.version, ">=0.8.7", {
        includePrerelease: true
    })) {
        return "0.8.7+";
    }
    else if (
    //see comment below about the weird-looking condition
    semver_1.default.satisfies(compiler.version, "~0.8 || >=0.8.0", {
        includePrerelease: true
    })) {
        return "0.8.x";
    }
    else if (semver_1.default.satisfies(compiler.version, "~0.5 || >=0.5.0", {
        includePrerelease: true
    })) {
        //what's with this weird-looking condition?  Well, I want to be sure to include
        //prerelease versions of 0.5.0.  But isn't that what the includePrerelease option
        //does?  No!  That just makes it so that prerelease versions can be included at
        //all; without that, all prereleases of *any* version of Solidity can be excluded.
        //A prerelease version of 0.5.0 still wouldn't satisfy >=0.5.0, so I added in ~0.5
        //as well, which they do satisfy.
        return "0.5.x";
    }
    else {
        return "pre-0.5.0";
    }
}
exports.solidityFamily = solidityFamily;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 560013:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeTypeId = exports.contextToType = void 0;
function contextToType(context) {
    if (context.contractId !== undefined) {
        return {
            typeClass: "contract",
            kind: "native",
            id: makeTypeId(context.contractId, context.compilationId),
            typeName: context.contractName,
            contractKind: context.contractKind,
            payable: context.payable
        };
    }
    else {
        return {
            typeClass: "contract",
            kind: "foreign",
            typeName: context.contractName,
            contractKind: context.contractKind,
            payable: context.payable
        };
    }
}
exports.contextToType = contextToType;
//NOTE: I am exporting this for use in other import functions, but please don't
//use this elsewhere!
//If you have to make a type ID, instead make the type and then
//take its ID.
function makeTypeId(astId, compilationId) {
    return `${compilationId}:${astId}`;
}
exports.makeTypeId = makeTypeId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 697938:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Import = void 0;
__exportStar(__webpack_require__(642986), exports); //'export type *' is not allowed
const Import = __importStar(__webpack_require__(560013));
exports.Import = Import;
const Utils = __importStar(__webpack_require__(381099));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 642986:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 381099:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeContext = exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:contexts:utils");
const Evm = __importStar(__webpack_require__(149218));
const Conversion = __importStar(__webpack_require__(152714));
const escapeRegExp_1 = __importDefault(__webpack_require__(392650));
const cbor = __importStar(__webpack_require__(82141));
const compile_common_1 = __webpack_require__(529833);
const Abi = __importStar(__webpack_require__(207651));
const AbiDataUtils = __importStar(__webpack_require__(785941));
function findContext(contexts, binary) {
    const matchingContexts = Object.values(contexts).filter(context => matchContext(context, binary));
    //rather than just pick an arbitrary matching context, we're going
    //to pick one that isn't a descendant of any of the others.
    //(if there are multiple of *those*, then yeah it's arbitrary.)
    const context = matchingContexts.find(descendant => !matchingContexts.some(ancestor => descendant.compilationId === ancestor.compilationId &&
        descendant.linearizedBaseContracts &&
        ancestor.contractId !== undefined &&
        descendant.linearizedBaseContracts
            .slice(1)
            .includes(ancestor.contractId)
    //we do slice one because everything is an an ancestor of itself; we only
    //care about *proper* ancestors
    ));
    return context || null;
}
exports.findContext = findContext;
function matchContext(context, givenBinary) {
    const { binary, compiler, isConstructor } = context;
    const lengthDifference = givenBinary.length - binary.length;
    //first: if it's not a constructor, and it's not Vyper,
    //they'd better be equal in length.
    //if it is a constructor, or is Vyper,
    //the given binary must be at least as long,
    //and the difference must be a multiple of 32 bytes (64 hex digits)
    const additionalAllowed = isConstructor || (compiler != undefined && compiler.name === "vyper");
    if ((!additionalAllowed && lengthDifference !== 0) ||
        lengthDifference < 0 ||
        lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {
        return false;
    }
    for (let i = 0; i < binary.length; i++) {
        //note: using strings like arrays is kind of dangerous in general in JS,
        //but everything here is ASCII so it's fine
        //note that we need to compare case-insensitive, since Solidity will
        //put addresses in checksum case in the compiled source
        //(we don't actually need that second toLowerCase(), but whatever)
        if (binary[i] !== "." &&
            binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {
            return false;
        }
    }
    return true;
}
exports.matchContext = matchContext;
function normalizeContexts(contexts) {
    //unfortunately, due to our current link references format, we can't
    //really use the binary from the artifact directly -- neither for purposes
    //of matching, nor for purposes of decoding internal functions.  So, we
    //need to perform this normalization step on our contexts before using
    //them.  Once we have truffle-db, this step should largely go away.
    debug("normalizing contexts");
    //first, let's clone the input
    //(let's do a 2-deep clone because we'll be altering binary & compiler)
    let newContexts = Object.assign({}, ...Object.entries(contexts).map(([contextHash, context]) => ({
        [contextHash]: Object.assign({}, context)
    })));
    debug("contexts cloned");
    //next, we get all the library names and sort them descending by length.
    //We're going to want to go in descending order of length so that we
    //don't run into problems when one name is a substring of another.
    //For simplicity, we'll exclude names of length <38, because we can
    //handle these with our more general check for link references at the end
    const fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;
    let names = Object.values(newContexts)
        .filter(context => context.contractKind === "library")
        .map(context => context.contractName)
        .filter(name => name.length >= fillerLength - 3)
        //the -3 is for 2 leading underscores and 1 trailing
        .sort((name1, name2) => name2.length - name1.length);
    debug("names sorted");
    //now, we need to turn all these names into regular expressions, because,
    //unfortunately, str.replace() will only replace all if you use a /g regexp;
    //note that because names may contain '$', we need to escape them
    //(also we prepend "__" because that's the placeholder format)
    let regexps = names.map(name => new RegExp(escapeRegExp_1.default("__" + name), "g"));
    debug("regexps prepared");
    //having done so, we can do the replace for these names!
    const replacement = ".".repeat(fillerLength);
    for (let regexp of regexps) {
        for (let context of Object.values(newContexts)) {
            context.binary = context.binary.replace(regexp, replacement);
        }
    }
    debug("long replacements complete");
    //now we can do a generic replace that will catch all names of length
    //<40, while also catching the Solidity compiler's link reference format
    //as well as Truffle's.  Hooray!
    const genericRegexp = new RegExp("_.{" + (fillerLength - 2) + "}_", "g");
    //we're constructing the regexp /_.{38}_/g, but I didn't want to use a
    //literal 38 :P
    for (let context of Object.values(newContexts)) {
        context.binary = context.binary.replace(genericRegexp, replacement);
    }
    debug("short replacements complete");
    //now we must handle the delegatecall guard -- libraries' deployedBytecode will include
    //0s in place of their own address instead of a link reference at the
    //beginning, so we need to account for that too
    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //"73"
    for (let context of Object.values(newContexts)) {
        if (context.contractKind === "library" && !context.isConstructor) {
            context.binary = context.binary.replace("0x" + pushAddressInstruction + "00".repeat(Evm.Utils.ADDRESS_SIZE), "0x" + pushAddressInstruction + replacement);
        }
    }
    debug("extra library replacements complete");
    //now let's handle immutable references
    //(these are much nicer than link references due to not having to deal with the old format)
    for (let context of Object.values(newContexts)) {
        if (context.immutableReferences) {
            for (let variable of Object.values(context.immutableReferences)) {
                for (let { start, length } of (variable)) {
                    //Goddammit TS
                    let lowerStringIndex = 2 + 2 * start;
                    let upperStringIndex = 2 + 2 * (start + length);
                    context.binary =
                        context.binary.slice(0, lowerStringIndex) +
                            "..".repeat(length) +
                            context.binary.slice(upperStringIndex);
                }
            }
        }
    }
    debug("immutables complete");
    //now: extract & decode all the cbor's.  we're going to use these for
    //two different purposes, so let's just get them all upfront.
    let cborInfos = {};
    let decodedCbors = {};
    //note: invalid cbor will be indicated in decodedCbors by the lack of an entry,
    //*not* by undefined or null, since there exists cbor for those :P
    for (const [contextHash, context] of Object.entries(newContexts)) {
        const cborInfo = extractCborInfo(context.binary);
        cborInfos[contextHash] = cborInfo;
        if (cborInfo) {
            try {
                //note this *will* throw if there's data left over,
                //which is what we want it to do
                const decoded = cbor.decodeFirstSync(cborInfo.cbor);
                decodedCbors[contextHash] = decoded;
            }
            catch (_a) {
                //just don't add it
            }
        }
    }
    debug("intial cbor processing complete");
    //now: if a context lacks a compiler, but a version can be found in the
    //cbor, add it.
    for (let [contextHash, context] of Object.entries(newContexts)) {
        if (!context.compiler && contextHash in decodedCbors) {
            context.compiler = detectCompilerInfo(decodedCbors[contextHash]);
        }
    }
    debug("versions complete");
    //one last step: where there's CBOR with a metadata hash, we'll allow the
    //CBOR to vary, aside from the length (note: ideally here we would *only*
    //dot-out the metadata hash part of the CBOR, but, well, it's not worth the
    //trouble to detect that; doing that could potentially get pretty involved)
    //note that if the code isn't Solidity, that's fine -- we just won't get
    //valid CBOR and will not end up adding to our list of regular expressions
    const externalCborInfos = Object.entries(cborInfos)
        .filter(([contextHash, _cborInfo]) => contextHash in decodedCbors &&
        isObjectWithHash(decodedCbors[contextHash]))
        .map(([_contextHash, cborInfo]) => cborInfo);
    const cborRegexps = externalCborInfos.map(cborInfo => ({
        input: new RegExp(cborInfo.cborSegment, "g"),
        output: "..".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex
    }));
    //HACK: we will replace *every* occurrence of *every* external CBOR occurring
    //in *every* context, in order to cover created contracts (including if there
    //are multiple or recursive ones)
    for (let context of Object.values(newContexts)) {
        for (let { input, output } of cborRegexps) {
            context.binary = context.binary.replace(input, output);
        }
    }
    debug("external wildcards complete");
    //finally, return this mess!
    return newContexts;
}
exports.normalizeContexts = normalizeContexts;
function extractCborInfo(binary) {
    debug("extracting cbor segement of %s", binary);
    const lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex
    //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract
    //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be
    //certain)
    if (lastTwoBytes.length < 2 * 2) {
        return null; //don't try to handle this case!
    }
    const cborLength = parseInt(lastTwoBytes, 16);
    const cborEnd = binary.length - 2 * 2;
    const cborStart = cborEnd - cborLength * 2;
    //sanity check
    if (cborStart < 2) {
        //"0x"
        return null; //don't try to handle this case!
    }
    const cbor = binary.slice(cborStart, cborEnd);
    return {
        cborStart,
        cborLength,
        cborEnd,
        cborLengthHex: lastTwoBytes,
        cbor,
        cborSegment: cbor + lastTwoBytes
    };
}
function isObjectWithHash(decoded) {
    if (typeof decoded !== "object" || decoded === null) {
        return false;
    }
    //cbor sometimes returns maps and sometimes objects,
    //so let's make things consistent by converting to a map
    //(actually, is this true? borc did this, I think cbor
    //does too, but I haven't checked recently)
    if (!(decoded instanceof Map)) {
        decoded = new Map(Object.entries(decoded));
    }
    const hashKeys = ["bzzr0", "bzzr1", "ipfs"];
    return hashKeys.some(key => decoded.has(key));
}
//returns undefined if no valid compiler info detected
//(if it detects solc but no version, it will not return
//a partial result, just undefined)
function detectCompilerInfo(decoded) {
    if (typeof decoded !== "object" || decoded === null) {
        return undefined;
    }
    //cbor sometimes returns maps and sometimes objects,
    //so let's make things consistent by converting to a map
    //(although see note above?)
    if (!(decoded instanceof Map)) {
        decoded = new Map(Object.entries(decoded));
    }
    if (!decoded.has("solc")) {
        //return undefined if the solc version field is not present
        //(this occurs if version <0.5.9)
        //currently no other language attaches cbor info, so, yeah
        return undefined;
    }
    const rawVersion = decoded.get("solc");
    if (typeof rawVersion === "string") {
        //for prerelease versions, the version is stored as a string.
        return {
            name: "solc",
            version: rawVersion
        };
    }
    else if (rawVersion instanceof Uint8Array && rawVersion.length === 3) {
        //for release versions, it's stored as a bytestring of length 3, with the
        //bytes being major, minor, patch. so we just join them with "." to form
        //a version string (although it's missing precise commit & etc).
        return {
            name: "solc",
            version: rawVersion.join(".")
        };
    }
    else {
        //return undefined on anything else
        return undefined;
    }
}
function makeContext(contract, node, compilation, isConstructor = false) {
    const abi = Abi.normalize(contract.abi);
    const bytecode = isConstructor
        ? contract.bytecode
        : contract.deployedBytecode;
    const binary = compile_common_1.Shims.NewToLegacy.forBytecode(bytecode);
    const hash = Conversion.toHexString(Evm.Utils.keccak256({
        type: "string",
        value: binary
    }));
    debug("hash: %s", hash);
    const fallback = abi.find(abiEntry => abiEntry.type === "fallback") ||
        null; //TS is failing at inference here
    const receive = abi.find(abiEntry => abiEntry.type === "receive") || null; //and here
    return {
        context: hash,
        contractName: contract.contractName,
        binary,
        contractId: node ? node.id : undefined,
        linearizedBaseContracts: node ? node.linearizedBaseContracts : undefined,
        contractKind: contractKind(contract, node),
        immutableReferences: isConstructor
            ? undefined
            : contract.immutableReferences,
        isConstructor,
        abi: AbiDataUtils.computeSelectors(abi),
        payable: AbiDataUtils.abiHasPayableFallback(abi),
        fallbackAbi: { fallback, receive },
        compiler: compilation.compiler || contract.compiler,
        compilationId: compilation.id
    };
}
exports.makeContext = makeContext;
//attempts to determine if the given contract is a library or not
function contractKind(contract, node) {
    //first: if we have a node, use its listed contract kind
    if (node) {
        return node.contractKind;
    }
    //next: check the contract kind field on the contract object itself, if it exists.
    //however this isn't implemented yet so we'll skip it.
    //next: if we have no direct info on the contract kind, but we do
    //have the deployed bytecode, we'll use a HACK:
    //we'll assume it's an ordinary contract, UNLESS its deployed bytecode begins with
    //PUSH20 followed by 20 0s, in which case we'll assume it's a library
    //(note: this will fail to detect libraries from before Solidity 0.4.20)
    if (contract.deployedBytecode) {
        const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
        const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //"73"
        const libraryString = "0x" + pushAddressInstruction + "00".repeat(Evm.Utils.ADDRESS_SIZE);
        return deployedBytecode.startsWith(libraryString) ? "library" : "contract";
    }
    //finally, in the absence of anything to go on, we'll assume it's an ordinary contract
    return "contract";
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 152714:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.stringToBytes = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.isBig = exports.toBN = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:conversion");
const bn_js_1 = __importDefault(__webpack_require__(213550));
const big_js_1 = __importDefault(__webpack_require__(107951));
const utf8_1 = __importDefault(__webpack_require__(957458));
/**
 * @param bytes - undefined | string | number | BN | Uint8Array | Big
 * @return {BN}
 */
function toBN(bytes) {
    if (bytes === undefined) {
        return undefined;
    }
    else if (typeof bytes === "string") {
        return new bn_js_1.default(bytes, 16);
    }
    else if (typeof bytes === "bigint") {
        return new bn_js_1.default(bytes.toString(16), 16);
    }
    else if (typeof bytes == "number" || bn_js_1.default.isBN(bytes)) {
        return new bn_js_1.default(bytes);
    }
    else if (isBig(bytes)) {
        return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!
        //note: going through string may seem silly but it's actually not terrible here,
        //since BN is binary-based and Big is decimal-based
        //[toFixed is like toString except it guarantees scientific notation is not used]
    }
    else if (typeof bytes.reduce === "function") {
        return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));
    }
}
exports.toBN = toBN;
//Big doesnt provide this function, so we'll make one ourselves
//HACK
function isBig(input) {
    return (typeof input === "object" &&
        input !== null &&
        (input.s === 1 || input.s === -1) &&
        typeof input.e === "number" &&
        Array.isArray(input.c) &&
        //we want to be sure this is *not* a BigNumber instead,
        //but we can't use isBigNumber here because we don't want
        //to import that library here, so, HACK, we'll check that
        //it lacks a particular BigNumber method that would be meaningless
        //for Bigs
        !input.isFinite);
    //(BigNumbers have this method because it supports Infinity and NaN,
    //but Big doesn't, so this method doesn't exist, because it would
    //be pointless)
}
exports.isBig = isBig;
/**
 * @param bytes - Uint8Array
 * @return {BN}
 */
function toSignedBN(bytes) {
    if (bytes[0] < 0x80) {
        // if first bit is 0
        return toBN(bytes);
    }
    else {
        return toBN(bytes.map(b => 0xff - b))
            .addn(1)
            .neg();
    }
}
exports.toSignedBN = toSignedBN;
function toBigInt(value) {
    //BN is binary-based, so we convert by means of a hex string in order
    //to avoid having to do a binary-decimal conversion and back :P
    return !value.isNeg()
        ? BigInt("0x" + value.toString(16))
        : -BigInt("0x" + value.neg().toString(16)); //can't directly make negative BigInt from hex string
}
exports.toBigInt = toBigInt;
function toBig(value) {
    //note: going through string may seem silly but it's actually not terrible here,
    //since BN (& number) is binary-based and Big is decimal-based
    return new big_js_1.default(value.toString());
}
exports.toBig = toBig;
/**
 * @param bytes - Uint8Array | BN | bigint
 * @param padLength - number - minimum desired byte length (left-pad with zeroes)
 * @param padRight - boolean - causes padding to occur on right instead of left
 * @return {string}
 */
function toHexString(bytes, padLength = 0, padRight = false) {
    if (bn_js_1.default.isBN(bytes) ||
        typeof bytes === "bigint" ||
        typeof bytes === "number" ||
        isBig(bytes)) {
        bytes = toBytes(bytes);
    }
    const pad = (s) => `${"00".slice(0, 2 - s.length)}${s}`;
    //                                          0  1  2  3  4
    //                                 0  1  2  3  4  5  6  7
    // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
    // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
    //                                `--.---'
    //                                     offset 3
    if (bytes.length < padLength) {
        let prior = bytes;
        bytes = new Uint8Array(padLength);
        if (padRight) {
            //unusual case: pad on right
            bytes.set(prior);
        }
        else {
            //usual case
            bytes.set(prior, padLength - prior.length);
        }
    }
    debug("bytes: %o", bytes);
    let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, "");
    return `0x${string}`;
}
exports.toHexString = toHexString;
function toBytes(data, length = 0) {
    //note that length is a minimum output length
    //strings will be 0-padded on left
    //numbers/BNs will be sign-padded on left
    //NOTE: if a number/BN is passed in that is too big for the given length,
    //you will get an error!
    //(note that strings passed in should be hex strings; this is not for converting
    //generic strings to hex)
    if (typeof data === "bigint") {
        data = data.toString(16);
    }
    if (typeof data === "string") {
        let hex = data; //renaming for clarity
        if (hex.startsWith("0x")) {
            hex = hex.slice(2);
        }
        if (hex === "") {
            //this special case is necessary because the match below will return null,
            //not an empty array, when given an empty string
            return new Uint8Array(0);
        }
        if (hex.length % 2 == 1) {
            hex = `0${hex}`;
        }
        let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
        if (bytes.length < length) {
            let prior = bytes;
            bytes = new Uint8Array(length);
            bytes.set(prior, length - prior.length);
        }
        return bytes;
    }
    else {
        // BN/Big/number case
        if (typeof data === "number") {
            data = new bn_js_1.default(data);
        }
        else if (isBig(data)) {
            //note: going through string may seem silly but it's actually not terrible here,
            //since BN is binary-based and Big is decimal-based
            data = new bn_js_1.default(data.toFixed());
            //[toFixed is like toString except it guarantees scientific notation is not used]
        }
        //note that the argument for toTwos is given in bits
        return data.toTwos(length * 8).toArrayLike(Uint8Array, "be", length);
        //big-endian
    }
}
exports.toBytes = toBytes;
function stringToBytes(input) {
    input = utf8_1.default.encode(input);
    let bytes = new Uint8Array(input.length);
    for (let i = 0; i < input.length; i++) {
        bytes[i] = input.charCodeAt(i);
    }
    return bytes;
    //NOTE: this will throw an error if the string contained malformed UTF-16!
    //but, well, it shouldn't contain that...
}
exports.stringToBytes = stringToBytes;
//computes value * 10**decimalPlaces
function shiftBigUp(value, decimalPlaces) {
    let newValue = new big_js_1.default(value);
    newValue.e += decimalPlaces;
    return newValue;
}
exports.shiftBigUp = shiftBigUp;
//computes value * 10**-decimalPlaces
function shiftBigDown(value, decimalPlaces) {
    let newValue = new big_js_1.default(value);
    newValue.e -= decimalPlaces;
    return newValue;
}
exports.shiftBigDown = shiftBigDown;
function countDecimalPlaces(value) {
    return Math.max(0, value.c.length - value.e - 1);
}
exports.countDecimalPlaces = countDecimalPlaces;
//converts out of range booleans to true; something of a HACK
//NOTE: does NOT do this recursively inside structs, arrays, etc!
//I mean, those aren't elementary and therefore aren't in the domain
//anyway, but still
function cleanBool(result) {
    switch (result.kind) {
        case "value":
            return result;
        case "error":
            switch (result.error.kind) {
                case "BoolOutOfRangeError":
                    //return true
                    return {
                        type: result.type,
                        kind: "value",
                        value: {
                            asBoolean: true
                        }
                    };
                default:
                    return result;
            }
    }
}
exports.cleanBool = cleanBool;
//# sourceMappingURL=conversion.js.map

/***/ }),

/***/ 632561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:core");
const Ast = __importStar(__webpack_require__(114442));
const AbiData = __importStar(__webpack_require__(20907));
const Topic = __importStar(__webpack_require__(963196));
const Evm = __importStar(__webpack_require__(149218));
const Contexts = __importStar(__webpack_require__(697938));
const abify_1 = __webpack_require__(57320);
const Conversion = __importStar(__webpack_require__(152714));
const errors_1 = __webpack_require__(672325);
const read_1 = __importDefault(__webpack_require__(887534));
const decode_1 = __importDefault(__webpack_require__(237478));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
/**
 * @Category Decoding
 */
function* decodeVariable(definition, pointer, info, compilationId) {
    let compiler = info.currentContext.compiler;
    let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
    return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset
}
exports.decodeVariable = decodeVariable;
/**
 * @Category Decoding
 */
function* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have
) {
    const context = info.currentContext;
    if (context === null) {
        //if we don't know the contract ID, we can't decode
        if (isConstructor) {
            return {
                kind: "create",
                decodingMode: "full",
                bytecode: Conversion.toHexString(info.state.calldata)
            };
        }
        else {
            return {
                kind: "unknown",
                decodingMode: "full",
                data: Conversion.toHexString(info.state.calldata)
            };
        }
    }
    const contextHash = context.context;
    const contractType = Contexts.Import.contextToType(context);
    isConstructor = context.isConstructor;
    const allocations = info.allocations.calldata;
    let allocation;
    let selector;
    //first: is this a creation call?
    if (isConstructor) {
        allocation = (allocations.constructorAllocations[contextHash] || { input: undefined }).input;
    }
    else {
        //skipping any error-handling on this read, as a calldata read can't throw anyway
        let rawSelector = yield* read_1.default({
            location: "calldata",
            start: 0,
            length: Evm.Utils.SELECTOR_SIZE
        }, info.state);
        selector = Conversion.toHexString(rawSelector);
        allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {
            input: undefined
        }).input;
    }
    if (allocation === undefined) {
        let abiEntry = null;
        if (info.state.calldata.length === 0) {
            //to hell with reads, let's just be direct
            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;
        }
        else {
            abiEntry = context.fallbackAbi.fallback;
        }
        return {
            kind: "message",
            class: contractType,
            abi: abiEntry,
            data: Conversion.toHexString(info.state.calldata),
            decodingMode: "full"
        };
    }
    let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary
    debug("calldata decoding mode: %s", decodingMode);
    //you can't map with a generator, so we have to do this map manually
    let decodedArguments = [];
    for (const argumentAllocation of allocation.arguments) {
        let value;
        let dataType = decodingMode === "full"
            ? argumentAllocation.type
            : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);
        try {
            value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {
                abiPointerBase: allocation.offset,
                allowRetry: decodingMode === "full"
            });
        }
        catch (error) {
            if (error instanceof errors_1.StopDecodingError &&
                error.allowRetry &&
                decodingMode === "full") {
                debug("problem! retrying as ABI");
                debug("error: %O", error);
                //if a retry happens, we've got to do several things in order to switch to ABI mode:
                //1. mark that we're switching to ABI mode;
                decodingMode = "abi";
                //2. abify all previously decoded values;
                decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));
                //3. retry this particular decode in ABI mode.
                //(no try/catch on this one because we can't actually handle errors here!
                //not that they should be occurring)
                value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                argumentAllocation.pointer, info, {
                    abiPointerBase: allocation.offset
                });
                //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                //so we don't need to do anything special there.
            }
            else {
                //we shouldn't be getting other exceptions, but if we do, we don't know
                //how to handle them, so uhhhh just rethrow I guess??
                throw error;
            }
        }
        const name = argumentAllocation.name;
        decodedArguments.push(name //deliberate general falsiness test
            ? { name, value }
            : { value });
    }
    if (isConstructor) {
        return {
            kind: "constructor",
            class: contractType,
            arguments: decodedArguments,
            abi: allocation.abi,
            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),
            decodingMode
        };
    }
    else {
        return {
            kind: "function",
            class: contractType,
            abi: allocation.abi,
            arguments: decodedArguments,
            selector,
            decodingMode
        };
    }
}
exports.decodeCalldata = decodeCalldata;
/**
 * @Category Decoding
 */
function* decodeEvent(info, address, //if null is passed, must pass currentContext in info
options = {}) {
    const allocations = info.allocations.event;
    const extras = options.extras || "off";
    let rawSelector;
    let selector;
    let contractAllocations; //for non-anonymous events
    let libraryAllocations; //similar
    let contractAnonymousAllocations;
    let libraryAnonymousAllocations;
    const topicsCount = info.state.eventtopics.length;
    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?
    if (allocations[topicsCount]) {
        if (topicsCount > 0) {
            rawSelector = yield* read_1.default({
                location: "eventtopic",
                topic: 0
            }, info.state);
            selector = Conversion.toHexString(rawSelector);
            if (allocations[topicsCount].bySelector[selector]) {
                ({ contract: contractAllocations, library: libraryAllocations } =
                    allocations[topicsCount].bySelector[selector]);
            }
            else {
                debug("no allocations for that selector!");
                contractAllocations = {};
                libraryAllocations = {};
            }
        }
        else {
            //if we don't have a selector, it means we don't have any non-anonymous events
            contractAllocations = {};
            libraryAllocations = {};
        }
        //now: let's get our allocations for anonymous events
        ({
            contract: contractAnonymousAllocations,
            library: libraryAnonymousAllocations
        } = allocations[topicsCount].anonymous);
    }
    else {
        //if there's not even an allocation for the topics count, we can't
        //decode; we could do this the honest way of setting all four allocation
        //objects to {}, but let's just short circuit
        debug("no allocations for that topic count!");
        return [];
    }
    let contractContext;
    if (address !== null) {
        //now: what contract are we (probably) dealing with? let's get its code to find out
        const codeBytes = yield {
            type: "code",
            address
        };
        const codeAsHex = Conversion.toHexString(codeBytes);
        contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);
    }
    else {
        contractContext = info.currentContext;
    }
    let possibleContractAllocations; //excludes anonymous events
    let possibleContractAnonymousAllocations;
    let possibleExtraAllocations; //excludes anonymous events
    let possibleExtraAnonymousAllocations;
    const emittingContextHash = (contractContext || { context: undefined })
        .context;
    if (emittingContextHash) {
        //if we found the contract, maybe it's from that contract
        const contractAllocation = contractAllocations[emittingContextHash];
        const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];
        possibleContractAllocations = contractAllocation || [];
        possibleContractAnonymousAllocations = contractAnonymousAllocation || [];
        //also, we need to set up the extras (everything that's from a
        //non-library contract but *not* this one)
        possibleExtraAllocations = [].concat(...Object.entries(contractAllocations)
            .filter(([key, _]) => key !== emittingContextHash)
            .map(([_, value]) => value));
        possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations)
            .filter(([key, _]) => key !== emittingContextHash)
            .map(([_, value]) => value));
    }
    else {
        //if we couldn't determine the contract, well, we have to assume it's from a library
        debug("couldn't find context");
        possibleContractAllocations = [];
        possibleContractAnonymousAllocations = [];
        //or it's an extra, which could be any of the contracts
        possibleExtraAllocations = [].concat(...Object.values(contractAllocations));
        possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));
    }
    //now we get all the library allocations!
    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));
    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));
    //now we put it all together!
    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);
    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);
    const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations);
    //...and also there's the extras
    const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);
    const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras
    possibleExtraAllocationsTotal);
    //whew!
    let decodings = [];
    allocationAttempts: for (const allocation of possibleAllocationsTotal) {
        debug("trying allocation: %O", allocation);
        //first: check for our sentinel value for extras (yeah, kind of HACKy)
        if (allocation === null) {
            switch (extras) {
                case "on":
                    continue allocationAttempts; //ignore the sentinel and continue
                case "off":
                    break allocationAttempts; //don't include extras; stop here
                case "necessary":
                    //stop on the sentinel and exclude extras *unless* there are no decodings yet
                    if (decodings.length > 0) {
                        break allocationAttempts;
                    }
                    else {
                        continue allocationAttempts;
                    }
            }
        }
        //second: do a name check so we can skip decoding if name is wrong
        //(this will likely be a more detailed check in the future)
        if (options.name !== undefined && allocation.abi.name !== options.name) {
            continue;
        }
        //now: the main part!
        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary
        const contextHash = allocation.contextHash;
        const attemptContext = info.contexts[contextHash];
        const emittingContractType = Contexts.Import.contextToType(attemptContext);
        const contractType = allocation.definedIn;
        //you can't map with a generator, so we have to do this map manually
        let decodedArguments = [];
        for (const argumentAllocation of allocation.arguments) {
            let value;
            //if in full mode, use the allocation's listed data type.
            //if in ABI mode, abify it before use.
            let dataType = decodingMode === "full"
                ? argumentAllocation.type
                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);
            try {
                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {
                    strictAbiMode: true,
                    allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity
                });
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError &&
                    error.allowRetry &&
                    decodingMode === "full") {
                    //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;
                    decodingMode = "abi";
                    //2. abify all previously decoded values;
                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));
                    //3. retry this particular decode in ABI mode.
                    try {
                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect
                        });
                    }
                    catch (_) {
                        //if an error occurred on the retry, this isn't a valid decoding!
                        debug("rejected due to exception on retry");
                        continue allocationAttempts;
                    }
                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                    //so we don't need to do anything special there.
                }
                else {
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", error);
                    continue allocationAttempts;
                }
            }
            const name = argumentAllocation.name;
            const indexed = argumentAllocation.pointer.location === "eventtopic";
            decodedArguments.push(name //deliberate general falsiness test
                ? { name, indexed, value }
                : { indexed, value });
        }
        if (!options.disableChecks) {
            //OK, so, having decoded the result, the question is: does it reencode to the original?
            //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )
            //first, we have to filter out the indexed arguments, and also get rid of the name information
            const nonIndexedValues = decodedArguments
                .filter(argument => !argument.indexed)
                .map(argument => argument.value);
            //now, we can encode!
            const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);
            const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well
            //are they equal?
            if (!Evm.Utils.equalData(reEncodedData, encodedData)) {
                //if not, this allocation doesn't work
                debug("rejected due to [non-indexed] mismatch");
                continue;
            }
        }
        //one last check -- let's check that the indexed arguments match up, too
        //(we won't skip this even if disableChecks was passed)
        const indexedValues = decodedArguments
            .filter(argument => argument.indexed)
            .map(argument => argument.value);
        const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);
        const encodedTopics = info.state.eventtopics;
        //now: do *these* match?
        const selectorAdjustment = allocation.anonymous ? 0 : 1;
        for (let i = 0; i < reEncodedTopics.length; i++) {
            if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {
                debug("rejected due to indexed mismatch");
                continue allocationAttempts;
            }
        }
        //if we've made it here, the allocation works!  hooray!
        debug("allocation accepted!");
        let decoding;
        if (allocation.abi.anonymous) {
            decoding = {
                kind: "anonymous",
                definedIn: contractType,
                class: emittingContractType,
                abi: allocation.abi,
                arguments: decodedArguments,
                decodingMode
            };
        }
        else {
            decoding = {
                kind: "event",
                definedIn: contractType,
                class: emittingContractType,
                abi: allocation.abi,
                arguments: decodedArguments,
                selector,
                decodingMode
            };
        }
        decodings.push(decoding);
        //if we've made this far (so this allocation works), and we were passed an
        //ID, and it matches this ID, bail out & return this as the *only* decoding
        if (options.id && allocation.id === options.id) {
            return [decoding];
        }
    }
    return decodings;
}
exports.decodeEvent = decodeEvent;
const errorSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({
    type: "string",
    value: "Error(string)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
const panicSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({
    type: "string",
    value: "Panic(uint256)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
const defaultRevertAllocations = [
    {
        kind: "revert",
        allocationMode: "full",
        selector: errorSelector,
        abi: {
            name: "Error",
            type: "error",
            inputs: [
                {
                    name: "",
                    type: "string",
                    internalType: "string"
                }
            ]
        },
        definedIn: null,
        arguments: [
            {
                name: "",
                pointer: {
                    location: "returndata",
                    start: errorSelector.length,
                    length: Evm.Utils.WORD_SIZE
                },
                type: {
                    typeClass: "string",
                    typeHint: "string"
                }
            }
        ]
    },
    {
        kind: "revert",
        allocationMode: "full",
        selector: panicSelector,
        abi: {
            name: "Panic",
            type: "error",
            inputs: [
                {
                    name: "",
                    type: "uint256",
                    internalType: "uint256"
                }
            ]
        },
        definedIn: null,
        arguments: [
            {
                name: "",
                pointer: {
                    location: "returndata",
                    start: panicSelector.length,
                    length: Evm.Utils.WORD_SIZE
                },
                type: {
                    typeClass: "uint",
                    bits: Evm.Utils.WORD_SIZE * 8,
                    typeHint: "uint256"
                }
            }
        ]
    }
];
const defaultEmptyAllocations = [
    {
        kind: "failure",
        allocationMode: "full",
        selector: new Uint8Array(),
        arguments: []
    },
    {
        kind: "selfdestruct",
        allocationMode: "full",
        selector: new Uint8Array(),
        arguments: []
    }
];
/**
 * If there are multiple possibilities, they're always returned in
 * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode
 * Moreover, within "revert", builtin ones are put above custom ones
 * @Category Decoding
 */
function* decodeReturndata(info, successAllocation, //null here must be explicit
status, //you can pass this to indicate that you know the status,
id //useful when status = false
) {
    let possibleAllocations;
    const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));
    const contextHash = (info.currentContext || { context: "" }).context; //HACK: "" is used to represent no context
    const customRevertAllocations = ((info.allocations.returndata || { [contextHash]: {} })[contextHash] || {
        [selector]: []
    })[selector] || [];
    if (successAllocation === null) {
        possibleAllocations = [
            ...defaultRevertAllocations,
            ...customRevertAllocations,
            ...defaultEmptyAllocations
        ];
    }
    else {
        switch (successAllocation.kind) {
            case "return":
                possibleAllocations = [
                    successAllocation,
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    ...defaultEmptyAllocations
                ];
                break;
            case "bytecode":
                possibleAllocations = [
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    ...defaultEmptyAllocations,
                    successAllocation
                ];
                break;
            case "returnmessage":
                possibleAllocations = [
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    successAllocation,
                    ...defaultEmptyAllocations
                ];
                break;
            //Other cases shouldn't happen so I'm leaving them to cause errors!
        }
    }
    let decodings = [];
    allocationAttempts: for (const allocation of possibleAllocations) {
        debug("trying allocation: %O", allocation);
        //before we attempt to use this allocation, we check: does the selector match?
        let encodedData = info.state.returndata; //again, not great to read this directly, but oh well
        const encodedPrefix = encodedData.subarray(0, allocation.selector.length);
        if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {
            continue;
        }
        encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later
        //also we check, does the status match?
        if (status !== undefined) {
            const successKinds = [
                "return",
                "selfdestruct",
                "bytecode",
                "returnmessage"
            ];
            const failKinds = ["failure", "revert"];
            if (status) {
                if (!successKinds.includes(allocation.kind)) {
                    continue;
                }
            }
            else {
                if (!failKinds.includes(allocation.kind)) {
                    continue;
                }
            }
        }
        if (allocation.kind === "bytecode") {
            //bytecode is special and can't really be integrated with the other cases.
            //so it gets its own function.
            const decoding = yield* decodeBytecode(info);
            if (decoding) {
                decodings.push(decoding);
            }
            continue;
        }
        if (allocation.kind === "returnmessage") {
            //this kind is also special, though thankfully it's easier
            const decoding = {
                kind: "returnmessage",
                status: true,
                data: Conversion.toHexString(info.state.returndata),
                decodingMode: allocation.allocationMode
            };
            decodings.push(decoding);
            continue;
        }
        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary
        //you can't map with a generator, so we have to do this map manually
        let decodedArguments = [];
        for (const argumentAllocation of allocation.arguments) {
            let value;
            //if in full mode, use the allocation's listed data type.
            //if in ABI mode, abify it before use.
            let dataType = decodingMode === "full"
                ? argumentAllocation.type
                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);
            //now, let's decode!
            try {
                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {
                    abiPointerBase: allocation.selector.length,
                    strictAbiMode: true,
                    allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity
                });
                debug("value on first try: %O", value);
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError &&
                    error.allowRetry &&
                    decodingMode === "full") {
                    debug("retry!");
                    //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;
                    decodingMode = "abi";
                    //2. abify all previously decoded values;
                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));
                    //3. retry this particular decode in ABI mode.
                    try {
                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            abiPointerBase: allocation.selector.length,
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect
                        });
                        debug("value on retry: %O", value);
                    }
                    catch (_) {
                        //if an error occurred on the retry, this isn't a valid decoding!
                        debug("rejected due to exception on retry");
                        continue allocationAttempts;
                    }
                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                    //so we don't need to do anything special there.
                }
                else {
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", error);
                    continue allocationAttempts;
                }
            }
            const name = argumentAllocation.name;
            decodedArguments.push(name //deliberate general falsiness test
                ? { name, value }
                : { value });
        }
        //OK, so, having decoded the result, the question is: does it reencode to the original?
        //first, we have to filter out the indexed arguments, and also get rid of the name information
        debug("decodedArguments: %O", decodedArguments);
        const decodedArgumentValues = decodedArguments.map(argument => argument.value);
        const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);
        //are they equal? note the selector has been stripped off encodedData!
        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {
            //if not, this allocation doesn't work
            debug("rejected due to mismatch");
            continue;
        }
        //if we've made it here, the allocation works!  hooray!
        debug("allocation accepted!");
        let decoding;
        switch (allocation.kind) {
            case "return":
                decoding = {
                    kind: "return",
                    status: true,
                    arguments: decodedArguments,
                    decodingMode
                };
                break;
            case "revert":
                decoding = {
                    kind: "revert",
                    abi: allocation.abi,
                    definedIn: allocation.definedIn,
                    status: false,
                    arguments: decodedArguments,
                    decodingMode
                };
                break;
            case "selfdestruct":
                decoding = {
                    kind: "selfdestruct",
                    status: true,
                    decodingMode
                };
                break;
            case "failure":
                decoding = {
                    kind: "failure",
                    status: false,
                    decodingMode
                };
                break;
        }
        decodings.push(decoding);
        //if we've made this far (so this allocation works), and we were passed an
        //ID, and it matches this ID, bail out & return this as the *only* decoding
        if (id && allocation.kind === "revert" && allocation.id === id) {
            return [decoding];
        }
    }
    return decodings;
}
exports.decodeReturndata = decodeReturndata;
//note: requires the bytecode to be in returndata, not code
function* decodeBytecode(info) {
    let decodingMode = "full"; //as always, degrade as necessary
    const bytecode = Conversion.toHexString(info.state.returndata);
    const context = Contexts.Utils.findContext(info.contexts, bytecode);
    if (!context) {
        return {
            kind: "unknownbytecode",
            status: true,
            decodingMode: "full",
            bytecode
        };
    }
    const contractType = Contexts.Import.contextToType(context);
    //now: ignore original allocation (which we didn't even pass :) )
    //and lookup allocation by context
    const allocation = info.allocations.calldata.constructorAllocations[context.context].output;
    debug("bytecode allocation: %O", allocation);
    //now: add immutables if applicable
    let immutables;
    if (allocation.immutables) {
        immutables = [];
        //NOTE: if we're in here, we can assume decodingMode === "full"
        for (const variable of allocation.immutables) {
            const dataType = variable.type; //we don't conditioning on decodingMode here because we know it
            let value;
            try {
                value = yield* decode_1.default(dataType, variable.pointer, info, {
                    allowRetry: true,
                    strictAbiMode: true,
                    paddingMode: "defaultOrZero"
                });
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError && error.allowRetry) {
                    //we "retry" by... not bothering with immutables :P
                    //(but we do set the mode to ABI)
                    decodingMode = "abi";
                    immutables = undefined;
                    break;
                }
                else {
                    //otherwise, this isn't a valid decoding I guess
                    return null;
                }
            }
            immutables.push({
                name: variable.name,
                class: variable.definedIn,
                value
            });
        }
    }
    let decoding = {
        kind: "bytecode",
        status: true,
        decodingMode,
        bytecode,
        immutables,
        class: contractType
    };
    //finally: add address if applicable
    if (allocation.delegatecallGuard) {
        decoding.address = web3_utils_1.default.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = "0x73".length
        );
    }
    return decoding;
}
/**
 * Decodes the return data from a failed call.
 *
 * @param returndata The returned data, as a Uint8Array.
 * @return An array of possible decodings.  At the moment it's
 *   impossible for there to be more than one.  (If the call didn't actually
 *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)
 *
 *   Decodings can either be decodings of revert messages, or decodings
 *   indicating that there was no revert message.  If somehow both were to be
 *   possible, they'd go in that order, although as mentioned, there (at least
 *   currently) isn't any way for that to occur.
 * @Category Decoding convenience
 */
function decodeRevert(returndata) {
    //coercing because TS doesn't know it'll finish in one go
    return decodeReturndata({
        allocations: {},
        state: {
            storage: {},
            returndata
        }
    }, null, false).next().value;
}
exports.decodeRevert = decodeRevert;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 237478:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:decode");
const AstConstant = __importStar(__webpack_require__(488132));
const AbiData = __importStar(__webpack_require__(20907));
const Compiler = __importStar(__webpack_require__(884159));
const Format = __importStar(__webpack_require__(429965));
const Basic = __importStar(__webpack_require__(553928));
const Memory = __importStar(__webpack_require__(635035));
const Special = __importStar(__webpack_require__(97859));
const Stack = __importStar(__webpack_require__(915385));
const Storage = __importStar(__webpack_require__(781037));
const Topic = __importStar(__webpack_require__(963196));
function* decode(dataType, pointer, info, options = {}) {
    return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));
}
exports["default"] = decode;
function* decodeDispatch(dataType, pointer, info, options = {}) {
    debug("type %O", dataType);
    debug("pointer %O", pointer);
    switch (pointer.location) {
        case "storage":
            return yield* Storage.Decode.decodeStorage(dataType, pointer, info);
        case "stack":
            return yield* Stack.Decode.decodeStack(dataType, pointer, info);
        case "stackliteral":
            return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);
        case "definition":
            return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);
        case "special":
            return yield* Special.Decode.decodeSpecial(dataType, pointer, info);
        case "calldata":
        case "eventdata":
        case "returndata":
            return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);
        case "eventtopic":
            return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);
        case "code":
        case "nowhere":
            //currently only basic types can go in code, so we'll dispatch directly to decodeBasic
            //(if it's a nowhere pointer, this will return an error result, of course)
            //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,
            //so we have to set the padding mode appropriately to allow for this)
            return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: "defaultOrZero" }));
        case "memory":
            //this case -- decoding something that resides *directly* in memory,
            //rather than located via a pointer -- only comes up when decoding immutables
            //in a constructor.  thus, we turn on the forceRightPadding option on Solidity
            //versions prior to 0.8.9, because before then all immutables would be right-padded
            //while in memory
            switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {
                case "0.5.x":
                case "0.8.x":
                case "0.8.7+":
                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: "right" }));
                default:
                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);
            }
    }
}
//# sourceMappingURL=decode.js.map

/***/ }),

/***/ 672325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoProjectInfoError = exports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;
const Format = __importStar(__webpack_require__(429965));
//For when we need to throw an error, here's a wrapper class that extends Error.
//Apologies about the confusing name, but I wanted something that would make
//sense should it not be caught and thus accidentally exposed to the outside.
/**
 * @hidden
 */
class DecodingError extends Error {
    constructor(error) {
        super(Format.Utils.Exception.message(error));
        this.error = error;
        this.name = "DecodingError";
    }
}
exports.DecodingError = DecodingError;
//used to stop decoding; like DecodingError, but used in contexts
//where I don't expect it to be caught
//NOTE: currently we don't actually check the type of a thrown error,
//we just rely on context.  still, I think it makes sense to be a separate
//type.
/**
 * @hidden
 */
class StopDecodingError extends Error {
    //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in
    //ABI mode, we give up.)
    constructor(error, allowRetry) {
        const message = `Stopping decoding: ${error.kind}`; //sorry about the bare-bones message,
        //but again, users shouldn't actually see this, so I think this should suffice for now
        super(message);
        this.error = error;
        this.allowRetry = Boolean(allowRetry);
    }
}
exports.StopDecodingError = StopDecodingError;
/**
 * @hidden
 */
function handleDecodingError(dataType, error, strict = false) {
    if (error instanceof DecodingError) {
        //expected error
        if (strict) {
            //strict mode -- stop decoding on errors
            throw new StopDecodingError(error.error);
        }
        else {
            //nonstrict mode -- return an error result
            return {
                //I don't know why TS's inference is failing here and needs the coercion
                type: dataType,
                kind: "error",
                error: error.error
            };
        }
    }
    else {
        //if it's *not* an expected error, we better not swallow it -- rethrow!
        throw error;
    }
}
exports.handleDecodingError = handleDecodingError;
/**
 * This error indicates that the user attempted to instantiate a decoder
 * with no project information (by explicitly overriding the default).
 * @category Exception
 */
class NoProjectInfoError extends Error {
    constructor() {
        super("No project information specified.");
        this.name = "NoProjectInfoError";
    }
}
exports.NoProjectInfoError = NoProjectInfoError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 427634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeInternalFunctionId = exports.functionTableEntryToType = void 0;
const import_1 = __webpack_require__(560013);
//creates a type object for the contract the function was defined in
function functionTableEntryToType(functionEntry) {
    if (functionEntry.contractNode === null) {
        //for free functions
        return null;
    }
    return {
        typeClass: "contract",
        kind: "native",
        id: import_1.makeTypeId(functionEntry.contractId, functionEntry.compilationId),
        typeName: functionEntry.contractName,
        contractKind: functionEntry.contractKind,
        payable: functionEntry.contractPayable
    };
}
exports.functionTableEntryToType = functionTableEntryToType;
function makeInternalFunctionId(functionEntry) {
    return `${functionEntry.compilationId}:${functionEntry.id}`;
}
exports.makeInternalFunctionId = makeInternalFunctionId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 149218:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = exports.Utils = void 0;
__exportStar(__webpack_require__(393311), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(559901));
exports.Utils = Utils;
const Import = __importStar(__webpack_require__(427634));
exports.Import = Import;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 393311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 559901:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toAddress = exports.equalData = exports.keccak256 = exports.ZERO_ADDRESS = exports.MAX_WORD = exports.PC_SIZE = exports.SELECTOR_SIZE = exports.ADDRESS_SIZE = exports.WORD_SIZE = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:evm:utils");
const bn_js_1 = __importDefault(__webpack_require__(213550));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const Conversion = __importStar(__webpack_require__(152714));
exports.WORD_SIZE = 0x20;
exports.ADDRESS_SIZE = 20;
exports.SELECTOR_SIZE = 4; //function selectors, not event selectors
exports.PC_SIZE = 4;
exports.MAX_WORD = new bn_js_1.default(-1).toTwos(exports.WORD_SIZE * 8);
exports.ZERO_ADDRESS = "0x" + "00".repeat(exports.ADDRESS_SIZE);
//beware of using this for generic strings! (it's fine for bytestrings, or
//strings representing numbers) if you want to use this on a generic string,
//you should pass in {type: "string", value: theString} instead of the string
//itself.
//(maybe I should add a rawKeccak256 function, using sha3 instead of
//soliditysha3?  not seeing the need atm though)
function keccak256(...args) {
    // debug("args %o", args);
    const rawSha = web3_utils_1.default.soliditySha3(...args);
    debug("rawSha %o", rawSha);
    let sha;
    if (rawSha === null) {
        sha = ""; //HACK, I guess?
    }
    else {
        sha = rawSha.replace(/0x/, "");
    }
    return Conversion.toBN(sha);
}
exports.keccak256 = keccak256;
//checks if two bytearrays (which may be undefined) are equal.
//does not consider undefined to be equal to itself.
function equalData(bytes1, bytes2) {
    if (!bytes1 || !bytes2) {
        return false;
    }
    if (bytes1.length !== bytes2.length) {
        return false;
    }
    for (let i = 0; i < bytes1.length; i++) {
        if (bytes1[i] !== bytes2[i]) {
            return false;
        }
    }
    return true;
}
exports.equalData = equalData;
function toAddress(bytes) {
    if (typeof bytes === "string") {
        //in this case, we can do some simple string manipulation and
        //then pass to web3
        let hex = bytes; //just renaming for clarity
        if (hex.startsWith("0x")) {
            hex = hex.slice(2);
        }
        if (hex.length < 2 * exports.ADDRESS_SIZE) {
            hex = hex.padStart(2 * exports.ADDRESS_SIZE, "0");
        }
        if (hex.length > 2 * exports.ADDRESS_SIZE) {
            hex = "0x" + hex.slice(hex.length - 2 * exports.ADDRESS_SIZE);
        }
        return web3_utils_1.default.toChecksumAddress(hex);
    }
    //otherwise, we're in the Uint8Array case, which we can't fully handle ourself
    //truncate *on left* to 20 bytes
    if (bytes.length > exports.ADDRESS_SIZE) {
        bytes = bytes.slice(bytes.length - exports.ADDRESS_SIZE, bytes.length);
    }
    //now, convert to hex string and apply checksum case that second argument
    //(which ensures it's padded to 20 bytes) shouldn't actually ever be
    //needed, but I'll be safe and include it
    return web3_utils_1.default.toChecksumAddress(Conversion.toHexString(bytes, exports.ADDRESS_SIZE));
}
exports.toAddress = toAddress;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 915103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatFunctionLike = exports.ReturndataDecodingInspector = exports.LogDecodingInspector = exports.containsDeliberateReadError = exports.CalldataDecodingInspector = exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.nativizeAccessList = exports.unsafeNativizeVariables = exports.unsafeNativize = exports.ResultInspector = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:export");
const os_1 = __importDefault(__webpack_require__(822037));
const util_1 = __importDefault(__webpack_require__(473837));
const Format = __importStar(__webpack_require__(429965));
const Conversion = __importStar(__webpack_require__(152714));
const inspect_1 = __webpack_require__(749290);
Object.defineProperty(exports, "ResultInspector", ({ enumerable: true, get: function () { return inspect_1.ResultInspector; } }));
Object.defineProperty(exports, "unsafeNativize", ({ enumerable: true, get: function () { return inspect_1.unsafeNativize; } }));
Object.defineProperty(exports, "unsafeNativizeVariables", ({ enumerable: true, get: function () { return inspect_1.unsafeNativizeVariables; } }));
Object.defineProperty(exports, "nativizeAccessList", ({ enumerable: true, get: function () { return inspect_1.nativizeAccessList; } }));
/**
 * This function is similar to
 * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to
 * be safe, and also allows for different output formats.  The only currently
 * supported format is "ethers", which is intended to match the way that
 * Truffle Contract currently returns values (based on the Ethers decoder).  As
 * such, it only handles ABI types, and in addition does not handle the types
 * fixed, ufixed, or function.  Note that in these cases it returns `undefined`
 * rather than throwing, as we want this function to be used in contexts where
 * it had better not throw.  It also does not handle circularities, for similar
 * reasons.
 *
 * To handle numeric types, this function takes an optional numberFormatter
 * option that tells it how to handle numbers; this function should take a
 * BigInt as input.  By default, this function will be the identity, and so
 * numbers will be represented as BigInts.
 *
 * Note that this function begins by calling abify, so out-of-range enums (that
 * aren't so out-of-range as to be padding errors) will not return `undefined`.
 * Out-of-range booleans similarly will return true rather than `undefined`.
 * However, other range errors may return `undefined`; this may technically be a
 * slight incompatibility with existing behavior, but should not be relevant
 * except in quite unusual cases.
 *
 * In order to match the behavior for tuples, tuples will be transformed into
 * arrays, but named entries will additionally be keyed by name.  Moreover,
 * indexed variables of reference type will be nativized to an undecoded hex
 * string.
 */
function nativize(result, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativize(result, numberFormatter);
    }
}
exports.nativize = nativize;
function ethersCompatibleNativize(result, numberFormatter = x => x) {
    //note: the original version of this function began by calling abify,
    //but we don't do that here because abify requires a userDefinedTypes
    //parameter and we don't want that.
    //However, it only needs that to handle getting the types right.  Since
    //we don't care about that here, we instead do away with abify and handle
    //such matters ourselves (which is less convenient, yeah).
    switch (result.kind) {
        case "error":
            switch (result.error.kind) {
                case "IndexedReferenceTypeError":
                    //strictly speaking for arrays ethers will fail to decode
                    //rather than do this, but, eh
                    return result.error.raw;
                case "EnumOutOfRangeError":
                    return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));
                default:
                    return undefined;
            }
        case "value":
            switch (result.type.typeClass) {
                case "uint":
                case "int":
                    const asBN = (result).value.asBN;
                    return numberFormatter(Conversion.toBigInt(asBN));
                case "enum":
                    const numericAsBN = result.value
                        .numericAsBN;
                    return numberFormatter(Conversion.toBigInt(numericAsBN));
                case "bool":
                    return result.value.asBoolean;
                case "bytes":
                    const asHex = result.value.asHex;
                    return asHex !== "0x" ? asHex : null;
                case "address":
                    return result.value.asAddress;
                case "contract":
                    return result.value.address;
                case "string": {
                    const coercedResult = result;
                    switch (coercedResult.value.kind) {
                        case "valid":
                            return coercedResult.value.asString;
                        case "malformed":
                            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)
                            // note we need to cut off the 0x prefix
                            return Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString();
                    }
                }
                case "userDefinedValueType":
                    return ethersCompatibleNativize(result.value, numberFormatter);
                case "array":
                    return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));
                case "tuple":
                case "struct":
                    //in this case, we need the result to be an array, but also
                    //to have the field names (where extant) as keys
                    const nativized = [];
                    const pairs = (result).value;
                    for (const { name, value } of pairs) {
                        const nativizedValue = ethersCompatibleNativize(value, numberFormatter);
                        nativized.push(nativizedValue);
                        if (name) {
                            nativized[name] = nativizedValue;
                        }
                    }
                    return nativized;
                case "function":
                    switch (result.type.visibility) {
                        case "external":
                            const coercedResult = result;
                            //ethers per se doesn't handle this, but web3's hacked version will
                            //sometimes decode these as just a bytes24, so let's do that
                            return (coercedResult.value.contract.address.toLowerCase() +
                                coercedResult.value.selector.slice(2));
                        case "internal":
                            return undefined;
                    }
                case "fixed":
                case "ufixed":
                default:
                    return undefined;
            }
    }
}
/**
 * This function is similar to [[nativize]], but takes
 * a [[ReturndataDecoding]].  If there's only one returned value, it
 * will be run through compatibleNativize but otherwise unaltered;
 * otherwise the results will be put in an object.
 *
 * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],
 * this will just return `undefined`.
 */
function nativizeReturn(decoding, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeReturn(decoding, numberFormatter);
    }
}
exports.nativizeReturn = nativizeReturn;
function ethersCompatibleNativizeReturn(decoding, numberFormatter = x => x) {
    if (decoding.kind !== "return") {
        return undefined;
    }
    if (decoding.arguments.length === 1) {
        return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);
    }
    const result = {};
    for (let i = 0; i < decoding.arguments.length; i++) {
        const { name, value } = decoding.arguments[i];
        const nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;
        if (name) {
            result[name] = nativized;
        }
    }
    return result;
}
/**
 * This function is similar to [[compatibleNativize]], but takes
 * a [[LogDecoding]], and puts the results in an object.  Note
 * that this does not return the entire event info, but just the
 * `args` for the event.
 */
function nativizeEventArgs(decoding, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);
    }
}
exports.nativizeEventArgs = nativizeEventArgs;
function ethersCompatibleNativizeEventArgs(decoding, numberFormatter = x => x) {
    const result = {};
    for (let i = 0; i < decoding.arguments.length; i++) {
        const { name, value } = decoding.arguments[i];
        const nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;
        if (name) {
            result[name] = nativized;
        }
    }
    //note: if you have an argument named __length__, what ethers
    //actually does is... weird.  we're just going to do this instead,
    //which is simpler and probably more useful, even if it's not strictly
    //the same (I *seriously* doubt anyone was relying on the old behavior,
    //because it's, uh, not very useful)
    result.__length__ = decoding.arguments.length;
    return result;
}
/**
 * Similar to [[ResultInspector]], but for a [[CalldataDecoding]].
 * See [[ResultInspector]] for more information.
 */
class CalldataDecodingInspector {
    constructor(decoding) {
        this.decoding = decoding;
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.decoding.kind) {
            case "function":
                const fullName = `${this.decoding.class.typeName}.${this.decoding.abi.name}`;
                return formatFunctionLike(fullName, this.decoding.arguments, options);
            case "constructor":
                return formatFunctionLike(`new ${this.decoding.class.typeName}`, this.decoding.arguments, options);
            case "message":
                const { data, abi } = this.decoding;
                //we'll set up a value and inspect that :)
                const codecValue = {
                    kind: "value",
                    type: {
                        typeClass: "bytes",
                        kind: "dynamic"
                    },
                    value: {
                        asHex: data
                    }
                };
                if (abi) {
                    return formatFunctionLike(`${this.decoding.class.typeName}.${abi.type}`, [{ value: codecValue }], options, true // we don't need to see the type here!
                    );
                }
                else {
                    return `Sent raw data to ${this.decoding.class.typeName}: ${util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options)}`;
                }
            case "unknown":
                return "Receiving contract could not be identified.";
            case "create":
                return "Created contract could not be identified.";
        }
    }
}
exports.CalldataDecodingInspector = CalldataDecodingInspector;
function containsDeliberateReadError(result) {
    switch (result.kind) {
        case "value":
            switch (result.type.typeClass) {
                case "struct":
                    //this is currently only intended for use with storage variables, so I
                    //won't bother with handling tuple, magic, options
                    return result.value.some(({ value }) => containsDeliberateReadError(value));
                case "array":
                    return result.value.some(containsDeliberateReadError);
                case "mapping":
                    return result.value.some(({ value }) => containsDeliberateReadError(value));
                default:
                    return false;
            }
        case "error":
            switch (result.error.kind) {
                case "StorageNotSuppliedError":
                    return true;
                default:
                    return false;
            }
    }
}
exports.containsDeliberateReadError = containsDeliberateReadError;
/**
 * Similar to [[ResultInspector]], but for a [[LogDecoding]].
 * See [[ResultInspector]] for more information.
 */
class LogDecodingInspector {
    constructor(decoding) {
        this.decoding = decoding;
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        const className = this.decoding.definedIn
            ? this.decoding.definedIn.typeName
            : this.decoding.class.typeName;
        const eventName = this.decoding.abi.name;
        const fullName = `${className}.${eventName}`;
        switch (this.decoding.kind) {
            case "event":
                return formatFunctionLike(fullName, this.decoding.arguments, options);
            case "anonymous":
                return formatFunctionLike(`<anonymous> ${fullName}`, this.decoding.arguments, options);
        }
    }
}
exports.LogDecodingInspector = LogDecodingInspector;
/**
 * Similar to [[ResultInspector]], but for a [[ReturndataDecoding]].
 * See [[ResultInspector]] for more information.
 */
class ReturndataDecodingInspector {
    constructor(decoding) {
        this.decoding = decoding;
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.decoding.kind) {
            case "return":
                return formatFunctionLike("Returned values: ", this.decoding.arguments, options);
            case "returnmessage":
                const { data } = this.decoding;
                //we'll just set up a value and inspect that :)
                const codecValue = {
                    kind: "value",
                    type: {
                        typeClass: "bytes",
                        kind: "dynamic"
                    },
                    value: {
                        asHex: data
                    }
                };
                const dataString = util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options);
                return `Returned raw data: ${dataString}`;
            case "selfdestruct":
                return "The contract self-destructed.";
            case "failure":
                return "The transaction reverted without a message.";
            case "revert":
                const name = this.decoding.definedIn
                    ? `${this.decoding.definedIn.typeName}.${this.decoding.abi.name}`
                    : this.decoding.abi.name;
                return formatFunctionLike(`Error thrown:${os_1.default.EOL}${name}`, this.decoding.arguments, options);
            case "bytecode":
                //this one gets custom handling :P
                const contractKind = this.decoding.class.contractKind || "contract";
                const firstLine = this.decoding.address !== undefined
                    ? `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName} at ${this.decoding.address}.`
                    : `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName}.`;
                if (this.decoding.immutables && this.decoding.immutables.length > 0) {
                    const prefixes = this.decoding.immutables.map(({ name, class: { typeName } }) => `${typeName}.${name}: `);
                    const maxLength = Math.max(...prefixes.map(prefix => prefix.length));
                    const paddedPrefixes = prefixes.map(prefix => prefix.padStart(maxLength));
                    const formattedValues = this.decoding.immutables.map((value, index) => {
                        const prefix = paddedPrefixes[index];
                        const formatted = indentExcludingFirstLine(util_1.default.inspect(new inspect_1.ResultInspector(value.value), options), maxLength);
                        return prefix + formatted;
                    });
                    return `Immutable values:${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}`;
                }
                else {
                    return firstLine;
                }
            case "unknownbytecode":
                return "Bytecode was returned, but it could not be identified.";
        }
    }
}
exports.ReturndataDecodingInspector = ReturndataDecodingInspector;
//copied from TestRunner, but simplified for our purposes :)
function indentArray(input, indentation) {
    return input.map(line => " ".repeat(indentation) + line);
}
//copied from TestRunner, but simplified for our purposes :)
function indentExcludingFirstLine(input, indentation) {
    const lines = input.split(/\r?\n/);
    return [lines[0], ...indentArray(lines.slice(1), indentation)].join(os_1.default.EOL);
}
//used for formatting things that look like function calls:
//events (including anonymous events), identifiable transactions,
//and revert messages
//"header" param should include everything before the initial parenthesis
/**
 * @hidden
 */
function formatFunctionLike(header, values, options, suppressType = false, indent = 2 //for use by debug-utils
) {
    if (values.length === 0) {
        return `${header}()`;
    }
    let formattedValues = values.map(({ name, indexed, value }, index) => {
        const namePrefix = name ? `${name}: ` : "";
        const indexedPrefix = indexed ? "<indexed> " : "";
        const prefix = namePrefix + indexedPrefix;
        const displayValue = util_1.default.inspect(new inspect_1.ResultInspector(value), options);
        const typeString = suppressType
            ? ""
            : ` (type: ${Format.Types.typeStringWithoutLocation(value.type)})`;
        return indentExcludingFirstLine(prefix +
            displayValue +
            typeString +
            (index < values.length - 1 ? "," : ""), 2 * indent);
    });
    return `${header}(${os_1.default.EOL}${indentArray(formattedValues, indent).join(os_1.default.EOL)}${os_1.default.EOL})`;
}
exports.formatFunctionLike = formatFunctionLike;
//# sourceMappingURL=export.js.map

/***/ }),

/***/ 573440:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Types = void 0;
const Types = __importStar(__webpack_require__(154075));
exports.Types = Types;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 429965:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Types = void 0;
/**
 * # Codec Output Format
 *
 * ## Module information
 *
 * This module primarily defines TypeScript types for the output format
 * used in results provided by packages
 * `@truffle/decoder@^4.0.0` and `@truffle/codec@^0.1.0`.
 *
 * See below for complete listing or continue reading
 * [Format information](#format-information) to learn about this format.
 *
 * ### How to import
 *
 * Import either as part of Codec or by itself:
 *
 * ```typescript
 * // when importing entire Codec, use Codec.Format.*:
 * import * as Codec from "@truffle/codec";
 *
 * // or import Format directly:
 * import { Format } from "@truffle/codec";
 * ```
 *
 * ![Example struct decoding](media://example-struct-decoding.png)
 *
 * ## Format information
 *
 * This format is intended for use in smart contract and dapp development
 * tools and libraries, and for use in display contexts, such as when
 * building on-screen components to show transaction and smart contract
 * state information.
 *
 * This format seeks to provide an exhaustive schema for JavaScript
 * objects to encode **lossless**, **machine-readable** representations of
 * all possible Solidity and ABI data types and all possible values of those
 * types.
 *
 * This format targets types and values understood by the
 * [Solidity programming language](https://solidity.readthedocs.io) and
 * the [Contract ABI specification](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html),
 * within the context of the [Ethereum Virtual Machine](https://ethereum.github.io/yellowpaper/paper.pdf)
 * (EVM) and in raw data for transactions and logs according to the
 * [Ethereum JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).
 *
 * Objects in this format may be deeply nested and/or contain circular
 * dependencies. As such, **do not** serialize objects in this format or
 * otherwise attempt to display them in full without considering potential
 * risk. **Objects in this format are for the machine to read, not humans!**
 * This module provides utilities for inspecting objects in this format,
 * including the **safe** [[Format.Utils.Inspect.ResultInspector]] wrapper
 * (for [util.inspect](https://nodejs.org/api/util.html#util_util_inspect_object_options)),
 * and the **unsafe** [[Format.Utils.Inspect.unsafeNativize]] function. For more
 * information, please see the documentation for those utilities.
 *
 * ### Specification
 *
 * Individual decoded values are represented by objects of the type
 * [[Format.Values.Result]], which contain the following fields:
 *   1. `type`: This is a [[Format.Types.Type|`Type`]] object describing the value's
 *     type.  Each `Type` has a `typeClass` field describing the overall broad type,
 *     such as `"uint"` or `"bytes"`, together with additional information that gives
 *     the specific type.  For full detail, see [[Format.Types]].
 *
 *   2. `kind`: This is either `"value"`, in which case the `Result` is a
 *     [[Format.Values.Value|`Value`]], or `"error"`, in which case the `Result` is an
 *     [[Format.Errors.ErrorResult|`ErrorResult`]].  In the former case, there will be
 *     a `value` field containin the decoded value.  In the latter case, there will be
 *     an `error` field indicating what went wrong.  *Warning*: When decoding a
 *     complex type, such as an array, mapping, or array, getting a kind of `"value"`
 *     does not necessarily mean the individual elements were decoded successfully.
 *     Even if the `Result` for the array (mapping, struct) as a whole has kind
 *     `"value"`, the elements might still have kind `"error"`.
 *
 *   3. `value`: As mentioned, this is included when `kind` is equal to `"value"`.
 *     It contains information about the actual decoded value.  See
 *     [[Format.Values|`Format.Values`]] for more information.
 *
 *   4. `error`: The alternative to `value`.  Generally includes information about
 *     the raw data that led to the error.  See [[Format.Errors|`Format.Errors`]] for
 *     more information.
 *
 *   5. `reference`: This field is a debugger-only feature and does not
 *      apply to results returned by  @truffle/decoder, so it won't be documented here.
 *
 * ### Values vs. errors
 *
 * It's worth taking a moment here to answer the question: What counts as a value,
 * and what counts as an error?
 *
 * In general, the answer is that anything that can be generated via Solidity
 * alone (i.e. no assembly), with correctly-encoded inputs, and without making use
 * of compiler bugs, is a value, not an error.  That means that, for instance, the
 * following things are values, not errors:
 *   - A variable of contract type whose address does not actually hold a
 *     contract of that type;
 *   - An external function pointer that does not correspond to a valid
 *     function;
 *   - A string containing invalid UTF-8;
 *   - ..., etc.
 *
 * By contrast, the following *are* errors:
 *   - A `bool` which is neither `false` (0) nor `true` (1);
 *   - An `enum` which is out of range;
 *   - ..., etc.
 *
 * (You may be wondering about the enum case here, because if you go sufficiently
 * far back, to Solidity 0.4.4 or earlier, it *was* possible to generate
 * out-of-range enums without resorting to assembly or compiler bugs.  However,
 * enums are only supported in full mode (see
 * [Notes on decoding modes](../#decoding-modes)),
 * which only supports 0.4.12 and later, so
 * we consider out-of-range enums an error.  There are also additional technical
 * reasons why supporting out-of-range enums as a value would be difficult.)
 *
 * There are three special cases here that are likely worthy of note.
 *
 * Firstly, internal function pointers currently can't be meaningfully
 * decoded via @truffle/decoder.  However, they decode to a bare-bones value,
 * not an error, as it is (in a sense) our own fault that we can't decode
 * these, so it doesn't make sense to report an error, which would mean that
 * something is wrong with the encoded data itself.  This value that it
 * decodes to will give the program counter values it corresponds to, but
 * will not include the function name or defining class, as @truffle/decoder
 * is not presently capable of that.  For now, full decoding of internal
 * function pointers remains a debugger-only feature.  (But limited support for
 * this via @truffle/decoder is planned for the future.)
 *
 * (When using the debugger, an invalid internal function pointer will decode to an
 * error.  However, when using @truffle/decoder, we have no way of discerning whether
 * the pointer is valid or not, so internal function pointers will always decode to
 * a value, if an uninformative one.)
 *
 * Secondly, when decoding events, it is impossible to decode indexed parameters
 * of reference type.  Thus, these decode to an error
 * (`IndexedReferenceTypeError`, which see) rather than to a value.
 *
 * Thirdly, the decoder is currently limited when it comes to decoding state
 * variables that are declared constant, and not all such variables are yet
 * supported in decoding; attempting to decode one of these that is not currently
 * supported will yield an error.
 *
 * Similarly, there are various things that decode to errors for technical reasons.
 * Objects with encoded length fields larger than what fits in a JavaScript safe
 * integer, or pointed to by pointers with values larger than what fits in a
 * JavaScript safe integer, will decode to errors, even if they may technically be
 * legal.  Such cases are impractical to handle and should never come up in real
 * use so we decode them to errors.  Errors may also be returned in case of an
 * error in attempting to read the data to be decoded.
 *
 * Finally, except when decoding events, we do not return an error if the pointers
 * in an ABI-encoded array or tuple are arranged in a nonstandard way, or if
 * strings or bytestrings are incorrectly padded, because it is not worth the
 * trouble to detect these conditions.
 *
 *
 * ## Notes on this documentation
 *
 * Most of this doesn't have explanatory documentation
 * because it's largely self-explanatory, but particularly
 * non-obvious parts have been documented for clarity.
 *
 * A note on optional fields: A number of types or values
 * have optional fields.  These contain helpful
 * but non-essential information, or information which
 * for technical reasons we can't guarantee we can determine.
 *
 * @category Data
 *
 * @packageDocumentation
 */
const common_1 = __webpack_require__(573440);
Object.defineProperty(exports, "Types", ({ enumerable: true, get: function () { return common_1.Types; } }));
const Utils = __importStar(__webpack_require__(446776));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 154075:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Contains the types for type objects, and some
 * functions for working with them.
 *
 * @category Main Format
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:format:types");
function forgetCompilations(typesByCompilation) {
    return Object.assign({}, ...Object.values(typesByCompilation).map(({ types }) => types));
}
exports.forgetCompilations = forgetCompilations;
function isUserDefinedType(anyType) {
    const userDefinedTypes = ["contract", "enum", "struct", "userDefinedValueType"];
    return userDefinedTypes.includes(anyType.typeClass);
}
function isReferenceType(anyType) {
    const alwaysReferenceTypes = ["array", "mapping", "struct", "string"];
    if (alwaysReferenceTypes.includes(anyType.typeClass)) {
        return true;
    }
    else if (anyType.typeClass === "bytes") {
        return anyType.kind === "dynamic";
    }
    else {
        return false;
    }
}
exports.isReferenceType = isReferenceType;
//one could define a counterpart function that stripped all unnecessary information
//from the type object, but at the moment I see no need for that
function fullType(basicType, userDefinedTypes) {
    if (!isUserDefinedType(basicType)) {
        return basicType;
    }
    let id = basicType.id;
    let storedType = userDefinedTypes[id];
    if (!storedType) {
        return basicType;
    }
    let returnType = Object.assign(Object.assign({}, basicType), storedType);
    if (isReferenceType(basicType) && basicType.location !== undefined) {
        returnType = specifyLocation(returnType, basicType.location);
    }
    return returnType;
}
exports.fullType = fullType;
//the location argument here always forces, so passing undefined *will* force undefined
function specifyLocation(dataType, location) {
    if (isReferenceType(dataType)) {
        switch (dataType.typeClass) {
            case "string":
            case "bytes":
                return Object.assign(Object.assign({}, dataType), { location });
            case "array":
                return Object.assign(Object.assign({}, dataType), { location, baseType: specifyLocation(dataType.baseType, location) });
            case "mapping":
                let newLocation = location === "storage" ? "storage" : undefined;
                return Object.assign(Object.assign({}, dataType), { location: newLocation, valueType: specifyLocation(dataType.valueType, newLocation) });
            case "struct":
                let returnType = Object.assign(Object.assign({}, dataType), { location });
                if (returnType.memberTypes) {
                    returnType.memberTypes = returnType.memberTypes.map(({ name: memberName, type: memberType }) => ({
                        name: memberName,
                        type: specifyLocation(memberType, location)
                    }));
                }
                return returnType;
        }
    }
    else {
        return dataType;
    }
}
exports.specifyLocation = specifyLocation;
//NOTE: the following two functions might not be exactly right for weird internal stuff,
//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things
//are pointers or not??  we don't track that so we can't recreate that)
//But what can you do.
function typeString(dataType) {
    let baseString = typeStringWithoutLocation(dataType);
    if (isReferenceType(dataType) && dataType.location) {
        return baseString + " " + dataType.location;
    }
    else {
        return baseString;
    }
}
exports.typeString = typeString;
function typeStringWithoutLocation(dataType) {
    switch (dataType.typeClass) {
        case "uint":
            return dataType.typeHint || `uint${dataType.bits}`;
        case "int":
            return dataType.typeHint || `int${dataType.bits}`;
        case "bool":
            return dataType.typeHint || "bool";
        case "bytes":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }
            switch (dataType.kind) {
                case "dynamic":
                    return "bytes";
                case "static":
                    return `bytes${dataType.length}`;
            }
        case "address":
            switch (dataType.kind) {
                case "general":
                    return dataType.typeHint || "address"; //I guess?
                case "specific":
                    return dataType.payable ? "address payable" : "address";
            }
        case "string":
            return dataType.typeHint || "string";
        case "fixed":
            return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;
        case "ufixed":
            return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;
        case "array":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }
            switch (dataType.kind) {
                case "dynamic":
                    return `${typeStringWithoutLocation(dataType.baseType)}[]`;
                case "static":
                    return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;
            }
        case "mapping":
            return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;
        case "struct":
        case "enum":
            //combining these cases for simplicity
            switch (dataType.kind) {
                case "local":
                    return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;
                case "global":
                    return `${dataType.typeClass} ${dataType.typeName}`;
            }
            break; //to satisfy TS :P
        case "userDefinedValueType":
            //differs from struct & enum in that typeClass is omitted
            switch (dataType.kind) {
                case "local":
                    return `${dataType.definingContractName}.${dataType.typeName}`;
                case "global":
                    return `${dataType.typeName}`;
            }
            break; //to satisfy TS :P
        case "tuple":
            return (dataType.typeHint ||
                "tuple(" +
                    dataType.memberTypes
                        .map(memberType => typeString(memberType.type))
                        .join(",") +
                    ")"); //note that we do include location and do not put spaces
        case "contract":
            return dataType.contractKind + " " + dataType.typeName;
        case "magic":
            //no, this is not transposed!
            const variableNames = {
                message: "msg",
                transaction: "tx",
                block: "block"
            };
            return variableNames[dataType.variable];
        case "type":
            return `type(${typeString(dataType.type)})`;
        case "function":
            let visibilityString;
            switch (dataType.visibility) {
                case "external":
                    if (dataType.kind === "general") {
                        if (dataType.typeHint) {
                            return dataType.typeHint;
                        }
                        else {
                            return "function external"; //I guess???
                        }
                    }
                    visibilityString = " external"; //note the deliberate space!
                    break;
                case "internal":
                    visibilityString = "";
                    break;
            }
            let mutabilityString = dataType.mutability === "nonpayable" ? "" : " " + dataType.mutability; //again, note the deliberate space
            let inputList = dataType.inputParameterTypes.map(typeString).join(","); //note that we do include location, and do not put spaces
            let outputList = dataType.outputParameterTypes.map(typeString).join(",");
            let inputString = `function(${inputList})`;
            let outputString = outputList === "" ? "" : ` returns (${outputList})`; //again, note the deliberate space
            return inputString + mutabilityString + visibilityString + outputString;
        case "options":
            //note: not a real Solidity type! just for error messaging!
            return "options";
    }
}
exports.typeStringWithoutLocation = typeStringWithoutLocation;
function isContractDefinedType(anyType) {
    const contractDefinedTypes = ["enum", "struct", "userDefinedValueType"];
    return contractDefinedTypes.includes(anyType.typeClass)
        && anyType.kind === "local";
}
exports.isContractDefinedType = isContractDefinedType;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 809898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tie = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:format:utils:circularity");
function tie(untied) {
    return tieWithTable(untied, []);
}
exports.tie = tie;
function tieWithTable(untied, seenSoFar) {
    if (untied.kind === "error") {
        return untied;
    }
    let reference;
    switch (untied.type.typeClass) {
        case "array":
            const untiedAsArray = untied; //dammit TS
            reference = untiedAsArray.reference;
            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let tied = Object.assign(Object.assign({}, untiedAsArray), { value: [...untiedAsArray.value] });
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object
                //note: this used to be a for-in loop, changed to avoid problems with VSCode
                for (let index = 0; index < tied.value.length; index++) {
                    tied.value[index] = tieWithTable(tied.value[index], [
                        tied,
                        ...seenSoFar
                    ]);
                }
                return tied;
            }
            else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });
            }
        case "struct":
            const untiedAsStruct = untied; //dammit TS
            reference = untiedAsStruct.reference;
            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let tied = Object.assign(Object.assign({}, untiedAsStruct), { value: untiedAsStruct.value.map(component => (Object.assign({}, component))) });
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object
                //note: this used to be a for-in loop, changed to avoid problems with VSCode
                for (let index = 0; index < tied.value.length; index++) {
                    tied.value[index] = Object.assign(Object.assign({}, tied.value[index]), { value: tieWithTable(tied.value[index].value, [tied, ...seenSoFar]) });
                }
                return tied;
            }
            else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });
            }
        case "tuple": //currently there are no memory tuples, but may as well
            //can't be circular, just recurse
            //note we can just recurse with a straight tie here; don't need tieWithTable
            const untiedAsTuple = untied; //dammit TS
            //we need to do some pointer stuff here, so let's first create our new
            //object we'll be pointing to
            let tied = Object.assign({}, untiedAsTuple);
            tied.value = tied.value.map(component => (Object.assign(Object.assign({}, component), { value: tie(component.value) })));
            return tied;
        default:
            //other types either:
            //1. aren't containers and so need no recursion
            //2. are containers but can't go in or contain memory things
            //and so still need no recursion
            //(or, in the case of mappings, can't contain *nontrivial* memory
            //things)
            return untied;
    }
}
//# sourceMappingURL=circularity.js.map

/***/ }),

/***/ 965086:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.message = void 0;
/**
 * @protected
 *
 * @packageDocumentation
 */
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:format:utils:exception");
const Format = __importStar(__webpack_require__(573440));
const AstUtils = __importStar(__webpack_require__(707656));
//this function gives an error message
//for those errors that are meant to possibly
//be wrapped in a DecodingError and thrown
function message(error) {
    switch (error.kind) {
        case "UserDefinedTypeNotFoundError":
            let typeName = Format.Types.isContractDefinedType(error.type)
                ? error.type.definingContractName + "." + error.type.typeName
                : error.type.typeName;
            return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;
        case "UnsupportedConstantError":
            return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;
        case "UnusedImmutableError":
            return "Cannot read unused immutable";
        case "ReadErrorStack":
            return `Can't read stack from position ${error.from} to ${error.to}`;
        case "ReadErrorBytes":
            return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;
        case "ReadErrorStorage":
            if (error.range.length) {
                return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;
            }
            else {
                return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;
            }
        case "StorageNotSuppliedError":
            if (error.range.length) {
                return `Unknown storage for ${error.range.length} bytes starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;
            }
            else {
                return `Unknown storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;
            }
    }
}
exports.message = message;
function slotAddressPrintout(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let { type: keyEncoding, value: keyValue } = keyInfoForPrinting(slot.key);
        return ("keccak(" +
            keyValue +
            " as " +
            keyEncoding +
            ", " +
            slotAddressPrintout(slot.path) +
            ") + " +
            slot.offset.toString());
    }
    else if (slot.path !== undefined) {
        const pathAddressPrintout = slotAddressPrintout(slot.path);
        return slot.hashPath
            ? "keccak(" + pathAddressPrintout + ")" + slot.offset.toString()
            : pathAddressPrintout + slot.offset.toString();
    }
    else {
        return slot.offset.toString();
    }
}
//this is like the old toSoliditySha3Input, but for debugging purposes ONLY
//it will NOT produce correct input to soliditySha3
//please use mappingKeyAsHex instead if you wish to encode a mapping key.
function keyInfoForPrinting(input) {
    switch (input.type.typeClass) {
        case "uint":
            return {
                type: "uint",
                value: input.value.asBN.toString()
            };
        case "int":
            return {
                type: "int",
                value: input.value.asBN.toString()
            };
        case "fixed":
            return {
                type: `fixed256x${input.type.places}`,
                value: input.value.asBig.toString()
            };
        case "ufixed":
            return {
                type: `ufixed256x${input.type.places}`,
                value: input.value.asBig.toString()
            };
        case "bool":
            //this is the case that won't work as valid input to soliditySha3 :)
            return {
                type: "uint",
                value: input.value.asBoolean.toString()
            };
        case "bytes":
            switch (input.type.kind) {
                case "static":
                    return {
                        type: "bytes32",
                        value: input.value.asHex
                    };
                case "dynamic":
                    return {
                        type: "bytes",
                        value: input.value.asHex
                    };
            }
        case "address":
            return {
                type: "address",
                value: input.value.asAddress
            };
        case "string":
            let coercedInput = (input);
            switch (coercedInput.value.kind) {
                case "valid":
                    return {
                        type: "string",
                        value: coercedInput.value.asString
                    };
                case "malformed":
                    return {
                        type: "bytes",
                        value: coercedInput.value.asHex
                    };
            }
        //fixed and ufixed are skipped for now
    }
}
//# sourceMappingURL=exception.js.map

/***/ }),

/***/ 446776:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Circularity = exports.Inspect = exports.Exception = void 0;
const Exception = __importStar(__webpack_require__(965086));
exports.Exception = Exception;
const Inspect = __importStar(__webpack_require__(749290));
exports.Inspect = Inspect;
const Circularity = __importStar(__webpack_require__(809898));
exports.Circularity = Circularity;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 749290:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nativizeAccessList = exports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:format:utils:inspect");
const util_1 = __importDefault(__webpack_require__(473837));
const Format = __importStar(__webpack_require__(573440));
const Conversion = __importStar(__webpack_require__(152714));
const EvmUtils = __importStar(__webpack_require__(559901));
const Exception = __importStar(__webpack_require__(965086));
//HACK?
function cleanStylize(options) {
    const clonedOptions = Object.assign({}, options);
    delete clonedOptions.stylize;
    return clonedOptions;
}
/**
 * This class is meant to be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * function.  Given a [[Format.Values.Result]] `value`, one can use
 * `new ResultInspector(value)` to create a ResultInspector for that value,
 * which can be used with util.inspect() to create a human-readable string
 * representing the value.
 *
 * @example
 * Suppose `value` is a Result.  In Node, the following would print to the
 * console a human-readable representation of `value`, with colors enabled,
 * no maximum depth, and no maximum array length, and lines (usually) no
 * longer than 80 characters:
 * ```javascript
 * console.log(
 *   util.inspect(
 *     new ResultInspector(value),
 *     {
 *       colors: true,
 *       depth: null,
 *       maxArrayLength: null,
 *       breakLength: 80
 *     }
 *   )
 * );
 * ```
 * Of course, there are many other ways to use util.inspect; see Node's
 * documentation, linked above, for more.
 */
class ResultInspector {
    constructor(result) {
        this.result = result;
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.result.kind) {
            case "value":
                switch (this.result.type.typeClass) {
                    case "uint":
                    case "int":
                        return options.stylize((this.result).value.asBN.toString(), "number");
                    case "fixed":
                    case "ufixed":
                        //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;
                        //we'll trust those to their defaults
                        return options.stylize((this.result).value.asBig.toString(), "number");
                    case "bool":
                        return util_1.default.inspect(this.result.value.asBoolean, options);
                    case "bytes":
                        let hex = this.result.value.asHex;
                        switch (this.result.type.kind) {
                            case "static":
                                return options.stylize(hex, "number");
                            case "dynamic":
                                return options.stylize(`hex'${hex.slice(2)}'`, "string");
                        }
                    case "address":
                        return options.stylize(this.result.value.asAddress, "number");
                    case "string": {
                        let coercedResult = this.result;
                        switch (coercedResult.value.kind) {
                            case "valid":
                                return util_1.default.inspect(coercedResult.value.asString, options);
                            case "malformed":
                                //note: this will turn malformed utf-8 into replacement characters (U+FFFD)
                                //note we need to cut off the 0x prefix
                                return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString());
                        }
                    }
                    case "array": {
                        let coercedResult = this.result;
                        if (coercedResult.reference !== undefined) {
                            return formatCircular(coercedResult.reference, options);
                        }
                        return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);
                    }
                    case "mapping":
                        return util_1.default.inspect(new Map(this.result.value.map(({ key, value }) => [
                            new ResultInspector(key),
                            new ResultInspector(value)
                        ])), options);
                    case "struct": {
                        let coercedResult = this.result;
                        if (coercedResult.reference !== undefined) {
                            return formatCircular(coercedResult.reference, options);
                        }
                        return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({
                            [name]: new ResultInspector(value)
                        }))), options);
                    }
                    case "userDefinedValueType": {
                        const typeName = Format.Types.typeStringWithoutLocation(this.result.type);
                        const coercedResult = (this.result);
                        const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);
                        return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized
                    }
                    case "tuple": {
                        let coercedResult = this.result;
                        //if everything is named, do same as with struct.
                        //if not, just do an array.
                        //(good behavior in the mixed case is hard, unfortunately)
                        if (coercedResult.value.every(({ name }) => name)) {
                            return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({
                                [name]: new ResultInspector(value)
                            }))), options);
                        }
                        else {
                            return util_1.default.inspect(coercedResult.value.map(({ value }) => new ResultInspector(value)), options);
                        }
                    }
                    case "type": {
                        switch (this.result.type.type.typeClass) {
                            case "contract":
                                //same as struct case but w/o circularity check
                                return util_1.default.inspect(Object.assign({}, ...this.result.value.map(({ name, value }) => ({
                                    [name]: new ResultInspector(value)
                                }))), options);
                            case "enum": {
                                return enumTypeName(this.result.type.type);
                            }
                        }
                    }
                    case "magic":
                        return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(([key, value]) => ({ [key]: new ResultInspector(value) }))), options);
                    case "enum": {
                        return enumFullName(this.result); //not stylized
                    }
                    case "contract": {
                        return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);
                    }
                    case "function":
                        switch (this.result.type.visibility) {
                            case "external": {
                                let coercedResult = (this.result);
                                let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), { colors: false }));
                                let firstLine;
                                switch (coercedResult.value.kind) {
                                    case "known":
                                        firstLine = `[Function: ${coercedResult.value.abi.name} of`;
                                        break;
                                    case "invalid":
                                    case "unknown":
                                        firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;
                                        break;
                                }
                                let secondLine = `${contractString}]`;
                                let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength
                                    ? "\n"
                                    : " ";
                                //now, put it together
                                return options.stylize(firstLine + breakingSpace + secondLine, "special");
                            }
                            case "internal": {
                                let coercedResult = (this.result);
                                switch (coercedResult.value.kind) {
                                    case "function":
                                        if (coercedResult.value.definedIn) {
                                            return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, "special");
                                        }
                                        else {
                                            return options.stylize(`[Function: ${coercedResult.value.name}]`, "special");
                                        }
                                    case "exception":
                                        return coercedResult.value.deployedProgramCounter === 0
                                            ? options.stylize(`[Function: <zero>]`, "special")
                                            : options.stylize(`[Function: <uninitialized>]`, "special");
                                    case "unknown":
                                        let firstLine = `[Function: decoding not supported (raw info:`;
                                        let secondLine = `deployed PC=${coercedResult.value.deployedProgramCounter}, constructor PC=${coercedResult.value.constructorProgramCounter})]`;
                                        let breakingSpace = firstLine.length + secondLine.length + 1 >
                                            options.breakLength
                                            ? "\n"
                                            : " ";
                                        //now, put it together
                                        return options.stylize(firstLine + breakingSpace + secondLine, "special");
                                }
                            }
                        }
                }
            case "error": {
                debug("this.result: %O", this.result);
                let errorResult = this.result; //the hell?? why couldn't it make this inference??
                switch (errorResult.error.kind) {
                    case "WrappedError":
                        return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);
                    case "UintPaddingError":
                        return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "IntPaddingError":
                        return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "UintPaddingError":
                        return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FixedPaddingError":
                        return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "BoolOutOfRangeError":
                        return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "BoolPaddingError":
                        return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "BytesPaddingError":
                        return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;
                    case "AddressPaddingError":
                        return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "EnumOutOfRangeError":
                        return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "EnumPaddingError":
                        return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "EnumNotFoundDecodingError":
                        return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "ContractPaddingError":
                        return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FunctionExternalNonStackPaddingError":
                        return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FunctionExternalStackPaddingError":
                        return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;
                    case "FunctionInternalPaddingError":
                        return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "NoSuchInternalFunctionError":
                        return `Invalid function (Deployed PC=${errorResult.error.deployedProgramCounter}, constructor PC=${errorResult.error.constructorProgramCounter}) of contract ${errorResult.error.context.typeName}`;
                    case "DeployedFunctionInConstructorError":
                        return `Deployed-style function (PC=${errorResult.error.deployedProgramCounter}) in constructor`;
                    case "MalformedInternalFunctionError":
                        return `Malformed internal function w/constructor PC only (value: ${errorResult.error.constructorProgramCounter})`;
                    case "IndexedReferenceTypeError": //for this one we'll bother with some line-wrapping
                        let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;
                        let secondLine = `(raw value ${errorResult.error.raw})`;
                        let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength
                            ? "\n"
                            : " ";
                        return firstLine + breakingSpace + secondLine;
                    case "OverlongArraysAndStringsNotImplementedError":
                        return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;
                    case "OverlargePointersNotImplementedError":
                        return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;
                    case "UserDefinedTypeNotFoundError":
                    case "UnsupportedConstantError":
                    case "UnusedImmutableError":
                    case "ReadErrorStack":
                    case "ReadErrorStorage":
                    case "ReadErrorBytes":
                        return Exception.message(errorResult.error); //yay, these five are already defined!
                    case "StorageNotSuppliedError":
                        //this one has a message, but we're going to special-case it
                        return options.stylize("?", "undefined");
                }
            }
        }
    }
}
exports.ResultInspector = ResultInspector;
//these get their own class to deal with a minor complication
class ContractInfoInspector {
    constructor(value) {
        this.value = value;
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.value.kind) {
            case "known":
                return (options.stylize(this.value.address, "number") +
                    ` (${this.value.class.typeName})`);
            case "unknown":
                return (options.stylize(this.value.address, "number") + " of unknown class");
        }
    }
}
function enumTypeName(enumType) {
    return ((enumType.kind === "local" ? enumType.definingContractName + "." : "") +
        enumType.typeName);
}
//this function will be used in the future for displaying circular
//structures
function formatCircular(loopLength, options) {
    return options.stylize(`[Circular (=up ${loopLength})]`, "special");
}
function enumFullName(value) {
    switch (value.type.kind) {
        case "local":
            return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;
        case "global":
            return `${value.type.typeName}.${value.value.name}`;
    }
}
/**
 * WARNING! Do NOT use this function in real code unless you
 * absolutely have to!  Using it in controlled tests is fine,
 * but do NOT use it in real code if you have any better option!
 * See [[unsafeNativize]] for why!
 */
function unsafeNativizeVariables(variables) {
    return Object.assign({}, ...Object.entries(variables).map(([name, value]) => {
        try {
            return { [name]: unsafeNativize(value) };
        }
        catch (_) {
            return undefined; //I guess??
        }
    }));
}
exports.unsafeNativizeVariables = unsafeNativizeVariables;
//HACK! Avoid using!
/**
 * WARNING! Do NOT use this function in real code unless you absolutely have
 * to!  Using it in controlled tests is fine, but do NOT use it in real code if
 * you have any better option!
 *
 * This function is a giant hack.  It will throw exceptions on numbers that
 * don't fit in a Javascript number.  It loses various information.  It was
 * only ever written to support our hacked-together watch expression system,
 * and later repurposed to make testing easier.
 *
 * If you are not doing something as horrible as evaluating user-inputted
 * Javascript expressions meant to operate upon Solidity variables, then you
 * probably have a better option than using this in real code!
 *
 * (For instance, if you just want to nicely print individual values, without
 * attempting to first operate on them via Javascript expressions, we have the
 * [[ResultInspector]] class, which can be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * to do exactly that.)
 *
 * Remember, the decoder output format was made to be machine-readable.  It
 * shouldn't be too hard for you to process.  If it comes to it, copy-paste
 * this code and dehackify it for your use case, which hopefully is more
 * manageable than the one that caused us to write this.
 */
function unsafeNativize(result) {
    return unsafeNativizeWithTable(result, []);
}
exports.unsafeNativize = unsafeNativize;
function unsafeNativizeWithTable(result, seenSoFar) {
    if (result.kind === "error") {
        debug("ErrorResult: %O", result);
        switch (result.error.kind) {
            case "BoolOutOfRangeError":
                return true;
            default:
                return undefined;
        }
    }
    //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;
    //other containers will just call unsafeNativize because they can get away with it
    //(only things that can *be* circular need unsafeNativizeWithTable, not things that
    //can merely *contain* circularities)
    switch (result.type.typeClass) {
        case "uint":
        case "int":
            return (result).value.asBN.toNumber(); //WARNING
        case "bool":
            return result.value.asBoolean;
        case "bytes":
            return result.value.asHex;
        case "address":
            return result.value.asAddress;
        case "string": {
            let coercedResult = result;
            switch (coercedResult.value.kind) {
                case "valid":
                    return coercedResult.value.asString;
                case "malformed":
                    // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)
                    // note we need to cut off the 0x prefix
                    return Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString();
            }
        }
        case "fixed":
        case "ufixed":
            //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number
            //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of
            //notation shouldn't affect the result (can you believe I have to write this? @_@)
            return Number((result).value.asBig.toString()); //WARNING
        case "array": {
            let coercedResult = result;
            if (coercedResult.reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let output = [...coercedResult.value];
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* output, not replace it with a new object
                for (let index = 0; index < output.length; index++) {
                    output[index] = unsafeNativizeWithTable(output[index], [
                        output,
                        ...seenSoFar
                    ]);
                }
                return output;
            }
            else {
                return seenSoFar[coercedResult.reference - 1];
            }
        }
        case "userDefinedValueType": {
            return unsafeNativize(result.value);
        }
        case "mapping":
            return Object.assign({}, ...result.value.map(({ key, value }) => ({
                [unsafeNativize(key).toString()]: unsafeNativize(value)
            })));
        case "struct": {
            let coercedResult = result;
            if (coercedResult.reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                let output = Object.assign({}, ...result.value.map(({ name, value }) => ({
                    [name]: value //we *don't* nativize yet!
                })));
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* output, not replace it with a new object
                for (let name in output) {
                    output[name] = unsafeNativizeWithTable(output[name], [
                        output,
                        ...seenSoFar
                    ]);
                }
                return output;
            }
            else {
                return seenSoFar[coercedResult.reference - 1];
            }
        }
        case "type":
            switch (result.type.type.typeClass) {
                case "contract":
                    return Object.assign({}, ...result.value.map(({ name, value }) => ({
                        [name]: unsafeNativize(value)
                    })));
                case "enum":
                    return Object.assign({}, ...result.value.map(enumValue => ({
                        [enumValue.value.name]: unsafeNativize(enumValue)
                    })));
            }
        case "tuple":
            return result.value.map(({ value }) => unsafeNativize(value));
        case "magic":
            return Object.assign({}, ...Object.entries(result.value).map(([key, value]) => ({ [key]: unsafeNativize(value) })));
        case "enum":
            return enumFullName(result);
        case "contract":
            return result.value.address; //we no longer include additional info
        case "function":
            switch (result.type.visibility) {
                case "external": {
                    let coercedResult = result;
                    switch (coercedResult.value.kind) {
                        case "known":
                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;
                        case "invalid":
                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;
                        case "unknown":
                            return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;
                    }
                }
                case "internal": {
                    let coercedResult = result;
                    switch (coercedResult.value.kind) {
                        case "function":
                            if (coercedResult.value.definedIn) {
                                return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;
                            }
                            else {
                                return coercedResult.value.name;
                            }
                        case "exception":
                            return coercedResult.value.deployedProgramCounter === 0
                                ? `<zero>`
                                : `<uninitialized>`;
                        case "unknown":
                            return `<decoding not supported>`;
                    }
                }
            }
    }
}
/**
 * Turns a wrapped access list into a usable form.
 * Will fail if the input is not a wrapped access list!
 * Note that the storage keys must be given as uint256, not bytes32.
 * Primarily meant for internal use.
 */
function nativizeAccessList(wrappedAccessList //this should really be a more specific type
) {
    return wrappedAccessList.value.map(wrappedAccessListForAddress => {
        //HACK: we're just going to coerce all over the place here
        const addressStorageKeysPair = (wrappedAccessListForAddress.value);
        const wrappedAddress = (addressStorageKeysPair[0].value);
        const wrappedStorageKeys = (addressStorageKeysPair[1].value);
        const wrappedStorageKeysArray = (wrappedStorageKeys.value);
        return {
            address: wrappedAddress.value.asAddress,
            storageKeys: wrappedStorageKeysArray.map(wrappedStorageKey => Conversion.toHexString(wrappedStorageKey.value.asBN, EvmUtils.WORD_SIZE))
        };
    });
}
exports.nativizeAccessList = nativizeAccessList;
//# sourceMappingURL=inspect.js.map

/***/ }),

/***/ 20102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * # Truffle Codec
 *
 * This module provides low-level decoding and encoding functionality for
 * Solidity and the Solidity ABI.  Many parts of this module are intended
 * primarily for internal use by Truffle and so remain largely undocumented,
 * but some of its types are also output by @truffle/decoder, which provides
 * a higher-level interface to much of this module's functionality.
 *
 * ## If you're here from Truffle Decoder or Truffle Encoder
 *
 * If you're coming here from [[@truffle/decoder]] or [[@truffle/encoder]],
 * you probably just want to know about the parts that are relevant to you.
 * These are:
 *
 * * The "data" category (specifically [[Format]])
 * * The "output" and "enumerations" categories ([[CalldataDecoding]], [[LogDecoding]], et al., see below)
 * * The "errors" category (specifically [[UnknownUserDefinedTypeError]])
 *
 * Note that the data category is largely scarce in
 * documentation, although that's because it's largely self-explanatory.
 *
 * If you're not just here from Truffle Decoder or Encoder, but are actually
 * interested in the lower-level workings, read on.
 *
 * ## How this module differs from Truffle Decoder and Encoder
 *
 * Unlike Truffle Decoder and Encoder, this library makes no network connections
 * and avoids dependencies that do.  Instead, its decoding functionality
 * is generator-based; calling one of the decoding functions returns a
 * generator.  This generator's `next()` function may return a finished
 * result, or it may return a request for more information.  It is up to
 * the caller to fulfill these requests -- say, by making a network
 * connection of its own.  This is how @truffle/decoder and @truffle/encoder
 * work; @truffle/codec makes requests, while Decoder and Encoder fulfill them by
 * looking up the necessary information on the blockchain.
 *
 * This library also provides additional functionality beyond what's used by
 * Truffle Decoder and Encoder.  In particular, this library also exists to
 * support Truffle Debugger, and so it provides decoding functionality not just
 * for transactions, logs, and state variables, but also for Solidity variables
 * during transaction execution, including circularity detection for memroy
 * structures.  It includes functionality for decoding Solidity's internal
 * function pointers, which the debugger uses, but which Truffle Decoder
 * currently does not (although this is planned for the future).
 *
 * There is also functionality for decoding return values and revert messages
 * that goes beyond what's currently available in @truffle/decoder; this may get
 * a better interface in the future.
 *
 * ## How to use
 *
 * You should probably use [[@truffle/decoder]] or [[@truffle/encoder]]
 * instead, if your use case doesn't preclude it.  This module has little
 * documentation, where it has any at all, and it's likely that parts of its
 * interface may change (particularly regarding allocation).  That said, if you
 * truly need the functionality here, Truffle Decoder and Truffle Encoder can
 * perhaps serve as something of a reference implementation (and perhaps
 * Truffle Debugger as well, though that code is much harder to read or copy).
 *
 * @module @truffle/codec
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wrap = exports.Export = exports.Evm = exports.Conversion = exports.Contexts = exports.Compilations = exports.Compiler = exports.Ast = exports.AstConstant = exports.Storage = exports.Stack = exports.Special = exports.Memory = exports.MappingKey = exports.Topic = exports.AbiData = exports.Bytes = exports.Basic = exports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.NoProjectInfoError = exports.StopDecodingError = exports.DecodingError = exports.decodeRevert = exports.decodeReturndata = exports.decodeCalldata = exports.decodeEvent = exports.decodeVariable = exports.Format = void 0;
//So, what shall codec export...?
//First: export the data format
const Format = __importStar(__webpack_require__(429965));
exports.Format = Format;
//now... various low-level stuff we want to export!
//the actual decoding functions and related errors
var core_1 = __webpack_require__(632561);
Object.defineProperty(exports, "decodeVariable", ({ enumerable: true, get: function () { return core_1.decodeVariable; } }));
Object.defineProperty(exports, "decodeEvent", ({ enumerable: true, get: function () { return core_1.decodeEvent; } }));
Object.defineProperty(exports, "decodeCalldata", ({ enumerable: true, get: function () { return core_1.decodeCalldata; } }));
Object.defineProperty(exports, "decodeReturndata", ({ enumerable: true, get: function () { return core_1.decodeReturndata; } }));
Object.defineProperty(exports, "decodeRevert", ({ enumerable: true, get: function () { return core_1.decodeRevert; } }));
var errors_1 = __webpack_require__(672325);
Object.defineProperty(exports, "DecodingError", ({ enumerable: true, get: function () { return errors_1.DecodingError; } }));
Object.defineProperty(exports, "StopDecodingError", ({ enumerable: true, get: function () { return errors_1.StopDecodingError; } }));
Object.defineProperty(exports, "NoProjectInfoError", ({ enumerable: true, get: function () { return errors_1.NoProjectInfoError; } }));
__exportStar(__webpack_require__(299987), exports);
var abify_1 = __webpack_require__(57320);
Object.defineProperty(exports, "abifyCalldataDecoding", ({ enumerable: true, get: function () { return abify_1.abifyCalldataDecoding; } }));
Object.defineProperty(exports, "abifyLogDecoding", ({ enumerable: true, get: function () { return abify_1.abifyLogDecoding; } }));
Object.defineProperty(exports, "abifyReturndataDecoding", ({ enumerable: true, get: function () { return abify_1.abifyReturndataDecoding; } }));
// data locations - common
const Basic = __importStar(__webpack_require__(553928));
exports.Basic = Basic;
const Bytes = __importStar(__webpack_require__(767689));
exports.Bytes = Bytes;
// data locations - abi
const AbiData = __importStar(__webpack_require__(20907));
exports.AbiData = AbiData;
const Topic = __importStar(__webpack_require__(963196));
exports.Topic = Topic;
// data locations - solidity
const MappingKey = __importStar(__webpack_require__(514817));
exports.MappingKey = MappingKey;
const Memory = __importStar(__webpack_require__(635035));
exports.Memory = Memory;
const Special = __importStar(__webpack_require__(97859));
exports.Special = Special;
const Stack = __importStar(__webpack_require__(915385));
exports.Stack = Stack;
const Storage = __importStar(__webpack_require__(781037));
exports.Storage = Storage;
const AstConstant = __importStar(__webpack_require__(488132));
exports.AstConstant = AstConstant;
const Ast = __importStar(__webpack_require__(114442));
exports.Ast = Ast;
const Compiler = __importStar(__webpack_require__(884159));
exports.Compiler = Compiler;
const Compilations = __importStar(__webpack_require__(89752));
exports.Compilations = Compilations;
const Contexts = __importStar(__webpack_require__(697938));
exports.Contexts = Contexts;
const Conversion = __importStar(__webpack_require__(152714));
exports.Conversion = Conversion;
const Evm = __importStar(__webpack_require__(149218));
exports.Evm = Evm;
const Export = __importStar(__webpack_require__(915103));
exports.Export = Export;
const Wrap = __importStar(__webpack_require__(818479));
exports.Wrap = Wrap;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 899429:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mappingKeyAsHex = exports.encodeMappingKey = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:mapping-key:encode");
const Conversion = __importStar(__webpack_require__(152714));
const BasicEncode = __importStar(__webpack_require__(151561));
const BytesEncode = __importStar(__webpack_require__(553951));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * @Category Encoding (low-level)
 */
function encodeMappingKey(input) {
    if (input.type.typeClass === "string" ||
        (input.type.typeClass === "bytes" && input.type.kind === "dynamic")) {
        return BytesEncode.encodeBytes(input);
    }
    else {
        return BasicEncode.encodeBasic(input);
    }
}
exports.encodeMappingKey = encodeMappingKey;
/**
 * @Category Encoding (low-level)
 */
function mappingKeyAsHex(input) {
    return Conversion.toHexString(encodeMappingKey(input));
}
exports.mappingKeyAsHex = mappingKeyAsHex;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 514817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For encoding mapping keys
 *
 * @protected
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Encode = void 0;
const Encode = __importStar(__webpack_require__(899429));
exports.Encode = Encode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 359046:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSkippedInMemoryStructs = exports.getMemoryAllocations = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:memory:allocate");
const Evm = __importStar(__webpack_require__(149218));
function getMemoryAllocations(userDefinedTypes) {
    let allocations = {};
    for (const dataType of Object.values(userDefinedTypes)) {
        if (dataType.typeClass === "struct") {
            allocations[dataType.id] = allocateStruct(dataType);
        }
    }
    return allocations;
}
exports.getMemoryAllocations = getMemoryAllocations;
function isSkippedInMemoryStructs(dataType) {
    if (dataType.typeClass === "mapping") {
        return true;
    }
    else if (dataType.typeClass === "array") {
        return isSkippedInMemoryStructs(dataType.baseType);
    }
    else {
        return false;
    }
}
exports.isSkippedInMemoryStructs = isSkippedInMemoryStructs;
//unlike in storage and calldata, we'll just return the one allocation, nothing fancy
//that's because allocating one struct can never necessitate allocating another
function allocateStruct(dataType) {
    let memberAllocations = [];
    let position = 0;
    for (const { name, type: memberType } of dataType.memberTypes) {
        const length = isSkippedInMemoryStructs(memberType)
            ? 0
            : Evm.Utils.WORD_SIZE;
        memberAllocations.push({
            name,
            type: memberType,
            pointer: {
                location: "memory",
                start: position,
                length
            }
        });
        position += length;
    }
    return {
        members: memberAllocations
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 663540:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:memory:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const Format = __importStar(__webpack_require__(429965));
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const Evm = __importStar(__webpack_require__(149218));
const allocate_1 = __webpack_require__(359046);
const errors_1 = __webpack_require__(672325);
function* decodeMemory(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType)) {
        if (allocate_1.isSkippedInMemoryStructs(dataType)) {
            //special case; these types are always empty in memory
            return decodeMemorySkippedType(dataType);
        }
        else {
            return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);
        }
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
    }
}
exports.decodeMemory = decodeMemory;
function decodeMemorySkippedType(dataType) {
    switch (dataType.typeClass) {
        case "mapping":
            return {
                type: dataType,
                kind: "value",
                value: []
            };
        case "array":
            return {
                type: dataType,
                kind: "value",
                value: []
            };
        //other cases should not arise!
    }
}
function* decodeMemoryReferenceByAddress(dataType, pointer, info, options = {}) {
    const { state } = info;
    const memoryVisited = options.memoryVisited || [];
    debug("pointer %o", pointer);
    let rawValue;
    try {
        rawValue = yield* read_1.default(pointer, state);
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error);
    }
    let startPositionAsBN = Conversion.toBN(rawValue);
    let startPosition;
    try {
        startPosition = startPositionAsBN.toNumber();
    }
    catch (_a) {
        return {
            //again with the TS failures...
            type: dataType,
            kind: "error",
            error: {
                kind: "OverlargePointersNotImplementedError",
                pointerAsBN: startPositionAsBN
            }
        };
    }
    //startPosition may get modified later, so let's save the current
    //value for circularity detection purposes
    const objectPosition = startPosition;
    let rawLength;
    let lengthAsBN;
    let length;
    let seenPreviously;
    switch (dataType.typeClass) {
        case "bytes":
        case "string":
            //initial word contains length
            try {
                rawLength = yield* read_1.default({
                    location: "memory",
                    start: startPosition,
                    length: Evm.Utils.WORD_SIZE
                }, state);
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error);
            }
            lengthAsBN = Conversion.toBN(rawLength);
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_b) {
                return {
                    //again with the TS failures...
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let childPointer = {
                location: "memory",
                start: startPosition + Evm.Utils.WORD_SIZE,
                length
            };
            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);
        case "array": {
            //first: circularity check!
            seenPreviously = memoryVisited.indexOf(objectPosition);
            if (seenPreviously !== -1) {
                return {
                    type: dataType,
                    kind: "value",
                    reference: seenPreviously + 1,
                    value: [] //will be fixed later by the tie function
                };
            }
            //otherwise, decode as normal
            if (dataType.kind === "dynamic") {
                //initial word contains array length
                try {
                    rawLength = yield* read_1.default({
                        location: "memory",
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return errors_1.handleDecodingError(dataType, error);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                //to next word, as first word was used for length
            }
            else {
                lengthAsBN = dataType.length;
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_c) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let memoryNowVisited = [objectPosition, ...memoryVisited];
            let baseType = dataType.baseType;
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeMemory(baseType, {
                    location: "memory",
                    start: startPosition + index * Evm.Utils.WORD_SIZE,
                    length: Evm.Utils.WORD_SIZE
                }, info, { memoryVisited: memoryNowVisited }));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren
            };
        }
        case "struct": {
            //first: circularity check!
            seenPreviously = memoryVisited.indexOf(objectPosition);
            if (seenPreviously !== -1) {
                return {
                    type: dataType,
                    kind: "value",
                    reference: seenPreviously + 1,
                    value: [] //will be fixed later by the tie function
                };
            }
            //otherwise, decode as normal
            const { allocations: { memory: allocations } } = info;
            const typeId = dataType.id;
            const structAllocation = allocations[typeId];
            if (!structAllocation) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "UserDefinedTypeNotFoundError",
                        type: dataType
                    }
                };
            }
            debug("structAllocation %O", structAllocation);
            let memoryNowVisited = [objectPosition, ...memoryVisited];
            let decodedMembers = [];
            for (let index = 0; index < structAllocation.members.length; index++) {
                const memberAllocation = structAllocation.members[index];
                const memberPointer = memberAllocation.pointer;
                const childPointer = {
                    location: "memory",
                    start: startPosition + memberPointer.start,
                    length: memberPointer.length //always equals WORD_SIZE or 0
                };
                let memberName = memberAllocation.name;
                let memberType = Format.Types.specifyLocation(memberAllocation.type, "memory");
                decodedMembers.push({
                    name: memberName,
                    value: yield* decodeMemory(memberType, childPointer, info, {
                        memoryVisited: memoryNowVisited
                    })
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedMembers
            };
        }
    }
}
exports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 635035:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For allocation and decoding of memory data
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decode = exports.Allocate = void 0;
const Allocate = __importStar(__webpack_require__(359046));
exports.Allocate = Allocate;
const Decode = __importStar(__webpack_require__(663540));
exports.Decode = Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 887534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StorageRead = __importStar(__webpack_require__(165135));
const StackRead = __importStar(__webpack_require__(709940));
const BytesRead = __importStar(__webpack_require__(720281));
const AstConstantRead = __importStar(__webpack_require__(538130));
const TopicRead = __importStar(__webpack_require__(61352));
const SpecialRead = __importStar(__webpack_require__(595884));
const errors_1 = __webpack_require__(672325);
function* read(pointer, state) {
    switch (pointer.location) {
        case "stack":
            return StackRead.readStack(pointer, state);
        case "storage":
            return yield* StorageRead.readStorage(pointer, state);
        case "memory":
        case "calldata":
        case "eventdata":
        case "returndata":
            return BytesRead.readBytes(pointer, state);
        case "code":
            //keeping this separate
            return yield* BytesRead.readCode(pointer, state);
        case "stackliteral":
            return StackRead.readStackLiteral(pointer);
        case "definition":
            return AstConstantRead.readDefinition(pointer);
        case "special":
            return SpecialRead.readSpecial(pointer, state);
        case "eventtopic":
            return TopicRead.readTopic(pointer, state);
        case "nowhere":
            throw new errors_1.DecodingError({
                kind: "UnusedImmutableError"
            });
    }
}
exports["default"] = read;
//# sourceMappingURL=read.js.map

/***/ }),

/***/ 311002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeMagic = exports.decodeSpecial = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:special:decode");
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const Compiler = __importStar(__webpack_require__(884159));
const Evm = __importStar(__webpack_require__(149218));
function* decodeSpecial(dataType, pointer, info) {
    if (dataType.typeClass === "magic") {
        return yield* decodeMagic(dataType, pointer, info);
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
    }
}
exports.decodeSpecial = decodeSpecial;
function* decodeMagic(dataType, pointer, info) {
    let { state } = info;
    switch (pointer.special) {
        case "msg":
            return {
                type: dataType,
                kind: "value",
                value: {
                    data: yield* Bytes.Decode.decodeBytes({
                        typeClass: "bytes",
                        kind: "dynamic",
                        location: "calldata"
                    }, {
                        location: "calldata",
                        start: 0,
                        length: state.calldata.length
                    }, info),
                    sig: yield* Basic.Decode.decodeBasic({
                        typeClass: "bytes",
                        kind: "static",
                        length: Evm.Utils.SELECTOR_SIZE
                    }, {
                        location: "calldata",
                        start: 0,
                        length: Evm.Utils.SELECTOR_SIZE
                    }, info),
                    sender: yield* Basic.Decode.decodeBasic(senderType(info.currentContext.compiler), { location: "special", special: "sender" }, info),
                    value: yield* Basic.Decode.decodeBasic({
                        typeClass: "uint",
                        bits: 256
                    }, { location: "special", special: "value" }, info)
                }
            };
        case "tx":
            return {
                type: dataType,
                kind: "value",
                value: {
                    origin: yield* Basic.Decode.decodeBasic(senderType(info.currentContext.compiler), { location: "special", special: "origin" }, info),
                    gasprice: yield* Basic.Decode.decodeBasic({
                        typeClass: "uint",
                        bits: 256
                    }, { location: "special", special: "gasprice" }, info)
                }
            };
        case "block":
            let block = {
                coinbase: yield* Basic.Decode.decodeBasic(coinbaseType(info.currentContext.compiler), { location: "special", special: "coinbase" }, info)
            };
            //the other ones are all uint's, so let's handle them all at once; due to
            //the lack of generator arrow functions, we do it by mutating block
            const variables = ["difficulty", "gaslimit", "number", "timestamp"];
            if (solidityVersionHasChainId(info.currentContext.compiler)) {
                variables.push("chainid");
            }
            if (solidityVersionHasBaseFee(info.currentContext.compiler)) {
                variables.push("basefee");
            }
            for (let variable of variables) {
                block[variable] = yield* Basic.Decode.decodeBasic({
                    typeClass: "uint",
                    bits: 256
                }, { location: "special", special: variable }, info);
            }
            return {
                type: dataType,
                kind: "value",
                value: block
            };
    }
}
exports.decodeMagic = decodeMagic;
function senderType(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
            return {
                typeClass: "address",
                kind: "general"
            };
        case "0.5.x":
            return {
                typeClass: "address",
                kind: "specific",
                payable: true
            };
        default:
            return {
                typeClass: "address",
                kind: "specific",
                payable: false
            };
    }
}
function coinbaseType(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
            return {
                typeClass: "address",
                kind: "general"
            };
        case "0.5.x":
        case "0.8.x":
        case "0.8.7+":
        case "0.8.9+":
            return {
                typeClass: "address",
                kind: "specific",
                payable: true
            };
    }
}
function solidityVersionHasChainId(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
        case "0.5.x":
            return false;
        default:
            return true;
    }
}
function solidityVersionHasBaseFee(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
        case "0.5.x":
        case "0.8.x":
            return false;
        default:
            return true;
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97859:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For decoding of special/magic variables
 *
 * @protected
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(311002));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(595884));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 595884:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readSpecial = void 0;
function readSpecial(pointer, state) {
    //not bothering with error handling on this one as I don't expect errors
    return state.specials[pointer.special];
}
exports.readSpecial = readSpecial;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 873292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeLiteral = exports.decodeStack = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:stack:decode");
const AbiData = __importStar(__webpack_require__(20907));
const Conversion = __importStar(__webpack_require__(152714));
const Format = __importStar(__webpack_require__(429965));
const read_1 = __importDefault(__webpack_require__(887534));
const Basic = __importStar(__webpack_require__(553928));
const Memory = __importStar(__webpack_require__(635035));
const Storage = __importStar(__webpack_require__(781037));
const Evm = __importStar(__webpack_require__(149218));
const errors_1 = __webpack_require__(672325);
function* decodeStack(dataType, pointer, info) {
    let rawValue;
    try {
        rawValue = yield* read_1.default(pointer, info.state);
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error);
    }
    const literalPointer = {
        location: "stackliteral",
        literal: rawValue
    };
    return yield* decodeLiteral(dataType, literalPointer, info);
}
exports.decodeStack = decodeStack;
function* decodeLiteral(dataType, pointer, info) {
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    if (Format.Types.isReferenceType(dataType)) {
        switch (dataType.location) {
            case "memory":
                //first: do we have a memory pointer? if so we can just dispatch to
                //decodeMemoryReference
                return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);
            case "storage":
                //next: do we have a storage pointer (which may be a mapping)? if so, we can
                //we dispatch to decodeStorageByAddress
                return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);
            case "calldata":
                //next: do we have a calldata pointer?
                //if it's a lookup type, it'll need special handling
                if (dataType.typeClass === "bytes" ||
                    dataType.typeClass === "string" ||
                    (dataType.typeClass === "array" && dataType.kind === "dynamic")) {
                    const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));
                    const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, { location: "stackliteral", literal: locationOnly }, info, {
                        abiPointerBase: 0,
                        lengthOverride: lengthAsBN
                    });
                }
                else {
                    //multivalue case -- this case is straightforward
                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {
                        abiPointerBase: 0 //let's be explicit
                    });
                }
        }
    }
    //next: do we have an external function?  these work differently on the stack
    //than elsewhere, so we can't just pass it on to decodeBasic.
    if (dataType.typeClass === "function" && dataType.visibility === "external") {
        let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
        let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);
        if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) ||
            !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {
            return {
                type: dataType,
                kind: "error",
                error: {
                    kind: "FunctionExternalStackPaddingError",
                    rawAddress: Conversion.toHexString(address),
                    rawSelector: Conversion.toHexString(selectorWord)
                }
            };
        }
        let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);
        return {
            type: dataType,
            kind: "value",
            value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)
        };
    }
    //finally, if none of the above hold, we can just dispatch to decodeBasic.
    //however, note that because we're on the stack, we use the permissive padding
    //option so that errors won't result due to values with bad padding
    //(of numeric or bytesN type, anyway)
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {
        paddingMode: "permissive"
    });
}
exports.decodeLiteral = decodeLiteral;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 915385:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For decoding stack variables
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(873292));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(709940));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 709940:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readStackLiteral = exports.readStack = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:stack:read");
const Evm = __importStar(__webpack_require__(149218));
const errors_1 = __webpack_require__(672325);
function readStack(pointer, state) {
    let { from, to } = pointer;
    let { stack } = state;
    if (from < 0 || to >= stack.length) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorStack",
            from,
            to
        });
    }
    //unforunately, Uint8Arrays don't support concat; if they did the rest of
    //this would be one line.  Or similarly if they worked with lodash's flatten,
    //but they don't support that either.  But neither of those are the case, so
    //we'll have to concatenate a bit more manually.
    let words = stack.slice(from, to + 1);
    let result = new Uint8Array(words.length * Evm.Utils.WORD_SIZE);
    //shouldn't we total up the lengths? yeah, but each one should have a
    //length of 32, so unless somehting's gone wrong we can just multiply
    for (let index = 0; index < words.length; index++) {
        result.set(words[index], index * Evm.Utils.WORD_SIZE);
    }
    return result;
}
exports.readStack = readStack;
function readStackLiteral(pointer) {
    return pointer.literal;
}
exports.readStackLiteral = readStackLiteral;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 478976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:storage:allocate");
const Compiler = __importStar(__webpack_require__(884159));
const Common = __importStar(__webpack_require__(299987));
const Basic = __importStar(__webpack_require__(553928));
const Utils = __importStar(__webpack_require__(142526));
const Ast = __importStar(__webpack_require__(114442));
const Evm = __importStar(__webpack_require__(149218));
const Format = __importStar(__webpack_require__(429965));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const partition_1 = __importDefault(__webpack_require__(698069));
class UnknownBaseContractIdError extends Error {
    constructor(derivedId, derivedName, derivedKind, baseId) {
        const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;
        super(message);
        this.name = "UnknownBaseContractIdError";
        this.derivedId = derivedId;
        this.derivedName = derivedName;
        this.derivedKind = derivedKind;
        this.baseId = baseId;
    }
}
exports.UnknownBaseContractIdError = UnknownBaseContractIdError;
//contracts contains only the contracts to be allocated; any base classes not
//being allocated should just be in referenceDeclarations
function getStorageAllocations(userDefinedTypesByCompilation) {
    let allocations = {};
    for (const compilation of Object.values(userDefinedTypesByCompilation)) {
        const { compiler, types: userDefinedTypes } = compilation;
        for (const dataType of Object.values(compilation.types)) {
            if (dataType.typeClass === "struct") {
                try {
                    allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);
                }
                catch (_a) {
                    //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                    //note: a better way of handling this would probably be to *mark* it
                    //as failed rather than throwing an exception as that would lead to less
                    //recomputation, but this is simpler and I don't think the recomputation
                    //should really be a problem
                }
            }
        }
    }
    return allocations;
}
exports.getStorageAllocations = getStorageAllocations;
/**
 * This function gets allocations for the state variables of the contracts;
 * this is distinct from getStorageAllocations, which gets allocations for
 * storage structs.
 *
 * While mostly state variables are kept in storage, constant ones are not.
 * And immutable ones, once those are introduced, will be kept in code!
 * (But those don't exist yet so this function doesn't handle them yet.)
 */
function getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {
    let allocations = existingAllocations;
    for (const contractInfo of contracts) {
        let { contractNode: contract, immutableReferences, compiler, compilationId } = contractInfo;
        try {
            allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);
        }
        catch (_a) {
            //we're just going to allow failure here and catch the problem elsewhere
        }
    }
    return allocations;
}
exports.getStateAllocations = getStateAllocations;
function allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);
}
function allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {
    let offset = 0; //will convert to BN when placing in slot
    let index = Evm.Utils.WORD_SIZE - 1;
    //don't allocate things that have already been allocated
    if (parentId in existingAllocations) {
        return existingAllocations;
    }
    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    //otherwise, we need to allocate
    let memberAllocations = [];
    for (const member of members) {
        let size;
        ({ size, allocations } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler));
        //if it's sized in words (and we're not at the start of slot) we need to start on a new slot
        //if it's sized in bytes but there's not enough room, we also need a new slot
        if (Utils.isWordsLength(size)
            ? index < Evm.Utils.WORD_SIZE - 1
            : size.bytes > index + 1) {
            index = Evm.Utils.WORD_SIZE - 1;
            offset += 1;
        }
        //otherwise, we remain in place
        let range;
        if (Utils.isWordsLength(size)) {
            //words case
            range = {
                from: {
                    slot: {
                        offset: new bn_js_1.default(offset) //start at the current slot...
                    },
                    index: 0 //...at the beginning of the word.
                },
                to: {
                    slot: {
                        offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...
                    },
                    index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.
                }
            };
        }
        else {
            //bytes case
            range = {
                from: {
                    slot: {
                        offset: new bn_js_1.default(offset) //start at the current slot...
                    },
                    index: index - (size.bytes - 1) //...early enough to fit what's being allocated.
                },
                to: {
                    slot: {
                        offset: new bn_js_1.default(offset) //end at the current slot...
                    },
                    index: index //...at the current position.
                }
            };
        }
        memberAllocations.push({
            name: member.name,
            type: member.type,
            pointer: {
                location: "storage",
                range
            }
        });
        //finally, adjust the current position.
        //if it was sized in words, move down that many slots and reset position w/in slot
        if (Utils.isWordsLength(size)) {
            offset += size.words;
            index = Evm.Utils.WORD_SIZE - 1;
        }
        //if it was sized in bytes, move down an appropriate number of bytes.
        else {
            index -= size.bytes;
            //but if this puts us into the next word, move to the next word.
            if (index < 0) {
                index = Evm.Utils.WORD_SIZE - 1;
                offset += 1;
            }
        }
    }
    //finally, let's determine the overall siz; we're dealing with a struct, so
    //the size is measured in words
    //it's one plus the last word used, i.e. one plus the current word... unless the
    //current word remains entirely unused, then it's just the current word
    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how
    //empty structs behave in versions where they're legal)
    let totalSize;
    if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {
        totalSize = { words: offset };
    }
    else {
        totalSize = { words: offset + 1 };
    }
    //having made our allocation, let's add it to allocations!
    allocations[parentId] = {
        members: memberAllocations,
        size: totalSize
    };
    //...and we're done!
    return allocations;
}
function getStateVariables(contractNode) {
    // process for state variables
    return contractNode.nodes.filter((node) => node.nodeType === "VariableDeclaration" && node.stateVariable);
}
function allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {
    //we're going to do a 2-deep clone here
    let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(([compilationId, compilationAllocations]) => ({
        [compilationId]: Object.assign({}, compilationAllocations)
    })));
    if (!immutableReferences) {
        immutableReferences = {}; //also, let's set this up for convenience
    }
    //base contracts are listed from most derived to most base, so we
    //have to reverse before processing, but reverse() is in place, so we
    //clone with slice first
    let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse();
    //first, let's get all the variables under consideration
    let variables = [].concat(...linearizedBaseContractsFromBase.map((id) => {
        let baseNode = referenceDeclarations[id];
        if (baseNode === undefined) {
            throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);
        }
        return getStateVariables(baseNode).map(definition => ({
            definition,
            definedIn: baseNode
        }));
    }));
    //just in case the constant field ever gets removed
    const isConstant = (definition) => definition.constant || definition.mutability === "constant";
    //now: we split the variables into storage, constant, and code
    let [constantVariables, variableVariables] = partition_1.default(variables, variable => isConstant(variable.definition));
    //why use this function instead of just checking
    //definition.mutability?
    //because of a bug in Solidity 0.6.5 that causes the mutability field
    //not to exist.  So, we also have to check against immutableReferences.
    const isImmutable = (definition) => definition.mutability === "immutable" ||
        definition.id.toString() in immutableReferences;
    let [immutableVariables, storageVariables] = partition_1.default(variableVariables, variable => isImmutable(variable.definition));
    //transform storage variables into data types
    const storageVariableTypes = storageVariables.map(variable => ({
        name: variable.definition.name,
        type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)
    }));
    //let's allocate the storage variables using a fictitious ID
    const id = "-1";
    const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id];
    //transform to new format
    const storageVariableAllocations = storageVariables.map(({ definition, definedIn }, index) => ({
        definition,
        definedIn,
        compilationId,
        pointer: storageVariableStorageAllocations.members[index].pointer
    }));
    //now let's create allocations for the immutables
    let immutableVariableAllocations = immutableVariables.map(({ definition, definedIn }) => {
        let references = immutableReferences[definition.id.toString()] || [];
        let pointer;
        if (references.length === 0) {
            pointer = {
                location: "nowhere"
            };
        }
        else {
            pointer = {
                location: "code",
                start: references[0].start,
                length: references[0].length
            };
        }
        return {
            definition,
            definedIn,
            compilationId,
            pointer
        };
    });
    //and let's create allocations for the constants
    let constantVariableAllocations = constantVariables.map(({ definition, definedIn }) => ({
        definition,
        definedIn,
        compilationId,
        pointer: {
            location: "definition",
            definition: definition.value
        }
    }));
    //now, reweave the three together
    let contractAllocation = [];
    for (let variable of variables) {
        let arrayToGrabFrom = isConstant(variable.definition)
            ? constantVariableAllocations
            : isImmutable(variable.definition)
                ? immutableVariableAllocations
                : storageVariableAllocations;
        contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
    }
    //finally, set things and return
    if (!allocations[compilationId]) {
        allocations[compilationId] = {};
    }
    allocations[compilationId][contract.id] = {
        members: contractAllocation
    };
    return allocations;
}
//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.
//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,
//not to the wrapper, because it may need the allocations returned.
function storageSize(dataType, userDefinedTypes, allocations, compiler) {
    return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;
}
exports.storageSize = storageSize;
function storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {
    //we'll only directly handle reference types here;
    //direct types will be handled by dispatching to Basic.Allocate.byteLength
    //in the default case
    switch (dataType.typeClass) {
        case "bytes": {
            switch (dataType.kind) {
                case "static":
                    //really a basic type :)
                    return {
                        size: {
                            bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                        },
                        allocations: existingAllocations
                    };
                case "dynamic":
                    return {
                        size: { words: 1 },
                        allocations: existingAllocations
                    };
            }
        }
        case "string":
        case "mapping":
            return {
                size: { words: 1 },
                allocations: existingAllocations
            };
        case "array": {
            switch (dataType.kind) {
                case "dynamic":
                    return {
                        size: { words: 1 },
                        allocations: existingAllocations
                    };
                case "static":
                    //static array case
                    const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem
                    if (length === 0) {
                        //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word
                        return {
                            size: { words: 1 },
                            allocations: existingAllocations
                        };
                    }
                    let { size: baseSize, allocations } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);
                    if (!Utils.isWordsLength(baseSize)) {
                        //bytes case
                        const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                        debug("length %o", length);
                        const numWords = Math.ceil(length / perWord);
                        return {
                            size: { words: numWords },
                            allocations
                        };
                    }
                    else {
                        //words case
                        return {
                            size: { words: baseSize.words * length },
                            allocations
                        };
                    }
            }
        }
        case "struct": {
            let allocations = existingAllocations;
            let allocation = allocations[dataType.id]; //may be undefined!
            if (allocation === undefined) {
                //if we don't find an allocation, we'll have to do the allocation ourselves
                const storedType = (userDefinedTypes[dataType.id]);
                if (!storedType) {
                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                }
                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                allocation = allocations[dataType.id];
            }
            //having found our allocation, we can just look up its size
            return {
                size: allocation.size,
                allocations
            };
        }
        case "userDefinedValueType":
            if (Compiler.Utils.solidityFamily(compiler) === "0.8.7+") {
                //UDVTs were introduced in Solidity 0.8.8.  However, in that version,
                //and that version only, they have a bug where they always take up a
                //full word in storage regardless of the size of the underlying type.
                return {
                    size: { words: 1 },
                    allocations: existingAllocations
                };
            }
        //otherwise, treat them normally
        //DELIBERATE FALL-TRHOUGH
        default:
            //otherwise, it's a direct type
            return {
                size: {
                    bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                },
                allocations: existingAllocations
            };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 888569:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:storage:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Conversion = __importStar(__webpack_require__(152714));
const Format = __importStar(__webpack_require__(429965));
const Basic = __importStar(__webpack_require__(553928));
const Bytes = __importStar(__webpack_require__(767689));
const Utils = __importStar(__webpack_require__(142526));
const Evm = __importStar(__webpack_require__(149218));
const allocate_1 = __webpack_require__(478976);
const bn_js_1 = __importDefault(__webpack_require__(213550));
const errors_1 = __webpack_require__(672325);
function* decodeStorage(dataType, pointer, info) {
    if (Format.Types.isReferenceType(dataType)) {
        return yield* decodeStorageReference(dataType, pointer, info);
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
    }
}
exports.decodeStorage = decodeStorage;
//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.
//NOTE: ONLY for use with pointers to reference types!
//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...
function* decodeStorageReferenceByAddress(dataType, pointer, info) {
    const allocations = info.allocations.storage;
    let rawValue;
    try {
        rawValue = yield* read_1.default(pointer, info.state);
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error);
    }
    const startOffset = Conversion.toBN(rawValue);
    let rawSize;
    try {
        rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);
    }
    catch (error) {
        return errors_1.handleDecodingError(dataType, error);
    }
    //we *know* the type being decoded must be sized in words, because it's a
    //reference type, but TypeScript doesn't, so we'll have to use a type
    //coercion
    const size = rawSize.words;
    //now, construct the storage pointer
    const newPointer = {
        location: "storage",
        range: {
            from: {
                slot: {
                    offset: startOffset
                },
                index: 0
            },
            to: {
                slot: {
                    offset: startOffset.addn(size - 1)
                },
                index: Evm.Utils.WORD_SIZE - 1
            }
        }
    };
    //dispatch to decodeStorageReference
    return yield* decodeStorageReference(dataType, newPointer, info);
}
exports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;
function* decodeStorageReference(dataType, pointer, info) {
    var data;
    var length;
    const { state } = info;
    const allocations = info.allocations.storage;
    switch (dataType.typeClass) {
        case "array": {
            debug("storage array! %o", pointer);
            let lengthAsBN;
            switch (dataType.kind) {
                case "dynamic":
                    debug("dynamic array");
                    debug("type %O", dataType);
                    try {
                        data = yield* read_1.default(pointer, state);
                    }
                    catch (error) {
                        return errors_1.handleDecodingError(dataType, error);
                    }
                    lengthAsBN = Conversion.toBN(data);
                    break;
                case "static":
                    debug("static array");
                    lengthAsBN = dataType.length;
                    break;
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_a) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            debug("length %o", length);
            debug("about to determine baseSize");
            let baseSize;
            try {
                baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error);
            }
            debug("baseSize %o", baseSize);
            //we are going to make a list of child ranges, pushing them one by one onto
            //this list, and then decode them; the first part will vary based on whether
            //we're in the words case or the bytes case, the second will not
            let ranges = [];
            if (Utils.isWordsLength(baseSize)) {
                //currentSlot will point to the start of the entry being decoded
                let currentSlot = {
                    path: pointer.range.from.slot,
                    offset: new bn_js_1.default(0),
                    hashPath: dataType.kind === "dynamic"
                };
                for (let i = 0; i < length; i++) {
                    let childRange = {
                        from: {
                            slot: {
                                path: currentSlot.path,
                                offset: currentSlot.offset.clone(),
                                hashPath: currentSlot.hashPath
                            },
                            index: 0
                        },
                        to: {
                            slot: {
                                path: currentSlot.path,
                                offset: currentSlot.offset.addn(baseSize.words - 1),
                                hashPath: currentSlot.hashPath
                            },
                            index: Evm.Utils.WORD_SIZE - 1
                        }
                    };
                    ranges.push(childRange);
                    currentSlot.offset.iaddn(baseSize.words);
                }
            }
            else {
                const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                debug("perWord %d", perWord);
                //currentPosition will point to the start of the entry being decoded
                //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE
                let currentPosition = {
                    slot: {
                        path: pointer.range.from.slot,
                        offset: new bn_js_1.default(0),
                        hashPath: dataType.kind === "dynamic"
                    },
                    index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!
                };
                for (let i = 0; i < length; i++) {
                    let childRange = {
                        from: {
                            slot: {
                                path: currentPosition.slot.path,
                                offset: currentPosition.slot.offset.clone(),
                                hashPath: currentPosition.slot.hashPath
                            },
                            index: currentPosition.index
                        },
                        length: baseSize.bytes
                    };
                    ranges.push(childRange);
                    currentPosition.index -= baseSize.bytes;
                    if (currentPosition.index < 0) {
                        currentPosition.slot.offset.iaddn(1);
                        currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;
                    }
                }
            }
            let decodedChildren = [];
            for (let childRange of ranges) {
                decodedChildren.push(yield* decodeStorage(dataType.baseType, { location: "storage", range: childRange }, info));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren
            };
        }
        case "bytes":
        case "string": {
            try {
                data = yield* read_1.default(pointer, state);
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error);
            }
            let lengthByte = data[Evm.Utils.WORD_SIZE - 1];
            if (lengthByte % 2 == 0) {
                // string lives in word, length is last byte / 2
                length = lengthByte / 2;
                debug("in-word; length %o", length);
                return yield* Bytes.Decode.decodeBytes(dataType, {
                    location: "storage",
                    range: {
                        from: { slot: pointer.range.from.slot, index: 0 },
                        to: { slot: pointer.range.from.slot, index: length - 1 }
                    }
                }, info);
            }
            else {
                let lengthAsBN = Conversion.toBN(data)
                    .subn(1)
                    .divn(2);
                try {
                    length = lengthAsBN.toNumber();
                }
                catch (_b) {
                    return {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN
                        }
                    };
                }
                debug("new-word, length %o", length);
                return yield* Bytes.Decode.decodeBytes(dataType, {
                    location: "storage",
                    range: {
                        from: {
                            slot: {
                                path: pointer.range.from.slot,
                                offset: new bn_js_1.default(0),
                                hashPath: true
                            },
                            index: 0
                        },
                        length
                    }
                }, info);
            }
        }
        case "struct": {
            const typeId = dataType.id;
            const structAllocation = allocations[typeId];
            if (!structAllocation) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "UserDefinedTypeNotFoundError",
                        type: dataType
                    }
                };
            }
            let decodedMembers = [];
            const members = structAllocation.members;
            for (let index = 0; index < members.length; index++) {
                const memberAllocation = members[index];
                const memberPointer = memberAllocation.pointer;
                //the type system thinks memberPointer might also be a constant
                //definition pointer.  However, structs can't contain constants,
                //so *we* know it's not, and can safely coerce it.
                debug("pointer %O", pointer);
                const childRange = {
                    from: {
                        slot: {
                            path: pointer.range.from.slot,
                            offset: memberPointer.range.from.slot.offset.clone()
                            //note that memberPointer should have no path
                        },
                        index: memberPointer.range.from.index
                    },
                    to: {
                        slot: {
                            path: pointer.range.from.slot,
                            offset: memberPointer.range.to.slot.offset.clone()
                            //note that memberPointer should have no path
                        },
                        index: memberPointer.range.to.index
                    }
                };
                let storedType = info.userDefinedTypes[typeId];
                if (!storedType) {
                    return {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "UserDefinedTypeNotFoundError",
                            type: dataType
                        }
                    };
                }
                let storedMemberType = storedType.memberTypes[index].type;
                let memberType = Format.Types.specifyLocation(storedMemberType, "storage");
                decodedMembers.push({
                    name: memberAllocation.name,
                    value: yield* decodeStorage(memberType, { location: "storage", range: childRange }, info)
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedMembers
            };
        }
        case "mapping": {
            debug("decoding mapping");
            const valueType = dataType.valueType;
            let valueSize;
            try {
                valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);
            }
            catch (error) {
                return errors_1.handleDecodingError(dataType, error);
            }
            let decodedEntries = [];
            const baseSlot = pointer.range.from.slot;
            debug("baseSlot %o", baseSlot);
            debug("base slot address %o", Utils.slotAddress(baseSlot));
            const keySlots = info.mappingKeys.filter(({ path }) => Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path)));
            for (const { key } of keySlots) {
                let valuePointer;
                if (Utils.isWordsLength(valueSize)) {
                    valuePointer = {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: 0
                            },
                            to: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(valueSize.words - 1)
                                },
                                index: Evm.Utils.WORD_SIZE - 1
                            }
                        }
                    };
                }
                else {
                    valuePointer = {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: Evm.Utils.WORD_SIZE - valueSize.bytes
                            },
                            to: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: Evm.Utils.WORD_SIZE - 1
                            }
                        }
                    };
                }
                decodedEntries.push({
                    key,
                    value: yield* decodeStorage(valueType, valuePointer, info)
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedEntries
            };
        }
    }
}
exports.decodeStorageReference = decodeStorageReference;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 781037:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * For allocation and decoding of storage variables
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = exports.Allocate = exports.Utils = void 0;
__exportStar(__webpack_require__(618020), exports); //can't do 'export type *'
const Utils = __importStar(__webpack_require__(142526));
exports.Utils = Utils;
const Allocate = __importStar(__webpack_require__(478976));
exports.Allocate = Allocate;
const Decode = __importStar(__webpack_require__(888569));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(165135));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 165135:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readStorage = exports.readSlot = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:storage:read");
const Conversion = __importStar(__webpack_require__(152714));
const Utils = __importStar(__webpack_require__(142526));
const Evm = __importStar(__webpack_require__(149218));
const errors_1 = __webpack_require__(672325);
function* readSlot(storage, slot) {
    const address = Utils.slotAddress(slot);
    // debug("reading slot: %o", Conversion.toHexString(address));
    const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);
    let word = storage[hexAddress];
    //if we can't find the word in the map, we place a request to the invoker to supply it
    //(contract-decoder will look it up from the blockchain, while the debugger will just
    //say 0)
    if (word === undefined) {
        word = yield {
            type: "storage",
            slot: address
        };
    }
    return word;
}
exports.readSlot = readSlot;
function* readStorage(pointer, state) {
    const { storage } = state;
    const { range } = pointer;
    debug("readRange %o", range);
    let { from, to, length } = range;
    from = {
        slot: from.slot,
        index: from.index || 0
    };
    if (length !== undefined) {
        to = {
            slot: {
                path: from.slot.path || undefined,
                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))
            },
            index: (from.index + length - 1) % Evm.Utils.WORD_SIZE
        };
    }
    debug("normalized readRange %o", { from, to });
    let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);
    let totalWords;
    try {
        totalWords = totalWordsAsBN.toNumber();
    }
    catch (_) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorStorage",
            range
        });
    }
    let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);
    for (let i = 0; i < totalWords; i++) {
        let offset = from.slot.offset.addn(i);
        const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), { offset }));
        if (word === null) {
            //check for null as a way to deliberately indicate an error
            throw new errors_1.DecodingError({
                kind: "StorageNotSuppliedError",
                range
            });
        }
        data.set(word, i * Evm.Utils.WORD_SIZE);
    }
    debug("words %o", data);
    data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);
    debug("data: %o", data);
    return data;
}
exports.readStorage = readStorage;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 618020:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 142526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:storage:utils");
const Evm = __importStar(__webpack_require__(149218));
const MappingKey = __importStar(__webpack_require__(514817));
function isWordsLength(size) {
    return size.words !== undefined;
}
exports.isWordsLength = isWordsLength;
function storageLengthToBytes(size) {
    if (isWordsLength(size)) {
        debug("size.words %d", size.words);
        return size.words * Evm.Utils.WORD_SIZE;
    }
    else {
        return size.bytes;
    }
}
exports.storageLengthToBytes = storageLengthToBytes;
/**
 * convert a slot to a word corresponding to actual storage address
 *
 * if `slot` is an array, return hash of array values.
 * if `slot` array is nested, recurse on sub-arrays
 *
 * @param slot - number or possibly-nested array of numbers
 */
function slotAddress(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);
    }
    else if (slot.path !== undefined) {
        const pathAddress = slotAddress(slot.path);
        const path = slot.hashPath
            ? Evm.Utils.keccak256(pathAddress)
            : pathAddress;
        return path.add(slot.offset);
    }
    else {
        return slot.offset;
    }
}
exports.slotAddress = slotAddress;
//note: this function compares slots mostly by structure,
//rather than by their numerical value
function equalSlots(slot1, slot2) {
    if (!slot1 || !slot2) {
        return !slot1 && !slot2; //if either is undefined, it's true only if both are
    }
    if (!slot1.offset.eq(slot2.offset)) {
        return false;
    }
    if (slot1.hashPath !== slot2.hashPath) {
        return false;
    }
    if (!equalSlots(slot1.path, slot2.path)) {
        return false;
    }
    //to compare keys, we'll just compare their hex encodings
    //(yes, that leaves some wiggle room, as it could consider different
    //*types* of keys to be equal, but if keys are the only difference then
    //that should determine those types, so it shouldn't be a problem)
    if (!slot1.key || !slot2.key) {
        //first, though, they likely don't *have* keys
        return !slot1.key && !slot2.key;
    }
    //if they do have keys, though...
    return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));
}
exports.equalSlots = equalSlots;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 182243:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeTopic = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:topic:decode");
const read_1 = __importDefault(__webpack_require__(887534));
const Basic = __importStar(__webpack_require__(553928));
const Format = __importStar(__webpack_require__(429965));
const Conversion = __importStar(__webpack_require__(152714));
function* decodeTopic(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType) ||
        dataType.typeClass === "tuple") {
        //we cannot decode reference types "stored" in topics; we have to just return an error
        let bytes = yield* read_1.default(pointer, info.state);
        let raw = Conversion.toHexString(bytes);
        //NOTE: even in strict mode we want to just return this, not throw an error here
        return {
            //dunno why TS is failing here
            type: dataType,
            kind: "error",
            error: {
                kind: "IndexedReferenceTypeError",
                type: dataType,
                raw
            }
        };
    }
    //otherwise, dispatch to decodeBasic
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
}
exports.decodeTopic = decodeTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44804:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeTopic = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:topic:encode");
const Conversion = __importStar(__webpack_require__(152714));
const Evm = __importStar(__webpack_require__(149218));
const BasicEncode = __importStar(__webpack_require__(151561));
/**
 * Encodes for event topics (indexed parameters).
 * Warning: This function is not fully implemented yet!
 * @Category Encoding (low-level)
 */
function encodeTopic(input) {
    //errors can't be encoded
    if (input.kind === "error") {
        debug("input: %O", input);
        //...unless it's an IndexedReferenceTypeError, in which
        //case, let's read otu that raw data!
        if (input.error.kind === "IndexedReferenceTypeError") {
            return Conversion.toBytes(input.error.raw, Evm.Utils.WORD_SIZE);
        }
        else {
            return undefined;
        }
    }
    //otherwise, just dispath to encodeBasic
    return BasicEncode.encodeBasic(input);
    //...of course, really here we should be checking
    //whether the input *is* a basic type, and if not, handling
    //that appropriately!  But so far we don't need this, so this
    //part of the function isn't implemented yet
}
exports.encodeTopic = encodeTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 963196:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Encode = exports.Decode = void 0;
/**
 * For decoding of event topics
 *
 * @protected
 * @category ABI data location
 *
 * @packageDocumentation
 */
const Decode = __importStar(__webpack_require__(182243));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(44804));
exports.Encode = Encode;
const Read = __importStar(__webpack_require__(61352));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readTopic = void 0;
function readTopic(pointer, state) {
    //not bothering with error handling on this one as I don't expect errors
    return state.eventtopics[pointer.topic];
}
exports.readTopic = readTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8871:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addressCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:address");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Utils = __importStar(__webpack_require__(133272));
const EvmUtils = __importStar(__webpack_require__(559901));
const Messages = __importStar(__webpack_require__(153983));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
//no separate cases for contracts; even with loose turned off,
//we consider these interchangeable
const addressFromStringCases = [
    addressFromHexString,
    addressFromPrefixlessHexString,
    addressFromOtherString //Please put after other string cases! Also, can yield
];
const addressCasesBasic = [
    ...addressFromStringCases,
    addressFromBoxedString,
    addressFromContractInput,
    addressFromCodecAddressLikeValue,
    addressFromCodecUdvtValue,
    addressFailureCase
];
exports.addressCases = [addressFromTypeValueInput, ...addressCasesBasic];
function* addressFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isHexString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a 0x-prefixed hex string");
    }
    return validateNormalizeAndWrap(dataType, input, input, wrapOptions.name);
}
function* addressFromPrefixlessHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isPrefixlessHexString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an unprefixed hex string");
    }
    return validateNormalizeAndWrap(dataType, "0x" + input, input, wrapOptions.name);
}
function* addressFromOtherString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const request = { kind: "address", name: input };
    const response = yield request;
    if (response.kind !== "address") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.address === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason);
    }
    //we should be able to skip validation & normalization here
    return wrapAsAppropriateType(dataType, response.address);
}
function* addressFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, addressFromStringCases);
}
function* addressFromContractInput(dataType, input, wrapOptions) {
    if (!Utils.isContractInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a contract-like object");
    }
    return validateNormalizeAndWrap(dataType, input.address, input, wrapOptions.name);
}
function* addressFromCodecAddressLikeValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "address" &&
        input.type.typeClass !== "contract") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    let address;
    switch (input.type.typeClass) {
        case "address":
            address = input.value.asAddress;
            break;
        case "contract":
            address = input.value.address;
            break;
        //other cases are impossible at this point
    }
    //we should be able to skip validation/normalization here
    return wrapAsAppropriateType(dataType, address);
}
function* addressFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* addressFromCodecAddressLikeValue(dataType, input.value, wrapOptions);
}
function* addressFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "address" && input.type !== "contract") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), addressCasesBasic);
}
function* addressFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not recognizable as an address");
}
function validateAndNormalize(asAddress, dataType, //for errors
input, //for errors
name //for errors
) {
    if (!Utils.isByteString(asAddress)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.notABytestringMessage("Address"));
    }
    if (asAddress.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.wrongLengthMessage("address", EvmUtils.ADDRESS_SIZE, (asAddress.length - 2) / 2));
    }
    if (!web3_utils_1.default.isAddress(asAddress)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 6, //to beat the one from the yield case :P
        Messages.checksumFailedMessage);
    }
    //and normalize
    return web3_utils_1.default.toChecksumAddress(asAddress);
}
function wrapAsAppropriateType(dataType, asAddress) {
    //return address or contract value as appropriate
    switch (dataType.typeClass) {
        case "address":
            return {
                type: dataType,
                kind: "value",
                value: {
                    asAddress
                }
            };
        case "contract":
            return {
                type: dataType,
                kind: "value",
                value: {
                    kind: "unknown",
                    address: asAddress
                }
            };
    }
}
function validateNormalizeAndWrap(dataType, asAddress, input, //for errors
name //for errors
) {
    return wrapAsAppropriateType(dataType, validateAndNormalize(asAddress, dataType, input, name));
}
//# sourceMappingURL=address.js.map

/***/ }),

/***/ 356291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:bool");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Utils = __importStar(__webpack_require__(133272));
const Messages = __importStar(__webpack_require__(153983));
const boolCasesBasic = [
    boolFromString,
    boolFromBoxedPrimitive,
    boolFromCodecBoolValue,
    boolFromCodecBoolError,
    boolFromCodecUdvtValue,
    boolFromCodecUdvtError,
    boolFromOther //must go last!
];
exports.boolCases = [
    boolFromTypeValueInput,
    ...boolCasesBasic
];
function* boolFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    //strings are true unless they're falsy or the case-insensitive string "false"
    const asBoolean = Boolean(input) && input.toLowerCase() !== "false";
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        }
    };
}
function* boolFromBoxedPrimitive(dataType, input, wrapOptions) {
    if (!Utils.isBoxedPrimitive(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed primitive");
    }
    //unbox and try again
    return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, exports.boolCases);
}
function* boolFromCodecBoolValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to BoolError case
        Messages.errorResultMessage);
    }
    const asBoolean = input.value.asBoolean;
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        }
    };
}
function* boolFromCodecBoolError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a value rather than an error");
    }
    //these two error types will be regarded as true
    const allowedErrors = ["BoolOutOfRangeError", "BoolPaddingError"];
    if (!allowedErrors.includes(input.error.kind)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean: true
        }
    };
}
function* boolFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, disallowing type/value input
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), boolCasesBasic);
}
function* boolFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);
}
function* boolFromCodecUdvtError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a value rather than an error");
    }
    //wrapped errors will have to be unwrapped, others can be rejected
    if (input.error.kind !== "WrappedError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);
}
function* boolFromOther(dataType, input, wrapOptions) {
    //fallback case: just go by truthiness/falsiness
    //(this case has to be last because there are various other
    //cases we do not want to go by truthiness/falsiness!)
    if (Utils.isWrappedResult(input)) {
        //...except for these, which may error
        //(note that we do this even when loose is on!)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    if (Utils.isTypeValueInput(input)) {
        //...and these, which also may error
        //(note that we do this even when loose is on!)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a type/value pair");
    }
    const asBoolean = Boolean(input);
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        }
    };
}
//# sourceMappingURL=bool.js.map

/***/ }),

/***/ 162083:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateUint8ArrayLike = exports.bytesCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:bytes");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Conversion = __importStar(__webpack_require__(152714));
const Utils = __importStar(__webpack_require__(133272));
const Messages = __importStar(__webpack_require__(153983));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const bytesFromStringCases = [
    bytesFromHexString,
    bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!
];
const bytesCasesBasic = [
    ...bytesFromStringCases,
    bytesFromBoxedString,
    bytesFromUint8ArrayLike,
    bytesFromCodecBytesValue,
    bytesFromCodecUdvtValue,
    bytesFromEncodingTextInput,
    bytesFromNumber,
    bytesFromBoxedNumber,
    bytesFromBigint,
    bytesFromBN,
    bytesFromBig,
    bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!
];
exports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];
function* bytesFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const trimmed = Utils.removeUnderscoresHex(input);
    //(but not between individual hex digits)
    if (!Utils.isByteString(trimmed)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage("Input"));
    }
    const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromIntegerString(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //bigint accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage("Input"));
    }
    const trimmed = Utils.removeUnderscoresNumeric(input);
    let asBigInt;
    try {
        //we'll use BigInt to parse integer strings, as it's pretty good at it.
        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.
        asBigInt = BigInt(trimmed);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input string was not a byte string or integer string");
    }
    if (asBigInt < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(asBigInt);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //defer to primitive string cases
    return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);
}
function* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromEncodingTextInput(dataType, input, wrapOptions) {
    if (!Utils.isEncodingTextInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a in encoding/text form");
    }
    if (input.encoding !== "utf8") {
        //(the only allowed encoding :P )
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);
    }
    let asHex;
    try {
        asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);
    }
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromCodecBytesValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bytes") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        !(input.type.kind === "dynamic" && dataType.kind === "dynamic") &&
        !(input.type.kind === "static" &&
            dataType.kind === "static" &&
            input.type.length === dataType.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    let asHex = input.value.asHex;
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);
}
function* bytesFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^byte(s\d*)?$/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    debug("input.type: %s", input.type);
    //now: determine the specified length; we use "null" for dynamic
    //note that "byte" is allowed, with a length of 1
    let length = null;
    let match = input.type.match(/^bytes(\d+)$/);
    if (match) {
        length = Number(match[1]); //static case with specified number
    }
    else if (input.type === "byte") {
        //"byte" case; set length to 1
        length = 1;
    }
    //otherwise, it's dynamic, so leave it at the default of null
    debug("length: %o", length);
    //check: does the specified length match the data type length?
    if (!(length === null && dataType.kind === "dynamic") &&
        !(dataType.kind === "static" && length === dataType.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), bytesCasesBasic);
}
function* bytesFromNumber(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (!Number.isSafeInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);
    }
    if (input < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBoxedNumber(dataType, input, wrapOptions) {
    //skipping the wrapOptions.loose check, as that'll get checked
    //in bytesFromNumber
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* bytesFromBigint(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    if (input < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBN(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    if (input.isNeg()) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBig(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    if (Conversion.countDecimalPlaces(input) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (input.lt(0)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromOther(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        //outside of the dynamic-loose case, this is just a failure case
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring");
    }
    const request = { kind: "integer", input };
    const response = yield request;
    if (response.kind !== "integer") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason ||
            "Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring");
    }
    if (response.value < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(response.value);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function validateUint8ArrayLike(input, dataType, //for error information
name //for error information
) {
    //this function doesn't return anything, it just throws errors if something
    //goes wrong
    if (input instanceof Uint8Array) {
        return; //honest Uint8Arrays don't need checking
    }
    if (!Number.isSafeInteger(input.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, "Input is byte-array-like, but its length is not a safe integer");
    }
    if (input.length < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, "Input is byte-array-like, but its length is negative");
    }
    //check: is it actually like a Uint8Array?
    for (let index = 0; index < input.length; index++) {
        if (typeof input[index] !== "number" ||
            input[index] < 0 ||
            input[index] >= 256 ||
            !Number.isInteger(input[index])) {
            throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);
        }
    }
    //otherwise, we didn't throw any errors, so return
}
exports.validateUint8ArrayLike = validateUint8ArrayLike;
function validateAndPad(dataType, asHex, input, //for errors
name //for errors
) {
    asHex = asHex.toLowerCase();
    //if static, validate and pad
    if (dataType.kind === "static") {
        if ((asHex.length - 2) / 2 > dataType.length) {
            throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));
        }
        else {
            asHex = asHex.padEnd(dataType.length * 2 + 2, "00");
        }
    }
    return asHex;
}
//special case for ethers compatibility; represents 0 as 0x00 rather than 0x.
//only for numeric input in loose mode, in dynamic case, for compatibility; not
//for ordinary hex input, where the two are distinct!
function adjustZeroNumericInput(asHex) {
    return asHex === "0x" ? "0x00" : asHex;
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ 36902:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decimalCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:decimal");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Conversion = __importStar(__webpack_require__(152714));
const Utils = __importStar(__webpack_require__(133272));
const Messages = __importStar(__webpack_require__(153983));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const big_js_1 = __importDefault(__webpack_require__(107951));
//note: doesn't include UDVT case,
//or error case
const decimalFromWrappedValueCases = [
    decimalFromCodecDecimalValue,
    decimalFromCodecIntegerValue,
    decimalFromCodecEnumValue
];
const decimalCasesBasic = [
    decimalFromNumber,
    decimalFromString,
    decimalFromBoxedNumber,
    decimalFromBoxedString,
    decimalFromBigint,
    decimalFromBN,
    decimalFromBig,
    ...decimalFromWrappedValueCases,
    decimalFromCodecUdvtValue,
    decimalFromCodecEnumError,
    decimalFromOther //must go last!
];
exports.decimalCases = [decimalFromTypeValueInput, ...decimalCasesBasic];
function* decimalFromBig(dataType, input, wrapOptions) {
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    const asBig = input.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBN(dataType, input, wrapOptions) {
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    const asBig = Conversion.toBig(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBigint(dataType, input, wrapOptions) {
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    const asBig = Conversion.toBig(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const trimmed = input.trim(); //allow whitespace
    const stripped = Utils.removeUnderscoresNoHex(trimmed);
    let asBig;
    try {
        asBig = new big_js_1.default(stripped);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonNumericMessage);
    }
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromNumber(dataType, input, wrapOptions) {
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isFinite(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Numeric value is not finite");
    }
    if (!Utils.isSafeNumber(dataType, input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Given number is outside the safe range for this data type (possible loss of precision); use a numeric string, bigint, or big number class instead");
    }
    const asBig = new big_js_1.default(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* decimalFromString(dataType, input.valueOf(), wrapOptions);
}
function* decimalFromBoxedNumber(dataType, input, wrapOptions) {
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* decimalFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* decimalFromCodecDecimalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "fixed" && input.type.typeClass !== "ufixed") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (input.type.typeClass !== dataType.typeClass ||
            input.type.bits !== dataType.bits ||
            input.type.places !== dataType.places)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = input.value.asBig.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecIntegerValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "int" && input.type.typeClass !== "uint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = Conversion.toBig(input.value.asBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecEnumValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case
        Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = Conversion.toBig(input.value.numericAsBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecEnumError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Wrapped result was a value rather than an error");
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const coercedInput = input;
    //only one specific kind of error will be allowed
    if (coercedInput.error.kind !== "EnumOutOfRangeError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const asBig = Conversion.toBig(coercedInput.error.rawAsBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, decimalFromWrappedValueCases);
}
function* decimalFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^u?fixed(\d+(x\d+)?)?$/) && input.type !== "decimal") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    let bits, places;
    let typeClass;
    if (input.type === "decimal") {
        //vyper's decimal type corresponds to fixed168x10
        typeClass = "fixed";
        bits = 168;
        places = 10;
    }
    else {
        const [_0, typeClassTemporary, _2, bitsAsString, _4, placesAsString] = input.type.match(/^(u?fixed)((\d+)(x(\d+))?)?$/);
        //not all of the fields in this match are used, so we discard them into _n variables
        bits = bitsAsString ? Number(bitsAsString) : 128; //defaults to 128
        places = placesAsString ? Number(placesAsString) : 18; //defaults to 18
        typeClass = typeClassTemporary;
    }
    if (dataType.typeClass !== typeClass ||
        dataType.bits !== bits ||
        dataType.places !== places) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), decimalCasesBasic);
}
function* decimalFromOther(dataType, input, wrapOptions) {
    const request = { kind: "decimal", input };
    const response = yield request;
    if (response.kind !== "decimal") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));
    }
    const asBig = response.value.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function validate(dataType, asBig, input, //just for errors
name //for errors
) {
    if (Conversion.countDecimalPlaces(asBig) > dataType.places) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.tooPreciseMessage(dataType.places, Conversion.countDecimalPlaces(asBig)));
    }
    if (asBig.gt(Utils.maxValue(dataType)) ||
        asBig.lt(Utils.minValue(dataType))) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.outOfRangeMessage);
    }
}
//# sourceMappingURL=decimal.js.map

/***/ }),

/***/ 573898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapWithCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:dispatch");
const Format = __importStar(__webpack_require__(429965));
const errors_1 = __webpack_require__(674595);
function* wrapWithCases(dataType, input, wrapOptions, cases) {
    let bestError;
    const specificityFloor = wrapOptions.specificityFloor || 0;
    for (const caseFn of cases) {
        try {
            return yield* caseFn(dataType, input, Object.assign(Object.assign({}, wrapOptions), { specificityFloor: 0 }));
        }
        catch (error) {
            if (!(error instanceof errors_1.TypeMismatchError)) {
                //rethrow unexpected errors
                throw error;
            }
            else if (!bestError || error.specificity > bestError.specificity) {
                bestError = error;
            }
        }
    }
    //if we've made it this far, no case has matched
    if (bestError && bestError.specificity < specificityFloor) {
        bestError.specificity = specificityFloor; //mutating this should be fine, right?
    }
    throw bestError || new errors_1.TypeMismatchError(//last-resort error
    dataType, input, wrapOptions.name, specificityFloor, //it doesn't matter, but we'll make this error lowest specificity
    `Input for ${wrapOptions.name} was not recognizable as type ${Format.Types.typeStringWithoutLocation(dataType)}`);
    //(note: we don't actually want to rely on the last-resort error, we'll
    //instead prefer last-resort cases that just throw an error so we can get
    //more specific messages, but I'm including this anyway just to be certain)
}
exports.wrapWithCases = wrapWithCases;
//# sourceMappingURL=dispatch.js.map

/***/ }),

/***/ 674595:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;
const Format = __importStar(__webpack_require__(429965));
/**
 * This error indicates that no overloads matched when performing
 * overload resolution.  If there was only one plausible match,
 * a [[TypeMismatchError]] will be thrown instead.
 * @category Errors
 */
class NoOverloadsMatchedError extends Error {
    constructor(methods, inputs, userDefinedTypes) {
        const message = "Arguments provided did not match any overload";
        super(message);
        this.methods = methods;
        this.inputs = inputs;
        this.userDefinedTypes = userDefinedTypes;
        this.name = "NoOverloadsMatchedError";
    }
}
exports.NoOverloadsMatchedError = NoOverloadsMatchedError;
/**
 * This error indicates that multiple overloads matched during
 * overload resolution, but none of them was the unique best
 * overload.
 * @category Errors
 */
class NoUniqueBestOverloadError extends Error {
    constructor(resolutions) {
        const message = "Could not determine a unique best overload for the given arguments.  " +
            "Please specify the overload explicitly or give the arguments more explicit types.";
        super(message);
        this.resolutions = resolutions;
        this.name = "NoUniqueBestOverloadError";
    }
}
exports.NoUniqueBestOverloadError = NoUniqueBestOverloadError;
/**
 * This error indicates that the given input could not be recognized as the
 * type it was supposed to be.
 * @category Errors
 */
class TypeMismatchError extends Error {
    constructor(dataType, input, variableName, specificity, reason) {
        const message = `Could not interpret input for ${variableName} as type ${Format.Types.typeString(dataType)}.  Reason: ${reason}`;
        super(message);
        this.variableName = variableName;
        this.dataType = dataType;
        this.input = input;
        this.reason = reason;
        this.specificity = specificity;
        this.name = "TypeMismatchError";
    }
}
exports.TypeMismatchError = TypeMismatchError;
class BadResponseTypeError extends Error {
    constructor(request, response) {
        const message = `Got response type ${response.kind} to request type ${request.kind}`;
        super(message);
        this.request = request;
        this.response = response;
        this.name = "BadResponseTypeError";
    }
}
exports.BadResponseTypeError = BadResponseTypeError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 552181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionExternalCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:function");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Messages = __importStar(__webpack_require__(153983));
const Utils = __importStar(__webpack_require__(133272));
const EvmUtils = __importStar(__webpack_require__(559901));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const address_1 = __webpack_require__(8871);
const bytes_1 = __webpack_require__(162083);
const functionExternalCasesBasic = [
    functionFromFunctionExternalInput,
    functionFromHexString,
    functionFromCodecFunctionExternalValue,
    functionFailureCase
];
exports.functionExternalCases = [functionFromTypeValueInput, ...functionExternalCasesBasic];
function* functionFromFunctionExternalInput(dataType, input, wrapOptions) {
    if (!Utils.isFunctionExternalInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an object with address & selector");
    }
    const wrappedAddress = (yield* dispatch_1.wrapWithCases({ typeClass: "address", kind: "general" }, input.address, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.address`, specificityFloor: 5 }), address_1.addressCases));
    const address = wrappedAddress.value.asAddress;
    const wrappedSelector = yield* dispatch_1.wrapWithCases({ typeClass: "bytes", kind: "static", length: 4 }, input.selector, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.selector`, specificityFloor: 5 }), bytes_1.bytesCases);
    const selector = wrappedSelector.value.asHex;
    //note validation & normalization have already been performed
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        }
    };
}
function* functionFromCodecFunctionExternalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "function" ||
        input.type.visibility !== "external") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const coercedInput = input;
    const address = coercedInput.value.contract.address;
    const selector = coercedInput.value.selector;
    //we can skip validation & normalization here
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        }
    };
}
function* functionFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isByteString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Input was a string, but not a valid even-length hex string");
    }
    if (input.length !==
        2 + 2 * (EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongLengthMessage("external function was given as a string but", EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE, (input.length - 2) / 2));
    }
    let address = input
        .slice(0, EvmUtils.ADDRESS_SIZE * 2 + 2)
        .toLowerCase();
    const selector = "0x" + input.slice(EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase();
    //address & selector must now have the correct length, and we are deliberately *not*
    //checking the checksum on address in this case.  So, the only thing remaining
    //to do is to normalize address.
    address = web3_utils_1.default.toChecksumAddress(address);
    //...and return
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        }
    };
}
function* functionFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "function") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), functionExternalCasesBasic);
}
function* functionFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input should be one of: an object with address and selector; a 24-byte hex string; a type/value pair; or a wrapped external function");
}
//# sourceMappingURL=function.js.map

/***/ }),

/***/ 818479:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap");
const priority_1 = __webpack_require__(62131);
const errors_1 = __webpack_require__(674595);
Object.defineProperty(exports, "NoOverloadsMatchedError", ({ enumerable: true, get: function () { return errors_1.NoOverloadsMatchedError; } }));
Object.defineProperty(exports, "NoUniqueBestOverloadError", ({ enumerable: true, get: function () { return errors_1.NoUniqueBestOverloadError; } }));
Object.defineProperty(exports, "TypeMismatchError", ({ enumerable: true, get: function () { return errors_1.TypeMismatchError; } }));
Object.defineProperty(exports, "BadResponseTypeError", ({ enumerable: true, get: function () { return errors_1.BadResponseTypeError; } }));
__exportStar(__webpack_require__(674595), exports);
const wrap_1 = __webpack_require__(118400);
Object.defineProperty(exports, "wrap", ({ enumerable: true, get: function () { return wrap_1.wrap; } }));
__exportStar(__webpack_require__(710076), exports);
exports.Messages = __importStar(__webpack_require__(153983));
function* wrapMultiple(types, inputs, wrapOptions) {
    //just wrap the types in a tuple and defer to wrap()
    const combinedType = {
        typeClass: "tuple",
        memberTypes: types
    };
    debug("wrapping multiple");
    const wrappedTogether = (yield* wrap_1.wrap(combinedType, inputs, wrapOptions));
    return wrappedTogether.value.map(({ value }) => value);
}
exports.wrapMultiple = wrapMultiple;
//note: turns on loose
function* wrapForMethod(method, inputs, resolveOptions) {
    const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);
    return wrappingToResolution(method, wrapped);
}
exports.wrapForMethod = wrapForMethod;
function wrappingToResolution(method, wrapped) {
    if (wrapped.length > 0 &&
        wrapped[wrapped.length - 1].type.typeClass === "options") {
        //there's options
        const wrappedArguments = wrapped.slice(0, -1); //cut off options
        const options = wrapped[wrapped.length - 1]
            .value;
        return {
            method,
            arguments: wrappedArguments,
            options
        };
    }
    else {
        //no options
        return {
            method,
            arguments: wrapped,
            options: {}
        };
    }
}
//doesn't separate out options from arguments & doesn't turn on loose
function* wrapForMethodRaw(method, inputs, { userDefinedTypes, allowOptions }, loose = false) {
    debug("wrapping for method");
    if (method.inputs.length === inputs.length) {
        //no options case
        debug("no options");
        return yield* wrapMultiple(method.inputs, inputs, {
            userDefinedTypes,
            oldOptionsBehavior: true,
            loose,
            name: "<arguments>"
        });
    }
    else if (allowOptions && method.inputs.length === inputs.length - 1) {
        //options case
        debug("options");
        const inputsWithOptions = [
            ...method.inputs,
            { name: "<options>", type: { typeClass: "options" } }
        ];
        return yield* wrapMultiple(inputsWithOptions, inputs, {
            userDefinedTypes,
            oldOptionsBehavior: true,
            loose,
            name: "<arguments>"
        });
    }
    else {
        //invalid length case
        const orOneMore = allowOptions
            ? ` (or ${method.inputs.length + 1} counting transaction options)`
            : "";
        throw new errors_1.TypeMismatchError({ typeClass: "tuple", memberTypes: method.inputs }, inputs, "<arguments>", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);
    }
}
function* resolveAndWrap(methods, inputs, { userDefinedTypes, allowOptions }) {
    //despite us having a good system for overload resolution, we want to
    //use it as little as possible!  That's because using it means we don't
    //get great error messages.  As such, we're going to do a bunch to filter
    //things beforehand, so that we get good error messages.
    if (methods.length === 1) {
        //if there's only one possibility, we just defer to wrapForMethod
        //if we ignore error messages this is silly... but we're not!
        //this is important for good error messages in this case
        return yield* wrapForMethod(methods[0], inputs, {
            userDefinedTypes,
            allowOptions
        });
    }
    //OK, so, there are multiple possibilities then.  let's try to filter things down by length.
    const possibleMatches = methods.filter(method => method.inputs.length === inputs.length);
    //but, we've also got to account for the possibility of options
    let possibleMatchesWithOptions = [];
    let possibleOptions = {};
    if (allowOptions && inputs.length > 0) {
        //if options are allowed, we'll have to account for that.
        //*however*, in order to minimize the number of possibilities, we won't
        //use these unless the last argument of inputs actually looks like an options!
        const lastInput = inputs[inputs.length - 1];
        let isOptionsPossible = true;
        try {
            const wrappedOptions = (yield* wrap_1.wrap({ typeClass: "options" }, lastInput, {
                name: "<options>",
                loose: true,
                oldOptionsBehavior: true,
                userDefinedTypes
            }));
            possibleOptions = wrappedOptions.value;
        }
        catch (error) {
            if (error instanceof errors_1.TypeMismatchError) {
                isOptionsPossible = false;
            }
            else {
                throw error; //rethrow unexpected errors
            }
        }
        if (isOptionsPossible) {
            possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);
        }
    }
    debug("possibleMatches: %o", possibleMatches);
    debug("possibleMatchesWithOptions: %o", possibleMatchesWithOptions);
    //if there's now only one possibility, great!
    if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {
        //only one possibility, no options. we can just defer to wrapMultiple.
        //(again, point is to have good error messaging)
        debug("only one possibility, no options");
        const method = possibleMatches[0];
        return {
            method,
            arguments: yield* wrapMultiple(method.inputs, inputs, {
                userDefinedTypes,
                loose: true,
                name: "<arguments>"
            }),
            options: {}
        };
    }
    else if (possibleMatchesWithOptions.length === 1 &&
        possibleMatches.length === 0) {
        //only one possibility, with options.  moreover, we already determined the options
        //above, so we can once again just defer to wrapMultiple
        debug("only one possiblity, with options");
        const method = possibleMatchesWithOptions[0];
        return {
            method,
            arguments: yield* wrapMultiple(method.inputs, inputs, {
                userDefinedTypes,
                loose: true,
                name: "<arguments>"
            }),
            options: possibleOptions
        };
    }
    else if (possibleMatches.length === 0 &&
        possibleMatchesWithOptions.length === 0) {
        debug("no possibilities");
        //nothing matches!
        throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);
    }
    //if all of our attempts to avoid it have failed, we'll have to actually use
    //our overload resolution system. note how we do *not* turn on loose in this
    //case!
    debug("attempting overload resolution");
    let resolutions = [];
    for (const method of methods) {
        let wrapped;
        try {
            //note this part takes care of options for us...
            //although yes this means options will be re-wrapped, oh well
            wrapped = yield* wrapForMethodRaw(method, inputs, {
                userDefinedTypes,
                allowOptions
            });
        }
        catch (error) {
            //if there's an error, don't add it
            debug("failed: %O", method);
            debug("because: %O", error);
            continue;
        }
        //note that options and arguments here are both not correct, but we'll
        //fix them up later!
        debug("adding: %O", method);
        resolutions.push({ method, arguments: wrapped, options: {} });
    }
    //now: narrow it down to the most specific one(s)
    debug("resolutions: %O", resolutions);
    resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !priority_1.isMoreSpecificMultiple(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) ||
        //because the comparison is nonstrict, this comparison is added to
        //effectively make it strict
        // i.e. we have !(x<=y) but we want !(x<y), i.e.,
        // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),
        // i.e., !(x<=y) | y<=x
        priority_1.isMoreSpecificMultiple(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));
    debug("resolutions remaining: %O", resolutions);
    switch (resolutions.length) {
        case 0:
            //no resolution worked
            throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);
        case 1:
            //there was a most specific resolution; fix up options and arguments
            //before returning
            const { method, arguments: wrapped } = resolutions[0];
            return wrappingToResolution(method, wrapped);
        default:
            //no unique most-specific resolution
            throw new errors_1.NoUniqueBestOverloadError(resolutions);
    }
}
exports.resolveAndWrap = resolveAndWrap;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 547779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integerCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:integer");
const Format = __importStar(__webpack_require__(429965));
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const Conversion = __importStar(__webpack_require__(152714));
const Utils = __importStar(__webpack_require__(133272));
const Messages = __importStar(__webpack_require__(153983));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const big_js_1 = __importDefault(__webpack_require__(107951));
const bytes_1 = __webpack_require__(162083);
//NOTE: all cases called "integerFrom..." also work for enums.
//The cases labeled "enumFrom..." work only for enums.
//there are no cases that work only for integers and not enums,
//because we always want input for integers to also be valid for enums.
const integerFromStringCases = [
    integerFromIntegerString,
    enumFromNameString,
    integerFromScientificOrUnits,
    integerFromNegatedBaseString,
    integerFromStringFailureCase
];
//note: doesn't include UDVT case,
//or error case
const integerFromWrappedValueCases = [
    integerFromCodecIntegerValue,
    integerFromCodecEnumValue,
    integerFromCodecDecimalValue
];
const integerCasesBasic = [
    ...integerFromStringCases,
    integerFromNumber,
    integerFromBoxedNumber,
    integerFromBoxedString,
    integerFromBigint,
    integerFromBN,
    integerFromBig,
    integerFromUint8ArrayLike,
    ...integerFromWrappedValueCases,
    integerFromCodecEnumError,
    integerFromCodecUdvtValue,
    integerFromOther //must go last!
];
exports.integerCases = [
    integerFromIntegerTypeValueInput,
    enumFromEnumTypeValueInput,
    ...integerCasesBasic
];
function* integerFromIntegerString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //bigint accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, dataType.typeClass === "enum"
            ? Messages.badEnumMessage
            : Messages.nonNumericMessage);
    }
    const stripped = Utils.removeUnderscoresNumeric(input);
    let asBN;
    try {
        //we'll use BigInt to parse integer strings, as it's pretty good at it.
        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.
        const asBigInt = BigInt(stripped);
        asBN = Conversion.toBN(asBigInt);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input string was not an integer string");
    }
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
//this case handles both scientific notation, and numbers with units
function* integerFromScientificOrUnits(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //the code below accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 since it's already specificity 5 above
        dataType.typeClass === "enum"
            ? Messages.badEnumMessage
            : Messages.nonNumericMessage);
    }
    const stripped = Utils.removeUnderscoresNoHex(input);
    let [_, quantityString, unit] = stripped.match(/^(.*?)(|wei|gwei|shannon|finney|szabo|ether)\s*$/i); //units will be case insensitive; note this always matches
    quantityString = quantityString.trim(); //Big rejects whitespace, let's allow it
    const unitPlacesTable = {
        //we could accept all of web3's units here, but, that's a little much;
        //we'll just accept the most common ones
        "": 0,
        wei: 0,
        gwei: 9,
        shannon: 9,
        szabo: 12,
        finney: 15,
        ether: 18
    };
    let quantity;
    try {
        quantity = quantityString.match(/^\s*$/)
            ? new big_js_1.default(1) //allow just "ether" e.g.
            : new big_js_1.default(quantityString);
    }
    catch (_a) {
        quantity = null;
    }
    if (quantity === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string using scientific notation or units");
    }
    const places = unitPlacesTable[unit.toLowerCase()];
    const asBig = Conversion.shiftBigUp(quantity, places);
    if (Conversion.countDecimalPlaces(asBig) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, unit !== ""
            ? "Input numeric value was not an integral number of wei"
            : Messages.nonIntegerMessage);
    }
    const asBN = Conversion.toBN(asBig);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromNegatedBaseString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!input.match(/^\s*-/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a negated numeric string");
    }
    const stripped = Utils.removeUnderscoresNumeric(input);
    let positiveAsBN;
    const [_, positiveString] = stripped.match(/^\s*-(.*)$/);
    try {
        const positive = BigInt(positiveString);
        positiveAsBN = Conversion.toBN(positive);
    }
    catch (_a) {
        positiveAsBN = null;
    }
    if (positiveAsBN === null ||
        positiveString === "" ||
        positiveString.match(/^(-|\s)/)) {
        //no double negation, no bare "-", and no space after the minus!
        //(we do this as a string check, rather than checking if
        //positiveAsBN is >=0, in order to prevent entering e.g. "--" or "- 2")
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);
    }
    const asBN = positiveAsBN.neg();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* enumFromNameString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (dataType.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);
    }
    const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
    const options = fullType.options;
    const components = input.split(".");
    const finalComponent = components[components.length - 1];
    debug("components: %O", components);
    debug("dataType: %O", dataType);
    debug("options: %O", options);
    //the enum can be qualified.  if it's qualified, does the type match?
    let matchingType;
    switch (components.length) {
        case 1:
            //not qualified, automatically matches
            matchingType = true;
            break;
        case 2:
            //qualified by type name, does it match?
            matchingType = components[0] === dataType.typeName;
            break;
        case 3:
            //qualified by type name and contract name, does it match?
            matchingType =
                dataType.kind === "local" &&
                    components[0] === dataType.definingContractName &&
                    components[1] === dataType.typeName;
            break;
        default:
            //no valid reason to have 3 or more periods
            //(and split cannot return an empty array)
            matchingType = false;
    }
    debug("matchingType: %O", matchingType);
    const numeric = matchingType ? options.indexOf(finalComponent) : -1; //if type doesn't match, just indicate error
    debug("numeric: %d", numeric);
    if (numeric === -1) {
        //-1 comes from either our setting it manually above to indicate error,
        //or from a failed indexOf call
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.badEnumMessage);
    }
    const asBN = new bn_js_1.default(numeric); //whew!
    //now: unlike in every other case, we can skip validation!
    //so let's just wrap and return!
    return {
        type: dataType,
        kind: "value",
        value: {
            numericAsBN: asBN,
            name: finalComponent //we know it matches!
        }
    };
}
function* integerFromStringFailureCase(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, dataType.typeClass === "enum"
        ? Messages.badEnumMessage
        : Messages.nonNumericMessage);
}
function* integerFromBN(dataType, input, wrapOptions) {
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    const asBN = input.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBigint(dataType, input, wrapOptions) {
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    const asBN = Conversion.toBN(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromNumber(dataType, input, wrapOptions) {
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (!Number.isSafeInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);
    }
    const asBN = new bn_js_1.default(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBig(dataType, input, wrapOptions) {
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    if (Conversion.countDecimalPlaces(input) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    const asBN = Conversion.toBN(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    bytes_1.validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    const asBN = Conversion.toBN(new Uint8Array(input)); //I am surprised TS accepts this!
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBoxedNumber(dataType, input, wrapOptions) {
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* integerFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* integerFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, integerFromStringCases);
}
function* integerFromCodecIntegerValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "int" && input.type.typeClass !== "uint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (input.type.typeClass !== dataType.typeClass ||
            input.type.bits !== dataType.bits)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = input.value.asBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecDecimalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "fixed" && input.type.typeClass !== "ufixed") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = Conversion.toBN(input.value.asBig);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecEnumValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case
        Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (dataType.typeClass !== "enum" || input.type.id !== dataType.id)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = input.value.numericAsBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecEnumError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Wrapped result was a value rather than an error");
    }
    if (!wrapOptions.loose &&
        (dataType.typeClass !== "enum" || input.type.id !== dataType.id)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const coercedInput = input;
    //only one specific kind of error will be allowed
    if (coercedInput.error.kind !== "EnumOutOfRangeError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const asBN = coercedInput.error.rawAsBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, integerFromWrappedValueCases);
}
function* integerFromIntegerTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^u?int\d*$/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === "enum" ? 1 : 5, 
        //use specificity 5 when getting an integer (which have no alternative),
        //but specificity 1 when getting an enum (which have enum type/value input also)
        Messages.specifiedTypeMessage(input.type));
    }
    const [_, typeClass, bitsAsString] = input.type.match(/^(u?int)(\d*)$/);
    const bits = bitsAsString ? Number(bitsAsString) : 256; //defaults to 256
    //(not using the WORD_SIZE constant due to fixed types bringing its applicability
    //here into question)
    const requiredTypeClass = dataType.typeClass !== "enum" ? dataType.typeClass : "uint"; //allow underlying uint type to work for enums
    //(we handle "enum" given as type in a separate case below)
    const requiredBits = dataType.typeClass !== "enum"
        ? dataType.bits
        : 8 *
            Math.ceil(Math.log2((Format.Types.fullType(dataType, wrapOptions.userDefinedTypes)).options.length) / 8); //compute required bits for enum type (sorry)
    if (requiredTypeClass !== typeClass || requiredBits !== bits) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic);
}
function* enumFromEnumTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === "enum" ? 5 : 1, 
        //use specificity 5 when getting an enum (which will have also failed integer type/value input),
        //but specificity 1 when getting an integer (to which this doesn't really apply)
        Messages.specifiedTypeMessage(input.type));
    }
    if (dataType.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    //(we'll also coerce the type on this one since we know it's
    //going to be an enum value :P )
    return (yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic));
}
function* integerFromOther(dataType, input, wrapOptions) {
    const request = { kind: "integer", input };
    const response = yield request;
    if (response.kind !== "integer") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));
    }
    const asBN = Conversion.toBN(response.value);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function validateAndWrap(dataType, asBN, wrapOptions, input //just for erroring
) {
    switch (dataType.typeClass) {
        case "uint":
            if (asBN.isNeg() || asBN.bitLength() > dataType.bits) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN
                }
            };
        case "int":
            if ((!asBN.isNeg() && asBN.bitLength() >= dataType.bits) || //>= since signed
                (asBN.isNeg() && asBN.neg().subn(1).bitLength() >= dataType.bits)
            //bitLength doesn't work great for negatives so we do this instead
            ) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN
                }
            };
        case "enum":
            const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
            if (asBN.isNeg() || asBN.gten(fullType.options.length)) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeEnumMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    numericAsBN: asBN,
                    name: fullType.options[asBN.toNumber()]
                }
            };
    }
}
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ 153983:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unrecognizedNumberMessage = exports.wrongLengthMessage = exports.notABytestringMessage = exports.tooPreciseMessage = exports.overlongMessage = exports.specifiedTypeMessage = exports.wrappedTypeMessage = exports.negativeBytesMessage = exports.looseModeOnlyMessage = exports.invalidUtf16Message = exports.checksumFailedMessage = exports.outOfRangeEnumMessage = exports.outOfRangeMessage = exports.badEnumMessage = exports.nonSafeMessage = exports.nonNumericMessage = exports.nonIntegerMessage = exports.notAStringMessage = exports.errorResultMessage = exports.wrongArrayLengthMessage = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:messages");
const Format = __importStar(__webpack_require__(429965));
function wrongArrayLengthMessage(expected, got) {
    return `Incorrect array length (expected ${expected.toString()} entries, got ${got})`;
}
exports.wrongArrayLengthMessage = wrongArrayLengthMessage;
exports.errorResultMessage = "Input is a wrapped result representing an error rather than a value";
exports.notAStringMessage = "Input was not a string, type/value pair, or wrapped or boxed string";
exports.nonIntegerMessage = "Input numeric value was not an integer";
exports.nonNumericMessage = "Input string was not numeric";
exports.nonSafeMessage = "Input number is not a Javascript safe integer";
exports.badEnumMessage = "Input string was neither numeric nor a valid enum value";
exports.outOfRangeMessage = "Input is outside the range of this numeric type";
exports.outOfRangeEnumMessage = "Input is outside the range of this enum type";
exports.checksumFailedMessage = "Address checksum failed (use all lowercase or all uppercase to circumvent)";
exports.invalidUtf16Message = "Input string was not valid UTF-16";
exports.looseModeOnlyMessage = "Numeric input for bytes is only allowed in loose mode and only for dynamic-length bytestrings";
exports.negativeBytesMessage = "Input for bytes cannot be negative";
function wrappedTypeMessage(dataType) {
    return `Input is a wrapped value of type ${Format.Types.typeString(dataType)}`;
}
exports.wrappedTypeMessage = wrappedTypeMessage;
function specifiedTypeMessage(dataType) {
    return `Input had type explicitly specified as ${dataType}`;
}
exports.specifiedTypeMessage = specifiedTypeMessage;
function overlongMessage(expected, got) {
    return `Input is too long for type (expected ${expected} bytes, got ${got} bytes)`;
}
exports.overlongMessage = overlongMessage;
function tooPreciseMessage(expected, got) {
    return `Input has too many decimal places for type (expected ${expected} decimal places, got ${got} decimal places)`;
}
exports.tooPreciseMessage = tooPreciseMessage;
function notABytestringMessage(what) {
    return `${what} is not a valid bytestring (even-length hex string)`;
}
exports.notABytestringMessage = notABytestringMessage;
function wrongLengthMessage(what, expected, got) {
    return `Input ${what} was ${got} bytes instead of ${expected} bytes`;
}
exports.wrongLengthMessage = wrongLengthMessage;
function unrecognizedNumberMessage(dataType) {
    const enumMessage = dataType.typeClass === "enum"
        ? "enum value name, "
        : "";
    const byteArrayMessage = dataType.typeClass !== "fixed" && dataType.typeClass !== "ufixed"
        ? "byte-array-like, "
        : "";
    return `Input was not a number, big integer, numeric string, ${enumMessage}type/value pair, boxed number, ${byteArrayMessage}wrapped number or enum, or recognized big number class`;
}
exports.unrecognizedNumberMessage = unrecognizedNumberMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 62131:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:priority");
const Format = __importStar(__webpack_require__(429965));
const utils_1 = __webpack_require__(133272);
//is input 1 more specific than input 2? (nonstrict)
function isMoreSpecificMultiple(types1, types2, userDefinedTypes) {
    //just wrap the types in tuples and defer to isMoreSpecific()
    const combinedType1 = {
        typeClass: "tuple",
        memberTypes: types1
    };
    const combinedType2 = {
        typeClass: "tuple",
        memberTypes: types2
    };
    return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true);
    //that last flag is so we ignore variable names at top level
}
exports.isMoreSpecificMultiple = isMoreSpecificMultiple;
//is input 1 more specific than input 2?
//(this is nonstrict)
function isMoreSpecific(type1, type2, userDefinedTypes, ignoreComponentNames = false //this flag is *not* applied recursively!
) {
    //udvts get priority of underlying type!
    if (type1.typeClass === "userDefinedValueType") {
        type1 = getUnderlyingType(type1, userDefinedTypes);
    }
    if (type2.typeClass === "userDefinedValueType") {
        type2 = getUnderlyingType(type2, userDefinedTypes);
    }
    const typeClasses = [
        ["options"],
        ["array"],
        ["struct", "tuple"],
        ["address", "contract"],
        ["bytes"],
        ["function"],
        ["uint", "int", "fixed", "ufixed"],
        ["enum"],
        ["string"],
        ["bool"]
    ];
    //for each type, what's the first one it counts as?
    const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));
    const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass));
    //NOTE: I am assuming neither will be -1!
    //If either is, something has gone very wrong!
    if (index1 < index2) {
        return true;
    }
    else if (index2 < index1) {
        return false;
    }
    //otherwise, indices are equal, defer to tiebreaker
    switch (type1.typeClass) {
        case "options":
            return isMoreSpecificOptions(type1, type2);
        case "address":
        case "contract":
            return isMoreSpecificAddress(type1, type2);
        case "function":
            return isMoreSpecificFunction(
            //we haven't actually checked visibility, so we'll have to coerce
            type1, type2, userDefinedTypes);
        case "array":
            return isMoreSpecificArray(type1, type2, userDefinedTypes);
        case "bytes":
            return isMoreSpecificBytes(type1, type2);
        case "uint":
        case "int":
        case "fixed":
        case "ufixed":
            return isMoreSpecificNumeric(type1, type2);
        case "enum":
            return isMoreSpecificEnum(type1, type2);
        case "string":
            return isMoreSpecificString(type1, type2);
        case "struct":
        case "tuple":
            return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);
        case "bool":
            return isMoreSpecificBool(type1, type2);
    }
}
exports.isMoreSpecific = isMoreSpecific;
function isMoreSpecificAddress(type1, type2) {
    //address payable more specific than address
    //contract types more specific than address
    //*payable* contract types more specific than address payable
    if (type1.typeClass === "address" && type2.typeClass === "address") {
        if (type1.kind === "specific" && type2.kind === "specific") {
            return type1.payable || !type2.payable;
        }
        else if (type2.kind === "general") {
            //specific is more specific than general :P
            return true;
        }
    }
    if (type1.typeClass === "contract" && type2.typeClass === "contract") {
        if (type1.kind === "native" && type2.kind === "native") {
            return type1.id === type2.id;
        } //foreign contract types will always be incomparable, I guess?
        //(they shouldn't come up here anyway)
    }
    if (type1.typeClass === "contract" && type2.typeClass === "address") {
        return (type2.kind === "general" ||
            (type2.kind === "specific" && !type2.payable) ||
            (type2.kind === "specific" && type1.payable));
    }
    return false; //otherwise
}
function isMoreSpecificBytes(type1, type2) {
    //static more specific than dynamic, with shorter
    //lengths more specific than longer ones
    return ((type1.kind === "dynamic" && type2.kind === "dynamic") ||
        (type1.kind === "static" && type2.kind === "dynamic") ||
        (type1.kind === "static" &&
            type2.kind === "static" &&
            type1.length <= type2.length));
}
function isMoreSpecificNumeric(type1, type2) {
    return (utils_1.maxValue(type1).lte(utils_1.maxValue(type2)) &&
        utils_1.minValue(type1).gte(utils_1.minValue(type2)) &&
        utils_1.places(type1) <= utils_1.places(type2) &&
        //note: I don't know whether this final bit is actually necessary
        //since we don't actually know yet whether fixedNx0 will be legal
        !((type1.typeClass === "fixed" || type1.typeClass === "ufixed") &&
            (type2.typeClass === "int" || type2.typeClass === "uint")));
}
function isMoreSpecificEnum(type1, type2) {
    //different enum types are incomparable
    return type1.id === type2.id;
}
function isMoreSpecificString(_type1, _type2) {
    //only one string type
    return true;
}
function isMoreSpecificArray(type1, type2, userDefinedTypes) {
    //static is more specific than dynamic, but
    //different static lengths are incomparable
    const moreSpecificLength = (type1.kind === "dynamic" && type2.kind === "dynamic") ||
        (type1.kind === "static" && type2.kind === "dynamic") ||
        (type1.kind === "static" &&
            type2.kind === "static" &&
            type1.length.eq(type2.length));
    //length and types must both be more specific
    return (moreSpecificLength &&
        isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes));
}
function isMoreSpecificFunction(type1, type2, userDefinedTypes) {
    switch (type2.kind) {
        case "general":
            return true;
        case "specific":
            switch (type1.kind) {
                case "general":
                    return false;
                case "specific":
                    //now: if they're both specific...
                    //(this case doesn't really matter, but let's do it anyway)
                    if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {
                        return false;
                    }
                    if (type1.outputParameterTypes.length !==
                        type2.outputParameterTypes.length) {
                        return false;
                    }
                    for (let i = 0; i < type1.outputParameterTypes.length; i++) {
                        if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {
                            return false;
                        }
                    }
                    if (type1.inputParameterTypes.length !==
                        type2.inputParameterTypes.length) {
                        return false;
                    }
                    for (let i = 0; i < type1.inputParameterTypes.length; i++) {
                        if (!isMoreSpecific(
                        //swapped for contravariance, I guess...?
                        type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {
                            return false;
                        }
                    }
                    return true;
            }
    }
}
function isMutabilityMoreSpecific(mutability1, mutability2) {
    //pure <= view <= nonpayable, payable <= nonpayable
    return (mutability1 === mutability2 ||
        (mutability1 === "pure" && mutability2 !== "payable") ||
        mutability2 === "nonpayable");
}
function isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames = false) {
    debug("type1: %O", type1);
    debug("type2: %O", type2);
    const fullType1 = Format.Types.fullType(type1, userDefinedTypes);
    const fullType2 = Format.Types.fullType(type2, userDefinedTypes);
    const types1 = (fullType1.memberTypes).map(member => member.type);
    const types2 = (fullType2.memberTypes).map(member => member.type);
    //lengths must match
    if (types1.length !== types2.length) {
        return false;
    }
    //individual types must satisfy isMoreSpecific
    for (let i = 0; i < types1.length; i++) {
        //note we do *not* pass along the ignoreComponentNames flag
        if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {
            return false;
        }
    }
    if (!ignoreComponentNames) {
        debug("checking by name");
        //if this flag is not set, *and* the component names match,
        //(and all exist)
        //then compare by component names in addition to by position
        let names1 = (fullType1.memberTypes).map(member => member.name);
        let names2 = (fullType2.memberTypes).map(member => member.name);
        //we just created these via a map so it's OK to sort in-place
        names1.sort();
        names2.sort();
        let namesEqual = true;
        for (let i = 0; i < names1.length; i++) {
            if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {
                namesEqual = false;
                break;
            }
        }
        if (namesEqual) {
            debug("names equal");
            for (let i = 0; i < types1.length; i++) {
                const type1 = types1[i];
                const name = fullType1.memberTypes[i].name;
                const type2 = fullType2.memberTypes.find(({ name: name2 }) => name2 === name).type;
                debug("name: %s", name);
                debug("type1: %O", type1);
                debug("type2: %O", type2);
                if (!isMoreSpecific(type1, type2, userDefinedTypes)) {
                    debug("returning false");
                    return false;
                }
            }
            debug("name check ok");
        }
    }
    return true;
    //I was going to make structs more specific than their underlying
    //tuples, and different equivalent structs incomparable, but I
    //couldn't find a good way to do that, so whatever, they're all
    //just equivalent, it won't come up
}
function isMoreSpecificOptions(_type1, _type2) {
    //only one options type
    return true;
}
function isMoreSpecificBool(_type1, _type2) {
    //only one boolean type
    return true;
}
function getUnderlyingType(udvtType, userDefinedTypes) {
    return (Format.Types.fullType(udvtType, userDefinedTypes)).underlyingType;
}
//# sourceMappingURL=priority.js.map

/***/ }),

/***/ 624578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:string");
const dispatch_1 = __webpack_require__(573898);
const errors_1 = __webpack_require__(674595);
const decode_1 = __webpack_require__(59495);
const bytes_1 = __webpack_require__(162083);
const Utils = __importStar(__webpack_require__(133272));
const Messages = __importStar(__webpack_require__(153983));
const stringCasesBasic = [
    stringFromString,
    stringFromBoxedString,
    stringFromCodecStringValue,
    stringFromUint8ArrayLike,
    stringFailureCase
];
exports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];
function* stringFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isValidUtf16(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "valid",
            asString: input
        }
    };
}
function* stringFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //defer to primitive string case
    return yield* stringFromString(dataType, input.valueOf(), wrapOptions);
}
function* stringFromCodecStringValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //rather than dealing with the different kinds in this case
    //for rewrapping, we'll just rewrap directly;
    //yes, this is a bit inconsistent with how we handle this case for other types
    return {
        type: dataType,
        kind: "value",
        value: input.value
    };
}
function* stringFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    bytes_1.validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    const info = decode_1.decodeString(new Uint8Array(input));
    return {
        type: dataType,
        kind: "value",
        value: info
    };
}
function* stringFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), stringCasesBasic);
}
function* stringFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);
}
//# sourceMappingURL=string.js.map

/***/ }),

/***/ 710076:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 133272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeUnderscoresHex = exports.removeUnderscoresNoHex = exports.removeUnderscoresNumeric = exports.isValidUtf16 = exports.isBoxedPrimitive = exports.isBoxedBoolean = exports.isBoxedNumber = exports.isBoxedString = exports.isByteStringWithUnderscores = exports.isByteString = exports.isPrefixlessHexString = exports.isHexString = exports.base64Length = exports.isBase64 = exports.isPlainObject = exports.isUint8ArrayLike = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;
const big_js_1 = __importDefault(__webpack_require__(107951));
const Conversion = __importStar(__webpack_require__(152714));
const isBoolean_1 = __importDefault(__webpack_require__(682134)); //recognizes boolean *or* Boolean
const isString_1 = __importDefault(__webpack_require__(136754)); //recognizes string *or* String
const isNumber_1 = __importDefault(__webpack_require__(52953)); //recognizes number *or* Number
const utf8_1 = __importDefault(__webpack_require__(957458));
function places(dataType) {
    switch (dataType.typeClass) {
        case "int":
        case "uint":
            return 0;
        case "fixed":
        case "ufixed":
            return dataType.places;
    }
}
exports.places = places;
function maxValue(dataType) {
    let bits = dataType.bits;
    if (dataType.typeClass === "int" || dataType.typeClass === "fixed") {
        bits -= 1; //subtract 1 for signed
    }
    const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);
    return Conversion.shiftBigDown(maxIntegerValue, places(dataType));
}
exports.maxValue = maxValue;
function minValue(dataType) {
    if (dataType.typeClass === "uint" || dataType.typeClass === "ufixed") {
        return new big_js_1.default(0);
    }
    const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));
    return Conversion.shiftBigDown(minIntegerValue, places(dataType));
}
exports.minValue = minValue;
function isSafeNumber(dataType, input) {
    const scaledUp = input * 10 ** dataType.places;
    return (Number.MIN_SAFE_INTEGER <= scaledUp && scaledUp <= Number.MAX_SAFE_INTEGER);
}
exports.isSafeNumber = isSafeNumber;
function isTypeValueInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "string" &&
        "value" in input &&
        Object.keys(input).length === 2);
}
exports.isTypeValueInput = isTypeValueInput;
function isEncodingTextInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.encoding === "string" &&
        typeof input.text === "string" &&
        Object.keys(input).length === 2);
}
exports.isEncodingTextInput = isEncodingTextInput;
function isContractInput(input) {
    return ((typeof input === "object" || typeof input === "function") &&
        input !== null &&
        typeof input.address === "string" &&
        //we *don't* check anything more for addresses, we'll let the
        //address wrapper handle that
        !("selector" in input));
}
exports.isContractInput = isContractInput;
function isFunctionExternalInput(input) {
    return ((typeof input === "object" || typeof input === "function") &&
        input !== null &&
        "address" in input &&
        "selector" in input);
}
exports.isFunctionExternalInput = isFunctionExternalInput;
function isWrappedResult(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "object" &&
        input.type !== null &&
        typeof input.type.typeClass === "string" &&
        ((input.kind === "value" && typeof input.value === "object") ||
            (input.kind === "error" && typeof input.error === "object")));
}
exports.isWrappedResult = isWrappedResult;
function isUint8ArrayLike(input) {
    return (input instanceof Uint8Array ||
        (typeof input === "object" &&
            input !== null &&
            typeof input.length === "number"));
}
exports.isUint8ArrayLike = isUint8ArrayLike;
//hack?
function isPlainObject(input) {
    return typeof input === "object" && input !== null;
}
exports.isPlainObject = isPlainObject;
function isBase64(input) {
    const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here
    return Boolean(input.match(base64Pattern));
}
exports.isBase64 = isBase64;
function base64Length(base64) {
    const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds
    return (base64.length * 3) / 4 - endingEquals.length;
}
exports.base64Length = base64Length;
function isHexString(input) {
    //(with prefix, to be clear)
    const hexStringPattern = /^0[xX][0-9a-fA-F]*$/;
    return Boolean(input.match(hexStringPattern));
}
exports.isHexString = isHexString;
function isPrefixlessHexString(input) {
    const shortHexStringPattern = /^[0-9a-fA-F]*$/;
    return Boolean(input.match(shortHexStringPattern));
}
exports.isPrefixlessHexString = isPrefixlessHexString;
function isByteString(input) {
    const byteStringPattern = /^0[xX]([0-9a-fA-F]{2})*$/;
    return Boolean(input.match(byteStringPattern));
}
exports.isByteString = isByteString;
function isByteStringWithUnderscores(input) {
    const byteStringWithUnderscoresPattern = /^0[xX](([0-9a-fA-F]{2}_?)*([0-9a-fA-F]{2}))?$/;
    return Boolean(input.match(byteStringWithUnderscoresPattern));
}
exports.isByteStringWithUnderscores = isByteStringWithUnderscores;
function isBoxedString(input) {
    //unfortunately, isString has been typed incorrectly.
    //it should return `input is string|String`, but instead it
    //incorrectly returns `input is string`.  As such, we have
    //to work around its incorrect typing here.
    return isString_1.default(input) && typeof input !== "string";
}
exports.isBoxedString = isBoxedString;
function isBoxedNumber(input) {
    //see comment on isBoxedString
    return isNumber_1.default(input) && typeof input !== "number";
}
exports.isBoxedNumber = isBoxedNumber;
function isBoxedBoolean(input) {
    //see comment on isBoxedString
    return isBoolean_1.default(input) && typeof input !== "boolean";
}
exports.isBoxedBoolean = isBoxedBoolean;
function isBoxedPrimitive(input) {
    return isBoxedString(input) || isBoxedNumber(input) || isBoxedBoolean(input);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isValidUtf16(input) {
    try {
        utf8_1.default.encode(input); //encode but discard :P
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isValidUtf16 = isValidUtf16;
function removeUnderscoresNumeric(numeric) {
    //if it contains 0x or 0X, treat as hex;
    //otherwise, treat as non-hex (decimal/octal/binary)
    return numeric.match(/0x/i)
        ? removeUnderscoresHex(numeric)
        : removeUnderscoresNoHex(numeric);
}
exports.removeUnderscoresNumeric = removeUnderscoresNumeric;
function removeUnderscoresNoHex(numeric) {
    //this would be easy with lookbehind assertions, but those aren't safe to use
    //in all browsers, so, we're going to have to do things a bit more
    //manually...
    return removeUnderscoresWithRegex(numeric, /\d_\d/);
}
exports.removeUnderscoresNoHex = removeUnderscoresNoHex;
function removeUnderscoresHex(hex) {
    //same comment
    return removeUnderscoresWithRegex(hex, /[\da-f]_[\da-f]/i);
}
exports.removeUnderscoresHex = removeUnderscoresHex;
//note: regex should be of the form <A>_<A>, where <A> is a regex that matches
//precisely one character!  this will not work otherwise!
function removeUnderscoresWithRegex(input, regex) {
    let match;
    while ((match = input.match(regex))) {
        //replace input by the same thing but w/ the underscore removed,
        //by taking the text before and after the underscore
        input = input.slice(0, match.index + 1) + input.slice(match.index + 2);
    }
    return input;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 118400:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("codec:wrap:wrap");
const Format = __importStar(__webpack_require__(429965));
const errors_1 = __webpack_require__(674595);
const dispatch_1 = __webpack_require__(573898);
const Messages = __importStar(__webpack_require__(153983));
const Conversion = __importStar(__webpack_require__(152714));
const Utils = __importStar(__webpack_require__(133272));
const integer_1 = __webpack_require__(547779);
const decimal_1 = __webpack_require__(36902);
const bool_1 = __webpack_require__(356291);
const bytes_1 = __webpack_require__(162083);
const address_1 = __webpack_require__(8871);
const string_1 = __webpack_require__(624578);
const function_1 = __webpack_require__(552181);
//this file contains the main wrap function, as well as the cases
//for arrays, tuples, udvts, and tx options.  all other types get their
//own file.
const arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFailureCase];
exports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];
const tupleCasesBasic = [
    tupleFromArray,
    tupleFromCodecTupleLikeValue,
    tupleFromObject,
    tupleFailureCase
];
exports.tupleCases = [
    tupleFromTypeValueInput,
    ...tupleCasesBasic
];
const txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];
exports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];
exports.udvtCases = [
    //no separate case for udvtFromUdvtValue,
    //since underlying already handles this
    udvtFromUnderlying
];
function* wrap(dataType, input, wrapOptions) {
    if (!wrapOptions.name) {
        wrapOptions = Object.assign(Object.assign({}, wrapOptions), { name: "<input>" });
    }
    switch (dataType.typeClass) {
        case "uint":
        case "int":
        case "enum":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, integer_1.integerCases);
        case "fixed":
        case "ufixed":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, decimal_1.decimalCases);
        case "bool":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, bool_1.boolCases);
        case "bytes":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, bytes_1.bytesCases);
        case "address":
        case "contract":
            //these are treated the same
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, address_1.addressCases);
        case "string":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, string_1.stringCases);
        case "function":
            //special check: weed out internal functions
            if (dataType.visibility === "internal") {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity
                `Wrapping/encoding for internal function pointers is not supported`);
            }
            //otherwise, go ahead
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, function_1.functionExternalCases);
        case "array":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.arrayCases);
        case "struct":
        case "tuple":
            //these are treated the same as well
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.tupleCases);
        case "userDefinedValueType":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.udvtCases);
        case "options":
            return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.txOptionsCases);
        default:
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity
            `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);
    }
}
exports.wrap = wrap;
//array cases
function* arrayFromArray(dataType, input, wrapOptions) {
    if (!Array.isArray(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an array");
    }
    if (dataType.kind === "static" && !dataType.length.eqn(input.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));
    }
    //can't do yield in a map, so manual loop here
    let value = [];
    for (let index = 0; index < input.length; index++) {
        value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}[${index}]`, specificityFloor: 5 //errors in components are quite specific!
         })));
    }
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* arrayFromCodecArrayValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "array") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //we won't bother with detailed typechecking as much of it is handled
    //either in the call to arrayFromArray or in the wrapping of the
    //individual elements; we will check dynamic vs static though as that
    //isn't handled elsewhere
    if (!wrapOptions.loose && input.type.kind === dataType.kind) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    //note that we do *not* just copy over input.value, but rather we
    //defer to arrayFromArray; this is because there might be some elements
    //where the type is not the same but is compatible
    const value = input.value;
    return yield* arrayFromArray(dataType, value, wrapOptions);
}
function* arrayFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "array") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //don't turn on loose here, only do that for non-container types!
    return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, arrayCasesBasic);
}
function* arrayFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not an array, type/value pair or wrapped array");
}
//tuple/struct cases;
//note even with loose turned off, we won't distinguish
//between tuples and structs
function* tupleFromArray(dataType, input, wrapOptions) {
    //first: obtain the types of the members
    if (!Array.isArray(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an array");
    }
    debug("input is array");
    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);
    if (memberTypes.length !== input.length) {
        debug("input is wrong-length array");
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));
    }
    //can't do yield in a map, so manual loop here
    let value = [];
    for (let index = 0; index < input.length; index++) {
        const memberName = memberTypes[index].name;
        debug("wrapping %s", memberName);
        value.push({
            name: memberName,
            value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), { name: memberName
                    ? wrapOptions.name.match(/^<.*>$/) //hack?
                        ? memberName
                        : `${wrapOptions.name}.${memberName}`
                    : `${wrapOptions.name}[${index}]`, specificityFloor: 5 }))
        });
    }
    //we need to coerce here because TS doesn't know that if it's a struct
    //then everything has a name
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* tupleFromObject(dataType, input, wrapOptions) {
    if (!Utils.isPlainObject(input)) {
        //just checks that it's an object & not null
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a non-null object");
    }
    if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {
        //let's exclude these unless loose is turned on
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a type/value pair");
    }
    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {
        //similarly here
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);
    if (memberTypes.some(({ name }) => !name)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, "Plain object input is allowed only when all elements of tuple are named");
    }
    let unusedKeys = new Set(Object.keys(input));
    let value = [];
    for (let index = 0; index < memberTypes.length; index++) {
        //note we had better process these in order!
        const memberName = memberTypes[index].name;
        if (!(memberName in input)) {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);
        }
        unusedKeys.delete(memberName);
        value.push({
            name: memberName,
            value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${memberName}`, specificityFloor: 4 //not sure this warrants a 5
             }))
        });
    }
    if (!wrapOptions.loose) {
        if (unusedKeys.size > 0) {
            //choose one arbitrarily
            const exampleKey = unusedKeys.values().next().value;
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);
        }
    }
    //we need to coerce here because TS doesn't know that if it's a struct
    //then everything has a name
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "tuple" && input.type.typeClass !== "struct") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //not going to do much typechecking here as it'll be handled in the call
    //to tupleFromArray
    //Typescript complains if I try to say it can be either struct or
    //tuple, so, uh, let's just tell it it's a tuple <shrug>
    const coercedInput = input; //HACK!
    //note that we do *not* just copy over input.value, but rather we
    //defer to tupleFromArray; this is because there might be some elements
    //where the type is not the same but is compatible
    return yield* tupleFromArray(dataType, coercedInput.value.map(({ value }) => value), wrapOptions);
}
function* tupleFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "tuple" && input.type !== "struct") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //don't turn on loose here, only do that for non-container types!
    return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, tupleCasesBasic);
}
function* tupleFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not an array, plain object, type/value pair or wrapped tuple or struct");
}
function memberTypesForType(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        case "tuple":
            return dataType.memberTypes;
            break;
        case "struct":
            debug("wrapping for struct %s", dataType.typeName);
            return (Format.Types.fullType(dataType, userDefinedTypes)).memberTypes;
    }
}
//udvt cases
function* udvtFromUnderlying(dataType, input, wrapOptions) {
    const { underlyingType } = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
    const value = yield* wrap(underlyingType, input, wrapOptions);
    return {
        type: dataType,
        kind: "value",
        value: value
    };
}
//tx options cases
function* optionsFromObject(dataType, input, wrapOptions) {
    if (!Utils.isPlainObject(input)) {
        //just checks that it's an object & not null
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a non-null object");
    }
    debug("options input is object: %O", input);
    debug("wrapOptions: %O", wrapOptions);
    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {
        //similarly here
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    //now... the main case
    let value = {};
    const uintKeys = [
        "gas",
        "gasPrice",
        "value",
        "nonce",
        "maxFeePerGas",
        "maxPriorityFeePerGas"
    ];
    const uint8Keys = ["type"];
    const addressKeys = ["from", "to"];
    const bytesKeys = ["data"];
    const boolKeys = ["overwrite"];
    const accessListKeys = ["accessList"];
    const specialKeys = ["privateFor"];
    const allKeys = [
        ...uintKeys,
        ...uint8Keys,
        ...addressKeys,
        ...bytesKeys,
        ...boolKeys,
        ...accessListKeys,
        ...specialKeys
    ];
    const badKey = Object.keys(input).find(key => !allKeys.includes(key));
    const goodKey = Object.keys(input).find(key => allKeys.includes(key));
    if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {
        //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK
        //to preserve existing behavior of Truffle Contract (perhaps we can
        //change this in Truffle 6)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);
    }
    if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {
        //similarly, if oldOptionsBehavior is on, we require at least
        //one *legit* key (again, HACK to preserve existing behavior,
        //maybe remove this in Truffle 6)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);
    }
    //otherwise, if all keys are transaction options, let's process them...
    //part 1: uint options
    for (const key of uintKeys) {
        //note we check input[key] !== undefined, rather than key in input,
        //because if one of them is undefined we want to just allow that but ignore it
        if (input[key] !== undefined) {
            const wrappedOption = (yield* dispatch_1.wrapWithCases({ typeClass: "uint", bits: 256 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));
            value[key] = wrappedOption.value.asBN;
        }
    }
    //part 2: uint8 options (just type for now)
    for (const key of uint8Keys) {
        if (input[key] !== undefined) {
            const wrappedOption = (yield* dispatch_1.wrapWithCases({ typeClass: "uint", bits: 8 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));
            const asBN = wrappedOption.value.asBN;
            //since this is just type right now, we're going to reject illegal types
            if (asBN.gten(0xc0)) {
                //not making a constant for this, this is its only use here
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, "Transaction types must be less than 0xc0");
            }
            //for compatibility, we give type as a hex string rather than
            //leaving it as a BN.  Since it's unsigned we don't have to
            //worry about negatives.
            value[key] = Conversion.toHexString(asBN);
        }
    }
    //part 3: address options
    for (const key of addressKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = (yield* dispatch_1.wrapWithCases({ typeClass: "address", kind: "general" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), address_1.addressCases));
            value[key] = wrappedOption.value.asAddress;
        }
    }
    //part 4: bytestring options
    for (const key of bytesKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* dispatch_1.wrapWithCases({ typeClass: "bytes", kind: "dynamic" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bytes_1.bytesCases);
            value[key] = wrappedOption.value.asHex;
        }
    }
    //part 5: boolean options
    for (const key of boolKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* dispatch_1.wrapWithCases({ typeClass: "bool" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bool_1.boolCases);
            value[key] = wrappedOption.value.asBoolean;
        }
    }
    //part 6: the access list
    for (const key of accessListKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* dispatch_1.wrapWithCases({
                typeClass: "array",
                kind: "dynamic",
                baseType: {
                    typeClass: "tuple",
                    memberTypes: [
                        {
                            name: "address",
                            type: {
                                typeClass: "address",
                                kind: "general"
                            }
                        },
                        {
                            name: "storageKeys",
                            type: {
                                typeClass: "array",
                                kind: "dynamic",
                                baseType: {
                                    //we use uint256 rather than bytes32 to allow
                                    //abbreviating and left-padding
                                    typeClass: "uint",
                                    bits: 256
                                }
                            }
                        }
                    ]
                }
            }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), exports.arrayCases);
            value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);
        }
    }
    //part 7: the special case of privateFor
    if (input.privateFor !== undefined) {
        //this doesn't correspond to any of our usual types, so we have to handle it specially
        if (!Array.isArray(input.privateFor)) {
            throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, "Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes");
        }
        value.privateFor = input.privateFor.map((publicKey, index) => {
            if (Utils.isBoxedString(publicKey)) {
                publicKey = publicKey.valueOf();
            }
            if (typeof publicKey !== "string") {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);
            }
            if (!Utils.isBase64(publicKey)) {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);
            }
            const length = Utils.base64Length(publicKey);
            if (length !== 32) {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);
            }
            return publicKey;
        });
    }
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "options") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const value = input.value;
    //unlike in the array or tuple cases, here should not have
    //to worry about compatible-but-not-identical types, so it's
    //safe to just copy value over
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* optionsFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "options") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //because options, unlike other containers, has specific types, we *will* turn on loose
    return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), txOptionsCasesBasic);
}
function* optionsFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Transaction options input was not a plain object, type/value pair or wrapped options object");
}
//# sourceMappingURL=wrap.js.map

/***/ }),

/***/ 632739:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rangeContainsAtLeast = exports.resolveToRange = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const semver_1 = __importDefault(__webpack_require__(734604));
const loadingStrategies_1 = __webpack_require__(641514);
const index_1 = __webpack_require__(147922);
/**
 * takes a version string which may be native or local, and resolves
 * it to one which is (presumably) either a version or a version range
 */
function resolveToRange(version) {
    if (!version) {
        return index_1.CompilerSupplier.getDefaultVersion();
    }
    //if version was native or local, must determine what version that
    //actually corresponds to
    if (version === "native") {
        return new loadingStrategies_1.Native().load().version();
    }
    else if (fs_extra_1.default.existsSync(version) && path_1.default.isAbsolute(version)) {
        return new loadingStrategies_1.Local().load(version).version();
    }
    return version;
}
exports.resolveToRange = resolveToRange;
/**
 * parameter range may be either an individual version or a range
 */
function rangeContainsAtLeast(range, comparisonVersion) {
    //the following line works with prereleases
    const individualAtLeast = !!(semver_1.default.valid(range, { loose: true }) &&
        semver_1.default.gte(range, comparisonVersion, {
            includePrerelease: true,
            loose: true
        }));
    //the following line doesn't, despite the flag, but does work with version ranges
    const rangeAtLeast = !!(semver_1.default.validRange(range, { loose: true }) &&
        !semver_1.default.gtr(comparisonVersion, range, {
            includePrerelease: true,
            loose: true
        }) //intersects will throw if given undefined so must ward against
    );
    return individualAtLeast || rangeAtLeast;
}
exports.rangeContainsAtLeast = rangeContainsAtLeast;
//# sourceMappingURL=rangeUtils.js.map

/***/ }),

/***/ 874269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("compile-vyper");
const path = __webpack_require__(371017);
const exec = (__webpack_require__(532081).exec);
const fs = __webpack_require__(657147);
const colors = __webpack_require__(183196);
const minimatch = __webpack_require__(791171);
const semver = __webpack_require__(590560);

const findContracts = __webpack_require__(123542);
const Config = __webpack_require__(120553);
const { Profiler } = __webpack_require__(776273);
const { requiredSources } = __webpack_require__(653377);
const { Compilations } = __webpack_require__(529833);

const { compileJson } = __webpack_require__(313919);

const VYPER_PATTERN_STRICT = "**/*.{vy,v.py,vyper.py}"; //no JSON

// Check that vyper is available, return its version
function checkVyper() {
  return new Promise((resolve, reject) => {
    exec("vyper-json --version", function (err, stdout, _stderr) {
      if (err) {
        //vyper-json not available, check vyper
        exec("vyper --version", function (err, stdout, stderr) {
          if (err) {
            //error: neither vyper nor vyper-json available
            return reject(`${colors.red("Error executing vyper:")}\n${stderr}`);
          }
          const version = normalizeVersion(stdout.trim());
          if (
            semver.satisfies(version, ">=0.2.5", {
              loose: true,
              includePrerelase: true
            })
          ) {
            //if version is >=0.2.5, we can still use JSON via
            //vyper --standard-json
            resolve({
              version,
              json: true,
              jsonCommand: "vyper --standard-json"
            });
          } else {
            //otherwise, we're stuck using vyper w/o JSON
            resolve({ version, json: false });
          }
        });
      } else {
        //no error: vyper-json is available
        const version = normalizeVersion(stdout.trim());
        resolve({ version, json: true, jsonCommand: "vyper-json" });
      }
    });
  });
}

//HACK: alters prerelease versions so semver can understand them
function normalizeVersion(version) {
  return version.replace(/^(\d+\.\d+\.\d+)b(\d+)/, "$1-beta.$2");
}

// Execute vyper for single source file
function execVyper(options, sourcePath, version, callback) {
  const formats = ["abi", "bytecode", "bytecode_runtime"];
  debug("version: %s", version);
  if (
    semver.satisfies(version, ">=0.1.0-beta.7", {
      loose: true,
      includePrerelase: true
    })
  ) {
    //Vyper chokes on unknown formats, so only include this for
    //ones that support it (they were introduced in 0.1.0b7)
    formats.push("source_map");
  }
  let evmVersionOption = "";
  if (
    options.compilers.vyper.settings &&
    options.compilers.vyper.settings.evmVersion
  ) {
    const evmVersion = options.compilers.vyper.settings.evmVersion;
    if (evmVersion.includes("'")) {
      throw new Error("Invalid EVM version");
    }
    evmVersionOption = `--evm-version '${evmVersion}'`;
  }
  if (options.contracts_directory.includes("'")) {
    throw new Error("Contracts directory contains apostrophe");
  }
  const command = `vyper -f ${formats.join(
    ","
  )} ${evmVersionOption} ${sourcePath} -p '${options.contracts_directory}'`;

  exec(command, { maxBuffer: 600 * 1024 }, function (err, stdout, stderr) {
    if (err)
      return callback(
        `${stderr}\n${colors.red(
          `Compilation of ${sourcePath} failed. See above.`
        )}`
      );

    var outputs = stdout.split(/\r?\n/);

    debug("formats: %O", formats);
    debug("outputs: %O", outputs);

    const compiledContract = outputs.reduce((contract, output, index) => {
      return Object.assign(contract, { [formats[index]]: output });
    }, {});

    callback(null, compiledContract);
  });
}

/**
 *
 * read source contents from sourcePath
 */
function readSource(sourcePath) {
  const sourceBuffer = fs.readFileSync(sourcePath);
  return sourceBuffer.toString();
}

/**
 * aggregate source information based on compiled output;
 * this can include sources that are not contracts
 */

//note: this takes paths, rather than full source objects like compileJson!
async function compileNoJson({ paths: sources, options, version }) {
  const compiler = { name: "vyper", version };
  const promises = [];
  const properSources = sources.filter(source => !source.endsWith(".json")); //filter out JSON interfaces
  const targets = options.compilationTargets
    ? properSources.filter(sourcePath =>
        options.compilationTargets.includes(sourcePath)
      )
    : properSources;
  targets.forEach(sourcePath => {
    promises.push(
      new Promise((resolve, reject) => {
        execVyper(
          options,
          sourcePath,
          version,
          function (error, compiledContract) {
            if (error) return reject(error);

            debug("compiledContract: %O", compiledContract);

            // remove first extension from filename
            const extension = path.extname(sourcePath);
            const basename = path.basename(sourcePath, extension);

            // if extension is .py, remove second extension from filename
            const contractName =
              extension !== ".py"
                ? basename
                : path.basename(basename, path.extname(basename));

            const sourceContents = readSource(sourcePath);
            const deployedSourceMap = compiledContract.source_map //there is no constructor source map
              ? JSON.parse(compiledContract.source_map)
              : undefined;

            const contractDefinition = {
              contractName: contractName,
              sourcePath: sourcePath,
              source: sourceContents,
              abi: JSON.parse(compiledContract.abi),
              bytecode: {
                bytes: compiledContract.bytecode.slice(2), //remove "0x" prefix
                linkReferences: [] //no libraries in Vyper
              },
              deployedBytecode: {
                bytes: compiledContract.bytecode_runtime.slice(2), //remove "0x" prefix
                linkReferences: [] //no libraries in Vyper
              },
              deployedSourceMap,
              compiler
            };

            const compilation = {
              sources: [
                {
                  sourcePath,
                  contents: sourceContents,
                  language: "Vyper"
                }
              ],
              contracts: [contractDefinition],
              compiler,
              sourceIndexes: [sourcePath]
            };

            resolve(compilation);
          }
        );
      })
    );
  });
  const compilations = await Promise.all(promises);

  return Compilations.promoteCompileResult({ compilations });
}

const Compile = {
  // Check that vyper is available then forward to internal compile function
  async sources({ sources = {}, options }) {
    options = Config.default().merge(options);
    const paths = Object.keys(sources);
    const vyperFiles = paths.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );

    // no vyper files found, no need to check vyper
    // (note that JSON-only will not activate vyper)
    if (vyperFiles.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    Compile.display(vyperFiles, options);
    const { version, json: useJson, jsonCommand } = await checkVyper();
    if (!useJson) {
      //it might be possible to handle this case by writing the sources
      //to a temporary directory (and possibly using some sort of remapping--
      //a manual one I mean, Vyper doesn't have remappings),
      //but for now I'll just have it throw for simplicity
      throw new Error("Compiling literal Vyper sources requires vyper-json");
    }

    return compileJson({ sources, options, version, command: jsonCommand });
  },

  async sourcesWithDependencies({ paths = [], options }) {
    options = Config.default().merge(options);
    debug("paths: %O", paths);
    const vyperFilesStrict = paths.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );
    debug("vyperFilesStrict: %O", vyperFilesStrict);

    // no vyper targets found, no need to check Vyper
    if (vyperFilesStrict.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    const { allSources, compilationTargets } = await requiredSources(
      options.with({
        paths: vyperFilesStrict,
        base_path: options.contracts_directory,
        compiler: {
          name: "vyper"
          //HACK: we leave version empty because we haven't determined
          //it at this point and we don't want to pay the cost of doing
          //so, and nothing in the resolver sources currently uses
          //precise vyper version
        }
      })
    );

    debug("allSources: %O", allSources);
    debug("compilationTargets: %O", compilationTargets);
    const vyperTargets = compilationTargets.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );

    // no vyper targets found, no need to activate Vyper
    if (vyperTargets.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    //having gotten the sources from the resolver, we invoke compileJson
    //ourselves, rather than going through Compile.sources()
    Compile.display(compilationTargets, options);

    const { version, json: useJson, jsonCommand } = await checkVyper();

    if (useJson) {
      return compileJson({
        sources: allSources,
        options: options.with({
          compilationTargets
        }),
        version,
        command: jsonCommand
      });
    } else {
      return await compileNoJson({
        paths: Object.keys(allSources),
        options: options.with({
          compilationTargets
        }),
        version
      });
    }
  },

  // contracts_directory: String. Directory where contract files can be found.
  // quiet: Boolean. Suppress output. Defaults to false.
  // strict: Boolean. Return compiler warnings as errors. Defaults to false.
  async all(options) {
    options = Config.default().merge(options);
    const files = await findContracts(options.contracts_directory);

    const vyperFilesStrict = files.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );
    // no vyper targets found, no need to check Vyper
    if (vyperFilesStrict.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    return await Compile.sourcesWithDependencies({
      paths: files,
      options
    });
  },

  // contracts_directory: String. Directory where contract files can be found.
  // all: Boolean. Compile all sources found. Defaults to true. If false, will compare sources against built files
  //      in the build directory to see what needs to be compiled.
  // quiet: Boolean. Suppress output. Defaults to false.
  // strict: Boolean. Return compiler warnings as errors. Defaults to false.
  async necessary(options) {
    options = Config.default().merge(options);

    const profiler = await new Profiler({});
    const updated = await profiler.updated(options);
    if (updated.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }
    return await Compile.sourcesWithDependencies({
      paths: updated,
      options
    });
  },

  async display(paths, options) {
    if (options.quiet !== true) {
      if (!Array.isArray(paths)) {
        paths = Object.keys(paths);
      }

      const sourceFileNames = paths.sort().map(contract => {
        if (path.isAbsolute(contract)) {
          return `.${path.sep}${path.relative(
            options.working_directory,
            contract
          )}`;
        }

        return contract;
      });
      options.events.emit("compile:sourcesToCompile", { sourceFileNames });
    }
  }
};

module.exports = {
  Compile
};


/***/ }),

/***/ 887359:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("compile-vyper:parser");
const OS = __webpack_require__(822037);

function parseImports(body) {
  // WARNING: We're going to do this crudely with regexes!!
  //
  // Vyper has a rigid enough syntax that I think this is workable.
  //
  // We can't use the Solidity approach here of analyzing error messages
  // because the Vyper compiler will only provide an error for the *first*
  // failing import, not all of them.

  // (before we do all that, though, we'll try parsing as JSON
  // and return no imports if it parses, in case this gets passed
  // a JSON file!)
  try {
    JSON.parse(body);
    debug("was JSON, no imports");
    return []; //if we reach this point it was a JSON file
  } catch (_) {
    //it was Vyper, proceed onward
  }

  const stripWhitespace = str => str.replace(/\s/g, ""); //remove even internal whitespace

  //HACK: this isn't actually a correct way of handling line
  //extensions and comments... but it should be good enough
  //for our purposes!  I can't think of any cases that this
  //gets wrong *in a way that we care about*

  return (
    body
      .replace(/(#.*)\\\r?\n/g, "$1") //remove backslashes from end of comments
      // (this is the most-incorrect step; it will detect a "comment" even if
      // the # is used in a string literal.  but this shouldn't screw up imports,
      // so...)
      .replace(/\\\r?\n/g, " ") //process line extensions;
      //for convenience we use \r?\n instead of OS.EOL
      //(we don't care that this screws up string literals)
      .split(OS.EOL) //split body into lines
      .map(line => {
        //extract imports!
        const importRegex = /^import\b(.*?)\bas\b/;
        const fromImportRegex = /^from\b(.*?)\bimport\b(.*?)($|\bas\b)/;
        let matches;
        if ((matches = line.match(importRegex))) {
          const [_, path] = matches;
          return stripWhitespace(path);
        } else if ((matches = line.match(fromImportRegex))) {
          const [_, basePath, endPath] = matches;
          debug("basePath: %s; endPath: %s", basePath, endPath);
          const strippedBasePath = stripWhitespace(basePath);
          if (strippedBasePath === "vyper.interfaces") {
            //built-in import; we should not attempt to resolve it
            return null;
          }
          const strippedEndPath = stripWhitespace(endPath);
          return strippedBasePath.endsWith(".")
            ? `${strippedBasePath}${strippedEndPath}` //don't add extra "." for "from . import", etc
            : `${strippedBasePath}.${strippedEndPath}`;
          //on the endPath because
        } else {
          return null;
        }
      })
      .filter(moduleName => moduleName !== null)
  );
}

module.exports = {
  parseImports
};


/***/ }),

/***/ 653377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("compile-vyper:profiler");
const { Profiler } = __webpack_require__(776273);
const { Resolver } = __webpack_require__(648511);
const { parseImports } = __webpack_require__(887359);

// Returns the minimal set of sources to pass to vyper-json as compilations targets,
// as well as the complete set of sources so vyper-json can resolve the comp targets' imports.
async function requiredSources(options) {
  const resolver = new Resolver(options);

  debug("resolver.sources.length: %d", resolver.sources.length);

  // generate profiler
  const profiler = new Profiler({
    parseImports,
    shouldIncludePath
  });

  // invoke profiler
  debug("invoking profiler");
  return await profiler.requiredSources(options.with({ resolver }));
}

function shouldIncludePath(path) {
  return path.match(/\.(vy|json|v\.py|vyper\.py)$/) !== null;
}

module.exports = {
  requiredSources
};


/***/ }),

/***/ 313919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("compile-vyper:vyper-json");
const execSync = (__webpack_require__(532081).execSync);
const path = __webpack_require__(371017);
const semver = __webpack_require__(590560);
const Common = __webpack_require__(529833);
const partition = __webpack_require__(39582);

//NOTE: this file has a fair bit of copypaste-with-modifications
//from compile-solidity/run.js, so be warned...
//(some has since been factored into compile-common, but not all)

function compileJson({ sources: rawSources, options, version, command }) {
  const compiler = { name: "vyper", version };

  //in order to better support absolute Vyper imports, we pretend that
  //the contracts directory is the root directory.  note this means that
  //if an imported source from somewhere other than FS uses an absolute
  //import to refer to its own project root, it won't work.  But, oh well.
  const { sources, targets, originalSourcePaths } =
    Common.Sources.collectSources(
      rawSources,
      options.compilationTargets,
      options.contracts_directory
    );

  //Vyper complains if we give it a source that is not also a target,
  //*unless* we give it as an interface.  So we have to split that out.
  //(JSON files also must always be interfaces)
  const [properSourcePaths, interfacePaths] = partition(
    Object.keys(sources),
    targets.length > 0
      ? sourcePath =>
          !sourcePath.endsWith(".json") && targets.includes(sourcePath)
      : sourcePath => !sourcePath.endsWith(".json")
  );

  const properSources = Object.assign(
    {},
    ...properSourcePaths.map(sourcePath => ({
      [sourcePath]: sources[sourcePath]
    }))
  );

  const interfaces = Object.assign(
    {},
    ...interfacePaths.map(sourcePath => ({
      [sourcePath]: sources[sourcePath]
    }))
  );

  // construct compiler input
  const compilerInput = prepareCompilerInput({
    sources: properSources,
    interfaces,
    settings: options.compilers.vyper.settings || {},
    version
  });

  // perform compilation
  const rawCompilerOutput = invokeCompiler({
    compilerInput,
    command
  });
  debug("rawCompilerOutput: %O", rawCompilerOutput);

  // handle warnings as errors if options.strict
  // log if not options.quiet
  const { warnings, errors } = detectErrors({
    compilerOutput: rawCompilerOutput,
    options
  });
  if (warnings.length > 0) {
    options.events.emit("compile:warnings", { warnings });
  }

  if (errors.length > 0) {
    if (!options.quiet) {
      options.logger.log("");
    }

    throw new Common.Errors.CompileError(errors);
  }

  const compilerOutput = correctPaths(rawCompilerOutput);

  const outputSources = processAllSources({
    sources,
    compilerOutput,
    originalSourcePaths
  });
  const sourceIndexes = outputSources.map(source => source.sourcePath);
  const compilation = {
    sourceIndexes,
    contracts: processContracts({
      sources,
      compilerOutput,
      version,
      originalSourcePaths
    }),
    sources: outputSources,
    compiler
  };

  return Common.Compilations.promoteCompileResult({
    compilations: [compilation]
  });
}

function invokeCompiler({ compilerInput, command }) {
  const inputString = JSON.stringify(compilerInput);
  const outputString = execVyperJson(inputString, command);
  return JSON.parse(outputString);
}

function execVyperJson(inputString, command) {
  return execSync(command, {
    input: inputString,
    maxBuffer: 1024 * 1024 * 10 //I guess?? copied from compile-solidity
  });
}

function prepareCompilerInput({ sources, settings, interfaces, version }) {
  const outputSelection = prepareOutputSelection({ version });
  return {
    language: "Vyper",
    sources: prepareSources({ sources }),
    interfaces: prepareInterfaces({ interfaces }),
    settings: {
      ...settings,
      outputSelection
    },
    //older versions of vyper require outputSelection *outside* of settings.
    //we'll put it in both places for compatibility.
    outputSelection
  };
}

function prepareSources({ sources }) {
  return Object.entries(sources)
    .map(([sourcePath, content]) => ({ [sourcePath]: { content } }))
    .reduce((a, b) => Object.assign({}, a, b), {});
}

function prepareInterfaces({ interfaces }) {
  return Object.entries(interfaces)
    .map(([sourcePath, content]) =>
      sourcePath.endsWith(".json") //for JSON we need the ABI *object*, not JSON!
        ? { [sourcePath]: { abi: JSON.parse(content) } }
        : { [sourcePath]: { content } }
    )
    .reduce((a, b) => Object.assign({}, a, b), {});
}

function prepareOutputSelection({ version }) {
  //Vyper uses a simpler output selection format
  //than solc does; it also supports solc's format,
  //but I've gone with the simpler version here
  let defaultSelectors = [
    "abi",
    "ast",
    "evm.bytecode.object",
    //we have to omit sourceMap here, as annoyingly,
    //Vyper errors if you give it a not-yet-supported output selection...
    "evm.deployedBytecode.object",
    "evm.deployedBytecode.sourceMap"
  ];
  if (
    semver.satisfies(version, ">=0.1.0-beta.17", {
      loose: true,
      includePrerelase: true
    })
  ) {
    //again, due to Vyper erroring if you ask for output it doesn't know about,
    //we have to only add these to the output if we're on a sufficiently recent
    //version
    const additionalSelectors = ["userdoc", "devdoc"];
    defaultSelectors = defaultSelectors.concat(additionalSelectors);
  }

  //because we've already filtered down the sources to match the targets,
  //we can just say that the targets are everything
  return {
    "*": defaultSelectors
  };
}

//this also is copy-pasted, but minus some complications
function detectErrors({ compilerOutput: { errors: outputErrors }, options }) {
  outputErrors = outputErrors || [];
  const rawErrors = options.strict
    ? outputErrors
    : outputErrors.filter(({ severity }) => severity !== "warning");

  const rawWarnings = options.strict
    ? [] // none of those in strict mode
    : outputErrors.filter(({ severity }) => severity === "warning");

  // extract messages
  // NOTE: sufficiently old Vyper versions don't have formattedMessage, so we use message
  // instead in those cases
  let errors = rawErrors
    .map(({ formattedMessage, message }) => formattedMessage || message)
    .join();
  const warnings = rawWarnings.map(
    ({ formattedMessage, message }) => formattedMessage || message
  );

  return { warnings, errors };
}

//warning: copypaste
function processAllSources({ sources, compilerOutput, originalSourcePaths }) {
  if (!compilerOutput.sources) return [];
  let outputSources = [];
  for (const [sourcePath, { id, ast }] of Object.entries(
    compilerOutput.sources
  )) {
    outputSources[id] = {
      sourcePath: originalSourcePaths[sourcePath],
      contents: sources[sourcePath],
      ast,
      language: "Vyper"
    };
  }
  return outputSources;
}

function processContracts({
  compilerOutput,
  sources,
  version,
  originalSourcePaths
}) {
  if (!compilerOutput.contracts) return [];
  return (
    Object.entries(compilerOutput.contracts)
      // map to [[{ source, contractName, contract }]]
      .map(([sourcePath, sourceContracts]) =>
        Object.entries(sourceContracts).map(([contractName, contract]) => ({
          // if extension is .py, remove second extension from contract name (HACK)
          contractName:
            path.extname(sourcePath) !== ".py"
              ? contractName
              : path.basename(contractName, path.extname(contractName)),
          contract,
          source: {
            ast: compilerOutput.sources[sourcePath].ast,
            contents: sources[sourcePath],
            sourcePath
          }
        }))
      )
      // and flatten
      .reduce((a, b) => [...a, ...b], [])

      // All source will have a key, but only the compiled source will have
      // the evm output.
      .filter(({ contract: { evm } }) => Object.keys(evm).length > 0)

      // convert to output format
      .map(
        ({
          contractName,
          contract: {
            evm: {
              bytecode: { object: bytecode },
              deployedBytecode: {
                sourceMap: deployedSourceMap,
                object: deployedBytecode
              }
            },
            abi,
            devdoc,
            userdoc
          },
          source: { ast, sourcePath: transformedSourcePath, contents: source }
        }) => ({
          contractName,
          abi,
          devdoc,
          userdoc,
          sourcePath: originalSourcePaths[transformedSourcePath],
          source,
          deployedSourceMap,
          ast,
          bytecode: {
            bytes: bytecode.slice(2), //Vyper uses a "0x" prefix
            linkReferences: [] //no libraries in Vyper
          },
          deployedBytecode: {
            bytes: deployedBytecode.slice(2), //Vyper uses a "0x" prefix
            linkReferences: [] //no libraries in Vyper
          },
          compiler: {
            name: "vyper",
            version
          }
        })
      )
  );
}

function correctPaths(compilerOutput) {
  return {
    compiler: compilerOutput.compiler,
    errors: compilerOutput.errors,
    sources: fixKeys(compilerOutput.sources),
    contracts: fixKeys(compilerOutput.contracts)
  };
}

function fixKeys(pathKeyedObject) {
  return Object.assign(
    {},
    ...Object.entries(pathKeyedObject).map(([key, value]) => ({
      [fixPath(key)]: value
    }))
  );
}

function fixPath(path) {
  if (path[0] === "/") {
    return path;
  } else {
    return "/" + path;
  }
}

module.exports = {
  compileJson,
  execVyperJson
};


/***/ }),

/***/ 418370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pkgVersion = (__webpack_require__(723373)/* .version */ .i8);
var Ajv = __webpack_require__(228849);
var util = __webpack_require__(473837);

var contractObjectSchema = __webpack_require__(885351);
var networkObjectSchema = __webpack_require__(453245);
var abiSchema = __webpack_require__(900);

/**
 * Property definitions for Contract Objects
 *
 * Describes canonical output properties as sourced from some "dirty" input
 * object. Describes normalization process to account for deprecated and/or
 * nonstandard keys and values.
 *
 * Maps (key -> property) where:
 *  - `key` is the top-level output key matching up with those in the schema
 *  - `property` is an object with optional values:
 *      - `sources`: list of sources (see below); default `key`
 *      - `transform`: function(value) -> transformed value; default x -> x
 *
 * Each source represents a means to select a value from dirty object.
 * Allows:
 *  - dot-separated (`.`) string, corresponding to path to value in dirty
 *    object
 *  - function(dirtyObj) -> (cleanValue | undefined)
 *
 * The optional `transform` parameter standardizes value regardless of source,
 * for purposes of ensuring data type and/or string schemas.
 */

// helper that ensures abi's do not contain function signatures
const sanitizedValue = dirtyValueArray => {
  let sanitizedValueArray = [];
  dirtyValueArray.forEach(item => {
    let sanitizedItem = Object.assign({}, item);
    delete sanitizedItem.signature;
    sanitizedValueArray.push(sanitizedItem);
  });
  return sanitizedValueArray;
};

// filter `signature` property from an event
const sanitizeEvent = dirtyEvent =>
  Object.entries(dirtyEvent).reduce(
    (acc, [property, value]) =>
      property === "signature"
        ? acc
        : Object.assign(acc, { [property]: value }),
    {}
  );

// sanitize aggregrate events given a `network-object.spec.json#events` object
const sanitizeAllEvents = dirtyEvents =>
  Object.entries(dirtyEvents).reduce(
    (acc, [property, event]) =>
      Object.assign(acc, { [property]: sanitizeEvent(event) }),
    {}
  );

var properties = {
  contractName: {
    sources: ["contractName", "contract_name"]
  },
  abi: {
    sources: ["abi", "interface"],
    transform: function (value) {
      if (typeof value === "string") {
        try {
          value = JSON.parse(value);
        } catch (_) {
          value = undefined;
        }
      }
      if (Array.isArray(value)) {
        return sanitizedValue(value);
      }
      return value;
    }
  },
  metadata: {
    sources: ["metadata"]
  },
  bytecode: {
    sources: ["bytecode", "binary", "unlinked_binary", "evm.bytecode.object"],
    transform: function (value) {
      if (value && value.indexOf("0x") !== 0) {
        value = "0x" + value;
      }
      return value;
    }
  },
  deployedBytecode: {
    sources: [
      "deployedBytecode",
      "runtimeBytecode",
      "evm.deployedBytecode.object"
    ],
    transform: function (value) {
      if (value && value.indexOf("0x") !== 0) {
        value = "0x" + value;
      }
      return value;
    }
  },
  immutableReferences: {},
  generatedSources: {},
  deployedGeneratedSources: {},
  sourceMap: {
    transform: function (value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (_) {
          return value;
        }
      } else {
        return value;
      }
    },
    sources: ["sourceMap", "srcmap", "evm.bytecode.sourceMap"]
  },
  deployedSourceMap: {
    transform: function (value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (_) {
          return value;
        }
      } else {
        return value;
      }
    },
    sources: [
      "deployedSourceMap",
      "srcmapRuntime",
      "evm.deployedBytecode.sourceMap"
    ]
  },
  source: {},
  sourcePath: {},
  ast: {},
  legacyAST: {},
  compiler: {},
  networks: {
    /**
     * Normalize a networks object. Currently this makes sure `events` are
     * always sanitized and `links` is extracted when copying from
     * a TruffleContract context object.
     *
     * @param {object} value - the target object
     * @param {object | TruffleContract} obj - the context, or source object.
     * @return {object} The normalized Network object
     */
    transform: function (value = {}, obj) {
      // Sanitize value's events for known networks
      Object.keys(value).forEach(networkId => {
        if (value[networkId].events) {
          value[networkId].events = sanitizeAllEvents(value[networkId].events);
        }
      });

      // Set and sanitize the current networks property from the
      // TruffleContract. Note: obj is a TruffleContract if it has
      // `network_id` attribute
      const networkId = obj.network_id;
      if (networkId && value.hasOwnProperty(networkId)) {
        value[networkId].links = obj.links;
        value[networkId].events = sanitizeAllEvents(obj.events);
      }

      return value;
    }
  },
  schemaVersion: {
    sources: ["schemaVersion", "schema_version"]
  },
  updatedAt: {
    sources: ["updatedAt", "updated_at"],
    transform: function (value) {
      if (typeof value === "number") {
        value = new Date(value).toISOString();
      }
      return value;
    }
  },
  networkType: {},
  devdoc: {},
  userdoc: {},
  db: {}
};

/**
 * Construct a getter for a given key, possibly applying some post-retrieve
 * transformation on the resulting value.
 *
 * @return {Function} Accepting dirty object and returning value || undefined
 */
function getter(key, transform) {
  if (transform === undefined) {
    transform = function (x) {
      return x;
    };
  }

  return function (obj) {
    try {
      return transform(obj[key]);
    } catch (_) {
      return undefined;
    }
  };
}

/**
 * Chains together a series of function(obj) -> value, passing resulting
 * returned value to next function in chain.
 *
 * Accepts any number of functions passed as arguments
 * @return {Function} Accepting initial object, returning end-of-chain value
 *
 * Assumes all intermediary values to be objects, with well-formed sequence
 * of operations.
 */
function chain() {
  var getters = Array.prototype.slice.call(arguments);
  return function (obj) {
    return getters.reduce(function (cur, get) {
      return get(cur);
    }, obj);
  };
}

// Schema module
//

var TruffleContractSchema = {
  // Return a promise to validate a contract object
  // - Resolves as validated `contractObj`
  // - Rejects with list of errors from schema validator
  validate: function (contractObj) {
    var ajv = new Ajv({ verbose: true });
    ajv.addSchema(abiSchema);
    ajv.addSchema(networkObjectSchema);
    ajv.addSchema(contractObjectSchema);
    if (ajv.validate("contract-object.spec.json", contractObj)) {
      return contractObj;
    } else {
      const message = `Schema validation failed. Errors:\n\n${ajv.errors
        .map(
          ({
            keyword,
            dataPath,
            schemaPath,
            params,
            message,
            data,
            parentSchema
          }) =>
            util.format(
              "%s (%s):\n%s\n",
              message,
              keyword,
              util.inspect(
                {
                  dataPath,
                  schemaPath,
                  params,
                  data,
                  parentSchema
                },
                { depth: 5 }
              )
            )
        )
        .join("\n")}`;
      const error = new Error(message);
      error.errors = ajv.errors;
      throw error;
    }
  },

  // accepts as argument anything that can be turned into a contract object
  // returns a contract object
  normalize: function (objDirty, options) {
    options = options || {};
    var normalized = {};

    // iterate over each property
    Object.keys(properties).forEach(function (key) {
      var property = properties[key];
      var value; // normalized value || undefined

      // either used the defined sources or assume the key will only ever be
      // listed as its canonical name (itself)
      var sources = property.sources || [key];

      // iterate over sources until value is defined or end of list met
      for (var i = 0; value === undefined && i < sources.length; i++) {
        var source = sources[i];
        // string refers to path to value in objDirty, split and chain
        // getters
        if (typeof source === "string") {
          var traversals = source.split(".").map(function (k) {
            return getter(k);
          });
          source = chain.apply(null, traversals);
        }

        // source should be a function that takes the objDirty and returns
        // value or undefined
        value = source(objDirty);
      }

      // run source-agnostic transform on value
      // (e.g. make sure bytecode begins 0x)
      if (property.transform) {
        value = property.transform(value, objDirty);
      }

      // add resulting (possibly undefined) to normalized obj
      normalized[key] = value;
    });

    // Copy x- options
    Object.keys(objDirty).forEach(function (key) {
      if (key.indexOf("x-") === 0) {
        normalized[key] = getter(key)(objDirty);
      }
    });

    // update schema version
    normalized.schemaVersion = pkgVersion;

    if (options.validate) {
      this.validate(normalized);
    }

    return normalized;
  }
};

module.exports = TruffleContractSchema;


/***/ }),

/***/ 378883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Schema = __webpack_require__(418370);
const Contract = __webpack_require__(807974);
const truffleContractVersion = (__webpack_require__(354720)/* .version */ .i8);

const contract = (json = {}) => {
  const normalizedArtifactObject = Schema.normalize(json);

  // Note we don't use `new` here at all. This will cause the class to
  // "mutate" instead of instantiate an instance.
  return Contract.clone(normalizedArtifactObject);
};

contract.version = truffleContractVersion;

module.exports = contract;

if (typeof window !== "undefined") {
  window.TruffleContract = contract;
}


/***/ }),

/***/ 85210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const execute = __webpack_require__(141441);
const debug = __webpack_require__(615158)("contract:contract:bootstrap");

module.exports = fn => {
  // Add our static methods
  // Add something here about excluding send, privately defined methods
  Object.keys(fn._constructorMethods).forEach(function (key) {
    fn[key] = fn._constructorMethods[key].bind(fn);
  });

  // Add our properties.
  Object.keys(fn._properties).forEach(function (key) {
    fn.addProp(key, fn._properties[key]);
  });

  // estimateGas & request as sub-property of new
  fn["new"].estimateGas = execute.estimateDeployment.bind(fn);
  fn["new"].request = execute.requestDeployment.bind(fn);

  //add enumerations. (probably these should go in
  //constructorMethods.js, but this is easier to modify... we'll
  //redo all this in the rewrite anyway)
  if (fn._json) {
    //getters will throw otherwise!
    if (fn.ast) {
      //note this was set up earlier
      const node = locateNode(fn.contractName, fn.ast); //name also set up earlier
      if (node) {
        fn.enums = extractEnums(node);
        for (const [name, enumeration] of Object.entries(fn.enums)) {
          //enum is a reserved word :P
          if (!(name in fn)) {
            //don't overwrite anything!
            fn[name] = enumeration;
          }
        }
      }
    }
  }

  return fn;
};

function locateNode(name, ast) {
  if (ast.nodeType === "SourceUnit") {
    return ast.nodes.find(
      node => node.nodeType === "ContractDefinition" && node.name === name
    );
  } else {
    return undefined;
  }
}

function extractEnums(node) {
  return Object.assign(
    {},
    ...node.nodes
      .filter(definition => definition.nodeType === "EnumDefinition")
      .map(definition => ({
        [definition.name]: Object.assign(
          {},
          ...definition.members.map((member, index) => ({[member.name]: index}))
        )
      }))
  );
}


/***/ }),

/***/ 402629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const utils = __webpack_require__(913735);
const execute = __webpack_require__(141441);
const bootstrap = __webpack_require__(85210);
const debug = __webpack_require__(615158)("contract:contract:constructorMethods");
const OS = __webpack_require__(822037);

module.exports = Contract => ({
  configureNetwork({ networkType, provider } = {}) {
    // otherwise use existing value as default (at most one of these)
    networkType = networkType || this.networkType;
    provider = provider || this.currentProvider;

    // recreate interfaceadapter
    this.interfaceAdapter = createInterfaceAdapter({ networkType, provider });

    if (this.web3) {
      // update existing
      this.web3.setNetworkType(networkType);
      this.web3.setProvider(provider);
    } else {
      // create new
      this.web3 = new Web3Shim({ networkType, provider });
    }

    // save properties
    this.currentProvider = provider;
    this.networkType = networkType;
  },

  setProvider(provider) {
    if (!provider) {
      throw new Error(
        `Invalid provider passed to setProvider(); provider is ${provider}`
      );
    }

    this.configureNetwork({ provider });
  },

  new() {
    utils.checkProvider(this);

    if (!this.bytecode || this.bytecode === "0x") {
      throw new Error(
        `${this.contractName} error: contract binary not set. Can't deploy new instance.\n` +
          `This contract may be abstract, not implement an abstract parent's methods completely\n` +
          `or not invoke an inherited contract's constructor correctly\n`
      );
    }

    var constructorABI = this.abi.filter(i => i.type === "constructor")[0];

    return execute.deploy.call(this, constructorABI)(...arguments);
  },

  async at(address) {
    if (
      address == null ||
      typeof address !== "string" ||
      address.length !== 42
    ) {
      throw new Error(
        `Invalid address passed to ${this.contractName}.at(): ${address}`
      );
    }

    await this.detectNetwork();
    const onChainCode = await this.interfaceAdapter.getCode(address);
    await utils.checkCode(onChainCode, this.contractName, address);
    return new this(address);
  },

  async deployed() {
    if (this.reloadJson) {
      this.reloadJson(); //truffle test monkey-patches in this method
    }
    utils.checkProvider(this);
    await this.detectNetwork();
    utils.checkNetworkArtifactMatch(this);
    utils.checkDeployment(this);
    return new this(this.address);
  },

  defaults(class_defaults) {
    if (this.class_defaults == null) {
      this.class_defaults = {};
    }

    if (class_defaults == null) {
      class_defaults = {};
    }

    Object.keys(class_defaults).forEach(key => {
      const value = class_defaults[key];
      this.class_defaults[key] = value;
    });

    return this.class_defaults;
  },

  hasNetwork(network_id) {
    return this._json.networks[`${network_id}`] != null;
  },

  isDeployed() {
    if (this.network_id == null) {
      return false;
    }

    if (this._json.networks[this.network_id] == null) {
      return false;
    }

    return !!this.network.address;
  },

  async detectNetwork() {
    // guard interfaceAdapter!
    if (this.interfaceAdapter == null) {
      throw new Error("Provider not set or invalid");
    }
    // if artifacts already have a network_id and network configuration synced,
    // use that network and use latest block gasLimit
    if (this.network_id && this.networks[this.network_id] != null) {
      const { gasLimit } = await this.interfaceAdapter.getBlock("latest");
      return { id: this.network_id, blockLimit: gasLimit };
    }
    // since artifacts don't have a network_id synced with a network configuration,
    // poll chain for network_id and sync artifacts
    const chainNetworkID = await this.interfaceAdapter.getNetworkId();
    const { gasLimit } = await this.interfaceAdapter.getBlock("latest");
    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);
  },

  setNetwork(network_id) {
    if (!network_id) return;
    this.network_id = `${network_id}`;
  },

  setNetworkType(networkType = "ethereum") {
    this.configureNetwork({ networkType });
  },

  setWallet(wallet) {
    this.configureNetwork();

    this.web3.eth.accounts.wallet = wallet;
  },

  // Overrides the deployed address to null.
  // You must call this explicitly so you don't inadvertently do this otherwise.
  resetAddress() {
    delete this.network.address;
  },

  // accepts 4 input formats
  //  - (<name>, <address>)
  //  - (<contractType>) - must have a deployed instance with an address
  //  - (<contractInstance>)
  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })
  link(name, address) {
    switch (typeof name) {
      case "string":
        // Case: Contract.link(<libraryName>, <address>)
        if (this._json.networks[this.network_id] == null) {
          this._json.networks[this.network_id] = {
            events: {},
            links: {}
          };
        }

        this.network.links[name] = address;
        return;
      case "function":
        // Case: Contract.link(<contractType>)
        const contract = name;

        if (contract.isDeployed() === false) {
          throw new Error("Cannot link contract without an address.");
        }

        this.link(contract.contractName, contract.address);

        // Merge events so this contract knows about library's events
        Object.keys(contract.events).forEach(topic => {
          this.network.events[topic] = contract.events[topic];
        });
        return;
      case "object":
        // 2 Cases:
        //   - Contract.link({<libraryName>: <address>, ... })
        //   - Contract.link(<instance>)
        const obj = name;
        if (
          obj.constructor &&
          typeof obj.constructor.contractName === "string" &&
          obj.address
        ) {
          // obj is a Truffle contract instance
          this.link(obj.constructor.contractName, obj.address);
        } else {
          // obj is of the form { <libraryName>: <address>, ... }
          Object.keys(obj).forEach(name => this.link(name, obj[name]));
        }
        return;
      default:
        const invalidInput =
          `Input to the link method is in the incorrect` +
          ` format. Input must be one of the following:${OS.EOL}` +
          `    - a library name and address                 > ("MyLibrary", ` +
          `"0x123456789...")${OS.EOL}` +
          `    - a contract type                            > ` +
          `(MyContract)${OS.EOL}` +
          `    - a contract instance                        > ` +
          `(myContract)${OS.EOL}` +
          `    - an object with library names and addresses > ({ <libName>: ` +
          `<address>, <libName2>: <address2>, ... })${OS.EOL}`;
        throw new Error(invalidInput);
    }
  },

  // Note, this function can be called with two input types:
  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.
  // 2. network id; this will clone the contract and set a specific network id upon cloning.
  clone(json) {
    json = json || {};

    const temp = function TruffleContract() {
      this.constructor = temp;
      return Contract.apply(this, arguments);
    };

    temp.prototype = Object.create(this.prototype);

    let network_id;

    // If we have a network id passed
    if (typeof json !== "object") {
      network_id = json;
      json = this._json;
    }

    json = utils.merge({}, this._json || {}, json);

    temp._constructorMethods = this._constructorMethods;
    temp._properties = this._properties;

    temp._property_values = {};
    temp._json = json;

    bootstrap(temp);

    temp.class_defaults = temp.prototype.defaults || {};

    if (network_id) {
      temp.setNetwork(network_id);
    }

    if (this.currentProvider) {
      temp.configureNetwork({
        provider: this.currentProvider,
        networkType: this.networkType
      });
    }

    // Copy over custom key/values to the contract class
    Object.keys(json).forEach(key => {
      if (key.indexOf("x-") !== 0) return;
      temp[key] = json[key];
    });

    return temp;
  },

  addProp(key, fn) {
    const getter = () => {
      if (fn.get != null) {
        return fn.get.call(this);
      }

      return this._property_values[key] || fn.call(this);
    };

    const setter = val => {
      if (fn.set != null) {
        fn.set.call(this, val);
        return;
      }

      // If there's not a setter, then the property is immutable.
      throw new Error(`${key} property is immutable`);
    };

    const definition = {};
    definition.enumerable = false;
    definition.configurable = false;
    definition.get = getter;
    definition.set = setter;

    Object.defineProperty(this, key, definition);
  },

  toJSON() {
    return this._json;
  },

  decodeLogs: utils.decodeLogs
});


/***/ }),

/***/ 807974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
const debug = __webpack_require__(615158)("contract:contract");
let Web3 = __webpack_require__(503283);
const webUtils = __webpack_require__(118269);
const execute = __webpack_require__(141441);
const bootstrap = __webpack_require__(85210);
const constructorMethods = __webpack_require__(402629);
const properties = __webpack_require__(40920);

// For browserified version. If browserify gave us an empty version,
// look for the one provided by the user.
if (typeof Web3 === "object" && Object.keys(Web3).length === 0) {
  Web3 = global.Web3;
}

(function (module) {
  // Accepts a contract object created with web3.eth.Contract or an address.
  function Contract(contract) {
    var instance = this;
    var constructor = instance.constructor;

    // Disambiguate between .at() and .new()
    if (typeof contract === "string") {
      var web3Instance = new constructor.web3.eth.Contract(constructor.abi);
      web3Instance.options.address = contract;
      contract = web3Instance;
    }

    // Core:
    instance.methods = {};
    instance.abi = constructor.abi;
    instance.address = contract.options.address;
    instance.transactionHash = contract.transactionHash;
    instance.contract = contract;

    //for stacktracing in tests
    if (constructor.debugger) {
      instance.debugger = constructor.debugger;
    }

    // User defined methods, overloaded methods, events
    instance.abi.forEach(function (item) {
      switch (item.type) {
        case "function":
          var isConstant =
            ["pure", "view"].includes(item.stateMutability) || item.constant; // new form // deprecated case

          var signature = webUtils._jsonInterfaceMethodToString(item);

          var method = function (constant, web3Method) {
            var fn;

            constant
              ? (fn = execute.call.call(
                  constructor,
                  web3Method,
                  item,
                  instance.address
                ))
              : (fn = execute.send.call(
                  constructor,
                  web3Method,
                  item,
                  instance.address
                ));

            fn.call = execute.call.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.sendTransaction = execute.send.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.estimateGas = execute.estimate.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.request = execute.request.call(
              constructor,
              web3Method,
              item,
              instance.address
            );

            return fn;
          };

          // Only define methods once. Any overloaded methods will have all their
          // accessors available by ABI signature available on the `methods` key below.
          if (instance[item.name] === undefined) {
            instance[item.name] = method(
              isConstant,
              contract.methods[item.name]
            );
          }

          // Overloaded methods should be invoked via the .methods property
          instance.methods[signature] = method(
            isConstant,
            contract.methods[signature]
          );
          break;

        case "event":
          instance[item.name] = execute.event.call(
            constructor,
            contract.events[item.name]
          );
          break;
      }
    });

    // sendTransaction / send
    instance.sendTransaction = execute.send.call(
      constructor,
      null,
      null,
      instance.address
    );

    // Prefer user defined `send`
    if (!instance.send) {
      instance.send = (value, txParams = {}) => {
        const packet = Object.assign({value: value}, txParams);
        return instance.sendTransaction(packet);
      };
    }

    // Other events
    instance.allEvents = execute.allEvents.call(constructor, contract);
    instance.getPastEvents = execute.getPastEvents.call(constructor, contract);
  }

  Contract._constructorMethods = constructorMethods(Contract);

  // Getter functions are scoped to Contract object.
  Contract._properties = properties;

  bootstrap(Contract);
  module.exports = Contract;

  return Contract;
})(module || {});


/***/ }),

/***/ 40920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const utils = __webpack_require__(913735);
const web3Utils = __webpack_require__(118269);

module.exports = {
  contract_name: {
    get: function () {
      return this.contractName;
    },
    set: function (val) {
      this.contractName = val;
    }
  },
  contractName: {
    get: function () {
      return this._json.contractName || "Contract";
    },
    set: function (val) {
      this._json.contractName = val;
    }
  },

  gasMultiplier: {
    get: function () {
      if (this._json.gasMultiplier === undefined) {
        this._json.gasMultiplier = 1.25;
      }
      return this._json.gasMultiplier;
    },
    set: function (val) {
      this._json.gasMultiplier = val;
    }
  },
  timeoutBlocks: {
    get: function () {
      return this._json.timeoutBlocks;
    },
    set: function (val) {
      this._json.timeoutBlocks = val;
    }
  },
  autoGas: {
    get: function () {
      if (this._json.autoGas === undefined) {
        this._json.autoGas = true;
      }
      return this._json.autoGas;
    },
    set: function (val) {
      this._json.autoGas = val;
    }
  },
  numberFormat: {
    get: function () {
      if (this._json.numberFormat === undefined) {
        this._json.numberFormat = "BN";
      }
      return this._json.numberFormat;
    },
    set: function (val) {
      const allowedFormats = ["BigNumber", "BN", "String", "BigInt"];

      const msg =
        `Invalid number format setting: "${val}": ` +
        `valid formats are: ${JSON.stringify(allowedFormats)}.`;

      if (!allowedFormats.includes(val)) throw new Error(msg);

      this._json.numberFormat = val;
    }
  },
  abi: {
    get: function () {
      return this._json.abi;
    },
    set: function (val) {
      this._json.abi = val;
    }
  },
  metadata: function () {
    return this._json.metadata;
  },
  network: function () {
    var network_id = this.network_id;

    if (network_id == null) {
      var error =
        this.contractName +
        " has no network id set, cannot lookup artifact data." +
        " Either set the network manually using " +
        this.contractName +
        ".setNetwork(), run " +
        this.contractName +
        ".detectNetwork(), or use new()," +
        " at() or deployed() as a thenable which will detect the network automatically.";

      throw new Error(error);
    }

    // TODO: this might be bad; setting a value on a get.
    if (this._json.networks[network_id] == null) {
      var error =
        this.contractName +
        " has no network configuration" +
        " for its current network id (" +
        network_id +
        ").";

      throw new Error(error);
    }

    var returnVal = this._json.networks[network_id];

    // Normalize output
    if (returnVal.links == null) {
      returnVal.links = {};
    }

    if (returnVal.events == null) {
      returnVal.events = {};
    }

    return returnVal;
  },
  networks: function () {
    return this._json.networks;
  },
  address: {
    get: function () {
      var address = this.network.address;

      if (address == null) {
        var error =
          "Cannot find deployed address: " +
          this.contractName +
          " not deployed or address not set.";
        throw new Error(error);
      }

      return address;
    },
    set: function (val) {
      if (val == null) {
        throw new Error("Cannot set deployed address; malformed value: " + val);
      }

      var network_id = this.network_id;

      if (network_id == null) {
        var error =
          this.contractName +
          " has no network id set, cannot lookup artifact data." +
          " Either set the network manually using " +
          this.contractName +
          ".setNetwork(), run " +
          this.contractName +
          ".detectNetwork()," +
          " or use new(), at() or deployed() as a thenable which will" +
          " detect the network automatically.";

        throw new Error(error);
      }

      // Create a network if we don't have one.
      if (this._json.networks[network_id] == null) {
        this._json.networks[network_id] = {
          events: {},
          links: {}
        };
      }

      // Finally, set the address.
      this.network.address = val;
    }
  },
  transactionHash: {
    get: function () {
      return this.network.transactionHash;
    },
    set: function (val) {
      this.network.transactionHash = val;
    }
  },
  links: function () {
    if (!this.network_id) {
      var error =
        this.contractName +
        " has no network id set, cannot lookup artifact data." +
        " Either set the network manually using " +
        this.contractName +
        ".setNetwork()," +
        " run " +
        this.contractName +
        ".detectNetwork(), or use new(), at()" +
        " or deployed() as a thenable which will detect the network automatically.";

      throw new Error(error);
    }

    if (this._json.networks[this.network_id] == null) {
      return {};
    }

    return this.network.links || {};
  },
  events: function () {
    var events;

    if (this._json.networks[this.network_id] == null) {
      events = {};
    } else {
      events = this.network.events || {};
    }

    // Merge abi events with whatever's returned.
    var abi = this.abi;

    abi.forEach(function (item) {
      if (item.type !== "event") return;

      if (item.signature) {
        events[item.signature] = item;
      } else {
        var signature = item.name + "(";

        item.inputs.forEach(function (input, index) {
          signature += input.type;

          if (index < item.inputs.length - 1) {
            signature += ",";
          }
        });

        signature += ")";

        var topic = web3Utils.keccak256(signature);

        events[topic] = item;
      }
    });

    return events;
  },
  binary: function () {
    return utils.linkBytecode(this.bytecode, this.links);
  },
  deployedBinary: function () {
    return utils.linkBytecode(this.deployedBytecode, this.links);
  },

  // deprecated; use bytecode
  unlinked_binary: {
    get: function () {
      return this.bytecode;
    },
    set: function (val) {
      this.bytecode = val;
    }
  },
  // alias for unlinked_binary; unlinked_binary will eventually be deprecated
  bytecode: {
    get: function () {
      return this._json.bytecode;
    },
    set: function (val) {
      this._json.bytecode = val;
    }
  },
  deployedBytecode: {
    get: function () {
      var code = this._json.deployedBytecode;

      if (!code) {
        return code;
      }

      if (code.indexOf("0x") !== 0) {
        code = "0x" + code;
      }

      return code;
    },
    set: function (val) {
      var code = val;

      if (val && val.indexOf("0x") !== 0) {
        code = "0x" + code;
      }

      this._json.deployedBytecode = code;
    }
  },
  sourceMap: {
    get: function () {
      return this._json.sourceMap;
    },
    set: function (val) {
      this._json.sourceMap = val;
    }
  },
  deployedSourceMap: {
    get: function () {
      return this._json.deployedSourceMap;
    },
    set: function (val) {
      this._json.deployedSourceMap = val;
    }
  },
  source: {
    get: function () {
      return this._json.source;
    },
    set: function (val) {
      this._json.source = val;
    }
  },
  sourcePath: {
    get: function () {
      return this._json.sourcePath;
    },
    set: function (val) {
      this._json.sourcePath = val;
    }
  },
  legacyAST: {
    get: function () {
      return this._json.legacyAST;
    },
    set: function (val) {
      this._json.legacyAST = val;
    }
  },
  ast: {
    get: function () {
      return this._json.ast;
    },
    set: function (val) {
      this._json.ast = val;
    }
  },
  compiler: {
    get: function () {
      return this._json.compiler;
    },
    set: function (val) {
      this._json.compiler = val;
    }
  },
  // Deprecated
  schema_version: function () {
    return this.schemaVersion;
  },
  schemaVersion: function () {
    return this._json.schemaVersion;
  },
  // deprecated
  updated_at: function () {
    return this.updatedAt;
  },
  updatedAt: function () {
    try {
      return this.network.updatedAt || this._json.updatedAt;
    } catch (e) {
      return this._json.updatedAt;
    }
  },
  userdoc: function () {
    return this._json.userdoc;
  },
  devdoc: function () {
    return this._json.devdoc;
  },
  networkType: {
    get: function () {
      return this._json.networkType || "ethereum";
    },
    set: function (_networkType) {
      this._json.networkType = _networkType;
    }
  },
  immutableReferences: {
    get: function () {
      return this._json.immutableReferences;
    },
    set: function (refs) {
      this._json.immutableReferences = refs;
    }
  },
  generatedSources: {
    get: function () {
      return this._json.generatedSources;
    },
    set: function (sources) {
      this._json.generatedSources = sources;
    }
  },
  deployedGeneratedSources: {
    get: function () {
      return this._json.deployedGeneratedSources;
    },
    set: function (sources) {
      this._json.deployedGeneratedSources = sources;
    }
  },
  db: {
    get: function () {
      return this._json.db;
    },
    set: function (db) {
      this._json.db = db;
    }
  }
};


/***/ }),

/***/ 141441:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("contract:execute");
const PromiEvent = __webpack_require__(420302);
const EventEmitter = __webpack_require__(582361);
const utils = __webpack_require__(913735);
const StatusError = __webpack_require__(460550);
const Reason = __webpack_require__(812630);
const handlers = __webpack_require__(399198);
const override = __webpack_require__(547009);
const reformat = __webpack_require__(190908);
const { sendTransactionManual } = __webpack_require__(895945);

const execute = {
  // -----------------------------------  Helpers --------------------------------------------------
  /**
   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.
   * Lacking an estimate, sets gas to have of latest blockLimit
   * @param  {Object} params     `sendTransaction` parameters
   * @param  {Number} blockLimit  most recent network block.blockLimit
   * @return {Number}             gas estimate
   */
  getGasEstimate: function (params, blockLimit, stacktrace = false) {
    const constructor = this;
    const interfaceAdapter = this.interfaceAdapter;

    return new Promise(function (accept) {
      // Always prefer gas specified by user (if a user sets gas to 0, that is treated
      // as undefined here and we do proceed to do gas estimation)
      if (params.gas) return accept(params.gas);
      if (!constructor.autoGas) return accept();

      interfaceAdapter
        .estimateGas(params, stacktrace)
        .then(gas => {
          // there are situations where the web3 gas estimation function in interfaceAdapter
          // fails, specifically when a transaction will revert; we still want to continue
          // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a
          // default gas for that situation, equal to half of the blockLimit for the latest block
          //
          // note: this means if a transaction will revert but the user does not have stacktracing enabled,
          // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this
          if (gas === null) {
            const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));
            accept(defaultGas.toHexString());
          } else {
            const limit = utils.bigNumberify(blockLimit);
            // if we did get a numerical gas estimate from interfaceAdapter, we
            // multiply that estimate by the gasMultiplier to help ensure we
            // have enough gas for the transaction
            const bestEstimate = utils.multiplyBigNumberByDecimal(
              utils.bigNumberify(gas),
              constructor.gasMultiplier
            );
            // Check that we don't go over blockLimit
            bestEstimate.gte(limit)
              ? accept(limit.sub(1).toHexString())
              : accept(bestEstimate.toHexString());
          }
        })
        .catch(() => accept());
    });
  },

  /**
   * Prepares simple wrapped calls by checking network and organizing the method inputs into
   * objects web3 can consume.
   * @param  {Object} constructor   TruffleContract constructor
   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.
   * @param  {Array}  _arguments    Arguments passed to method invocation
   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;
   *                                  skips network checks and ignores default gas prices
   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments
   */
  prepareCall: async function (constructor, methodABI, _arguments, isCall) {
    let args = Array.prototype.slice.call(_arguments);
    let params = utils.getTxParams.call(constructor, methodABI, args, isCall);

    args = utils.convertToEthersBN(args);

    if (constructor.ens && constructor.ens.enabled) {
      const { web3 } = constructor;
      const processedValues = await utils.ens.convertENSNames({
        networkId: constructor.network_id,
        ens: constructor.ens,
        inputArgs: args,
        inputParams: params,
        methodABI,
        web3
      });
      args = processedValues.args;
      params = processedValues.params;
    }
    //isCall flag used to skip network call for read data (calls type) methods invocation
    if (isCall) {
      return { args, params };
    }
    const network = await constructor.detectNetwork();
    return { args, params, network };
  },

  /**
   * Disambiguates between transaction parameter objects and BN / BigNumber objects
   * @param  {Any}  arg
   * @return {Boolean}
   */
  hasTxParams: function (arg) {
    return utils.is_object(arg) && !utils.is_big_number(arg);
  },

  /**
   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`
   * to execute a call at.
   * @param  {Array}  args      `arguments` that were passed to method
   * @param  {Any}    lastArg    terminal argument passed to method
   * @param  {Array}  inputs     ABI segment defining method arguments
   * @return {Boolean}           true if final argument is `defaultBlock`
   */
  hasDefaultBlock: function (args, lastArg, inputs) {
    const hasDefaultBlock =
      !execute.hasTxParams(lastArg) && args.length > inputs.length;
    const hasDefaultBlockWithParams =
      execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;
    return hasDefaultBlock || hasDefaultBlockWithParams;
  },

  // -----------------------------------  Methods --------------------------------------------------

  /**
   * Executes method as .call and processes optional `defaultBlock` argument.
   * @param  {Function} fn         method
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}             Return value of the call.
   */
  call: function (fn, methodABI, address) {
    const constructor = this;

    return function () {
      let defaultBlock = constructor.web3.eth.defaultBlock || "latest";
      const args = Array.prototype.slice.call(arguments);
      const lastArg = args[args.length - 1];
      const promiEvent = new PromiEvent();

      // Extract defaultBlock parameter
      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {
        defaultBlock = args.pop();
      }
      //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation
      const skipNetworkCheck = true;
      execute
        .prepareCall(constructor, methodABI, args, skipNetworkCheck)
        .then(async ({ args, params }) => {
          let result;

          params.to = address;

          promiEvent.eventEmitter.emit("execute:call:method", {
            fn: fn,
            args: args,
            address: address,
            abi: methodABI,
            contract: constructor
          });

          result = await fn(...args).call(params, defaultBlock);
          result = reformat.numbers.call(
            constructor,
            result,
            methodABI.outputs
          );
          return promiEvent.resolve(result);
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Executes method as .send
   * @param  {Function} fn         Method to invoke
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @param  {String}   address    Deployed address of the targeted instance
   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)
   */
  send: function (fn, methodABI, address) {
    const constructor = this;
    const web3 = constructor.web3;

    return function () {
      const promiEvent = new PromiEvent(false, constructor.debugger);

      execute
        .prepareCall(constructor, methodABI, arguments)
        .then(async ({ args, params, network }) => {
          const context = {
            contract: constructor, // Can't name this field `constructor` or `_constructor`
            promiEvent: promiEvent,
            params: params
          };

          params.to = address;
          params.data = fn ? fn(...args).encodeABI() : params.data;

          promiEvent.eventEmitter.emit("execute:send:method", {
            fn,
            args,
            address,
            abi: methodABI,
            contract: constructor
          });

          const stacktrace = promiEvent.debug ? promiEvent.debug : false;
          try {
            params.gas = await execute.getGasEstimate.call(
              constructor,
              params,
              network.blockLimit,
              stacktrace
            );
          } catch (error) {
            promiEvent.reject(error);
            return;
          }

          execute
            .sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...
            .then(receipt => {
              if (promiEvent.debug) {
                // in this case, we need to manually invoke the handler since it
                // hasn't been set up (hack?)
                handlers.receipt(context, receipt);
              }
              //otherwise, just let the handlers handle things
            })
            .catch(override.start.bind(constructor, context));
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Deploys an instance
   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys
   * @return {PromiEvent}             Resolves a TruffleContract instance
   */
  deploy: function (constructorABI) {
    const constructor = this;
    const web3 = constructor.web3;

    return function () {
      let deferred;
      const promiEvent = new PromiEvent(false, constructor.debugger, true);

      execute
        .prepareCall(constructor, constructorABI, arguments)
        .then(async ({ args, params, network }) => {
          const { blockLimit } = network;

          utils.checkLibraries.apply(constructor);

          // Promievent and flag that allows instance to resolve (rather than just receipt)
          const context = {
            contract: constructor,
            promiEvent,
            onlyEmitReceipt: true
          };

          const options = {
            data: constructor.binary,
            arguments: args
          };

          const contract = new web3.eth.Contract(constructor.abi);
          params.data = contract.deploy(options).encodeABI();
          const stacktrace = promiEvent.debug ? promiEvent.debug : false;

          params.gas = await execute.getGasEstimate.call(
            constructor,
            params,
            blockLimit,
            stacktrace
          );

          context.params = params;

          promiEvent.eventEmitter.emit("execute:deploy:method", {
            args,
            abi: constructorABI,
            contract: constructor
          });

          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...

          try {
            const receipt = await deferred;
            if (receipt.status !== undefined && !receipt.status) {
              const reason = await Reason.get(params, web3);

              const error = new StatusError(
                params,
                context.transactionHash,
                receipt,
                reason
              );

              return context.promiEvent.reject(error);
            }

            const web3Instance = new web3.eth.Contract(
              constructor.abi,
              receipt.contractAddress
            );
            web3Instance.transactionHash = context.transactionHash;

            context.promiEvent.resolve(new constructor(web3Instance));
          } catch (web3Error) {
            // Manage web3's 50 blocks' timeout error.
            // Web3's own subscriptions go dead here.
            await override.start.call(constructor, context, web3Error);
          }
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Begins listening for an event OR manages the event callback
   * @param  {Function} fn  Solidity event method
   * @return {Emitter}      Event emitter
   */
  event: function (fn) {
    const constructor = this;
    const decode = utils.decodeLogs;
    let currentLogID = null;

    // Someone upstream is firing duplicates :/
    function dedupe(id) {
      return id === currentLogID ? false : (currentLogID = id);
    }

    return function (params, callback) {
      if (typeof params === "function") {
        callback = params;
        params = {};
      }

      // As callback
      if (callback !== undefined) {
        const intermediary = function (err, e) {
          if (err) return callback(err);
          if (!dedupe(e.id)) return;
          callback(null, decode.call(constructor, e, true)[0]);
        };

        return constructor
          .detectNetwork()
          .then(() => fn.call(constructor.events, params, intermediary));
      }

      // As EventEmitter
      const emitter = new EventEmitter();

      constructor.detectNetwork().then(() => {
        const event = fn(params);

        event.on(
          "data",
          e =>
            dedupe(e.id) &&
            emitter.emit("data", decode.call(constructor, e, true)[0])
        );
        event.on(
          "changed",
          e =>
            dedupe(e.id) &&
            emitter.emit("changed", decode.call(constructor, e, true)[0])
        );
        event.on("error", e => emitter.emit("error", e));
      });

      return emitter;
    };
  },

  /**
   * Wraps web3 `allEvents`, with additional log decoding
   * @return {PromiEvent}  EventEmitter
   */
  allEvents: function (web3Instance) {
    const constructor = this;
    const decode = utils.decodeLogs;
    let currentLogID = null;

    // Someone upstream is firing duplicates :/
    function dedupe(id) {
      return id === currentLogID ? false : (currentLogID = id);
    }

    return function (params) {
      const emitter = new EventEmitter();

      constructor.detectNetwork().then(() => {
        const event = web3Instance.events.allEvents(params);

        event.on(
          "data",
          e =>
            dedupe(e.id) &&
            emitter.emit("data", decode.call(constructor, e, true)[0])
        );
        event.on(
          "changed",
          e =>
            dedupe(e.id) &&
            emitter.emit("changed", decode.call(constructor, e, true)[0])
        );
        event.on("error", e => emitter.emit("error", e));
      });

      return emitter;
    };
  },

  /**
   * Wraps web3 `getPastEvents`, with additional log decoding
   * @return {Promise}  Resolves array of event objects
   */
  getPastEvents: function (web3Instance) {
    const constructor = this;
    const decode = utils.decodeLogs;

    return function (event, options) {
      return web3Instance
        .getPastEvents(event, options)
        .then(events => decode.call(constructor, events, false));
    };
  },

  /**
   * Estimates gas cost of a method invocation
   * @param  {Function} fn  Method to target
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}
   */
  estimate: function (fn, methodABI) {
    const constructor = this;
    return function () {
      return execute
        .prepareCall(constructor, methodABI, arguments)
        .then(res => fn(...res.args).estimateGas(res.params));
    };
  },

  /**
   *
   * @param  {Function} fn  Method to target
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}
   */
  request: function (fn, methodABI, address) {
    const constructor = this;
    return function () {
      return execute
        .prepareCall(constructor, methodABI, arguments)
        .then(res => {
          //clone res.params
          let tx = {};
          for (let key in res.params) {
            tx[key] = res.params[key];
          }
          //set to
          tx.to = address;
          //set data
          tx.data = fn(...res.args).encodeABI();
          return tx;
        });
    };
  },

  // This gets attached to `.new` (declared as a static_method in `contract`)
  // during bootstrapping as `estimateGas`
  estimateDeployment: function () {
    const constructor = this;

    const constructorABI = constructor.abi.filter(
      i => i.type === "constructor"
    )[0];

    return execute
      .prepareCall(constructor, constructorABI, arguments)
      .then(res => {
        const options = {
          data: constructor.binary,
          arguments: res.args
        };

        delete res.params["data"]; // Is this necessary?

        const instance = new constructor.web3.eth.Contract(
          constructor.abi,
          res.params
        );
        return instance.deploy(options).estimateGas(res.params);
      });
  },

  // This gets attached to `.new` (declared as a static_method in `contract`)
  // during bootstrapping as `request`
  requestDeployment: function () {
    const constructor = this;

    const constructorABI = constructor.abi.filter(
      i => i.type === "constructor"
    )[0];

    return execute
      .prepareCall(constructor, constructorABI, arguments)
      .then(res => {
        //clone res.params
        let tx = {};
        for (let key in res.params) {
          tx[key] = res.params[key];
        }

        const options = {
          data: constructor.binary,
          arguments: res.args
        };

        const instance = new constructor.web3.eth.Contract(
          constructor.abi,
          res.params
        );
        tx.data = instance.deploy(options).encodeABI();
        return tx;
      });
  },

  //our own custom sendTransaction function, made to mimic web3's,
  //while also being able to do things, like, say, store the transaction
  //hash even in case of failure.  it's not as powerful in some ways,
  //as it just returns an ordinary Promise rather than web3's PromiEvent,
  //but it's more suited to our purposes (we're not using that PromiEvent
  //functionality here anyway)
  //input works the same as input to web3.sendTransaction
  //(well, OK, it's lacking some things there too, but again, good enough
  //for our purposes)
  sendTransaction: async function (web3, params, promiEvent, context) {
    //if we don't need the debugger, let's not risk any errors on our part,
    //and just have web3 do everything
    if (!promiEvent || !promiEvent.debug) {
      const deferred = web3.eth.sendTransaction(params);
      handlers.setup(deferred, context);
      return deferred;
    }
    //otherwise, do things manually!
    //(and skip the PromiEvent stuff :-/ )
    return sendTransactionManual(web3, params, promiEvent);
  }
};

module.exports = execute;


/***/ }),

/***/ 399198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("contract:handlers");
const StatusError = __webpack_require__(460550);
const Utils = __webpack_require__(913735);
const Reason = __webpack_require__(812630);

/*
  Handlers for events emitted by `send` / `call` etc.
 */
const handlers = {
  // ----------------------------------- Constants -------------------------------------------------

  maxConfirmations: 24, // Maximum number of confirmation web3 emits
  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx
  timeoutMessage: "50 blocks", // Substring of web3 timeout error.
  defaultWeb3Error: "please check your gas limit", // Substring of default Web3 error

  // -----------------------------------  Helpers --------------------------------------------------

  /**
   * Parses error message and determines if we should squash web3 timeout errors at user's request.
   * @param  {Object} contract contract instance
   * @param  {Object} message  error message
   * @return {Boolean}
   */
  ignoreTimeoutError({ contract }, { message }) {
    const timedOut = message && message.includes(handlers.timeoutMessage);

    const shouldWait =
      contract &&
      contract.timeoutBlocks &&
      contract.timeoutBlocks > handlers.defaultTimeoutBlocks;

    const waitForTxPropagation =
      message && message.includes(handlers.defaultWeb3Error);

    return shouldWait && (timedOut || waitForTxPropagation);
  },

  /**
   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.
   * @param {Object}       context  execution state
   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call
   */
  setup: function(emitter, context) {
    emitter.on("error", handlers.error.bind(emitter, context));
    emitter.on("transactionHash", handlers.hash.bind(emitter, context));
    // web3 block polls if the confirmation listener is enabled so we want to
    // give users a way of opting out of this behavior - it causes problems in testing
    if (!context.contract.disableConfirmationListener) {
      emitter.on("confirmation", handlers.confirmation.bind(emitter, context));
    }
    emitter.on("receipt", handlers.receipt.bind(emitter, context));
  },

  // -----------------------------------  Handlers -------------------------------------------------
  /**
   * Error event handler. Emits error unless error is block timeout and user has
   * specified we should wait longer
   * @param  {Object} context   execution state
   * @param  {Object} error     error
   */
  error: function(context, error) {
    if (!handlers.ignoreTimeoutError(context, error)) {
      context.promiEvent.eventEmitter.emit("error", error);
      this.removeListener("error", handlers.error);
    }
  },

  /**
   * Transaction hash event handler. Attaches the hash to the context object
   * so it can be attached to the contract instance after a deployment resolves.
   * @param  {Object} context   execution state
   * @param  {String} hash      transaction hash
   */
  hash: function(context, hash) {
    context.transactionHash = hash;
    context.promiEvent.eventEmitter.emit("transactionHash", hash);
    this.removeListener("transactionHash", handlers.hash);
  },

  confirmation: function(context, number, receipt) {
    context.promiEvent.eventEmitter.emit("confirmation", number, receipt);

    // Per web3: initial confirmation index is 0
    if (number === handlers.maxConfirmations + 1) {
      this.removeListener("confirmation", handlers.confirmation);
    }
  },

  /**
   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,
   * and (for method calls only) resolves/rejects the promiEvent with the receipt.
   * @param  {Object} context   execution state
   * @param  {Object} receipt   transaction receipt
   */
  receipt: async function(context, receipt) {
    // keep around the raw (not decoded) logs in the raw logs field as a
    // stopgap until we can get the ABI for all events, not just the current
    // contract
    receipt.rawLogs = receipt.logs;

    // Decode logs, use as receipt.logs for ease of use.
    try {
      receipt.logs = receipt.logs
        ? Utils.decodeLogs.call(context.contract, receipt.logs)
        : [];
    } catch (error) {
      return context.promiEvent.reject(error);
    }

    // Emit receipt
    context.promiEvent.eventEmitter.emit("receipt", receipt);

    // .new(): Exit early. We need the promiEvent to resolve a contract instance.
    if (context.onlyEmitReceipt) {
      context.receipt = receipt;
      return;
    }

    // .method(): resolve/reject receipt in handler
    if (receipt.status !== undefined && !receipt.status) {
      const reason = await Reason.get(
        context.params,
        context.contract.web3,
        context.contract.interfaceAdapter
      );

      const error = new StatusError(
        context.params,
        receipt.transactionHash,
        receipt,
        reason
      );

      return context.promiEvent.reject(error);
    }

    // This object has some duplicate data but is backward compatible.
    context.promiEvent.resolve({
      tx: receipt.transactionHash,
      receipt: receipt,
      logs: receipt.logs
    });

    //HACK: adding this conditional for when the handler is invoked
    //manually during stacktracing
    if (this.removeListener) {
      this.removeListener("receipt", handlers.receipt);
    }
  }
};

module.exports = handlers;


/***/ }),

/***/ 895945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("contract:manual-send");
const ethers = __webpack_require__(204003);
const Utils = __webpack_require__ (913735);
const { formatters } = __webpack_require__(484390); //used for reproducing web3's behavior

//this is less manual now, it uses ethers, whew
//(it's still more manual than using web3)
async function sendTransactionManual(web3, params, promiEvent) {
  debug("executing manually!");
  //set up ethers provider
  const ethersProvider = new ethers.providers.Web3Provider(
    web3.currentProvider
  );
  //let's clone params and set it up properly
  const { transaction, from } = setUpParameters(params, web3);
  //now: if the from address is in the wallet, web3 will sign the transaction before
  //sending, so we have to account for that
  const account = web3.eth.accounts.wallet[from];
  const ethersSigner = account
    ? new ethers.Wallet(account.privateKey, ethersProvider)
    : ethersProvider.getSigner(from);
  debug("got signer");
  let txHash, receipt, ethersResponse;
  try {
    //note: the following code won't work with ethers v5.
    //wth ethers v5, in the getSigner() case, you'll need to
    //use sendUncheckedTransaction instead of sendTransaction.
    //I don't know why.
    ethersResponse = await ethersSigner.sendTransaction(transaction);
    txHash = ethersResponse.hash;
    receipt = await ethersProvider.waitForTransaction(txHash);
    debug("no error");
  } catch (error) {
    ({ txHash, receipt } = handleError(error));
    if (!receipt) {
      receipt = await ethersProvider.waitForTransaction(txHash);
    }
  }
  debug("txHash: %s", txHash);
  receipt = translateReceipt(receipt);
  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@
  return await handleResult(receipt, transaction.to == null);
}

function handleError(error) {
  debug("error: %O", error);
  if (error.data && error.data.hash) {
    //ganache v7.x
    return { txHash: error.data.hash };
  } else if (error.data && Object.keys(error.data).length === 3) {
    //ganache v2.x
    //error.data will have 3 keys: stack, name, and the txHash
    const transactionHash = Object.keys(error.data).find(
      key => key !== "stack" && key !== "name"
    );
    return { txHash: transactionHash };
  } else if (error.transactionHash && error.receipt) {
    return {
      txHash: error.transactionHash,
      receipt: error.receipt
    };
  } else {
    throw error; //rethrow unexpected errors
  }
}

async function handleResult(receipt, isDeployment) {
  const deploymentFailedMessage = "The contract code couldn't be stored, please check your gas limit.";
  if (receipt.status) {
    if (isDeployment) {
      //in the deployment case, web3 might error even when technically successful @_@
      if ((await web3.eth.getCode(receipt.contractAddress)) === "0x") {
        throw new Error(deploymentFailedMessage);
      }
    }
    return receipt;
  } else {
    //otherwise: we have to mimic web3's errors @_@
    if (isDeployment) {
      //deployment case
      throw new Error(deploymentFailedMessage);
    }
    throw new Error(
      "Transaction has been reverted by the EVM:" +
        "\n" +
        JSON.stringify(receipt)
    );
  }
}

function setUpParameters(params, web3) {
  let transaction = Object.assign({}, params);
  transaction.from =
    transaction.from != undefined
      ? transaction.from
      : web3.eth.defaultAccount;
  //now let's have web3 check our inputs
  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn
  //...but ethers uses gasLimit instead of gas like web3
  transaction.gasLimit = transaction.gas;
  delete transaction.gas;
  //also, it insists "from" be kept separate
  const { from } = transaction;
  delete transaction.from;
  return { transaction, from }
}

//translate the receipt to web3 format by converting BigNumbers
//(note: these are *ethers* BigNumbers) to numbers
function translateReceipt(receipt) {
  return Object.assign({},
    ...Object.entries(receipt).map(([key, value]) => ({
      [key]: Utils.is_big_number(value)
        ? value.toNumber()
        : value
    }))
  );
}

module.exports = {
  sendTransactionManual
}


/***/ }),

/***/ 547009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Reason = __webpack_require__(812630);
const handlers = __webpack_require__(399198);

const override = {
  timeoutMessage: "not mined within", // Substring of timeout err fired by web3
  defaultWeb3Error: "please check your gas limit", // Substring of default Web3 error
  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx
  pollingInterval: 1000,

  /**
   * Attempts to extract receipt object from Web3 error message
   * @param  {Object} message       web3 error
   * @return {Object|undefined} receipt
   */
  extractReceipt(message) {
    const hasReceipt = message && message.includes("{");
    message.includes("}");

    if (hasReceipt) {
      const receiptString = "{" + message.split("{")[1].trim();
      try {
        return JSON.parse(receiptString);
      } catch (err) {
        // ignore
      }
    }
  },

  /**
   * Fired after web3 ceases to support subscriptions if user has specified
   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen
   * for new blocks and begins evaluating whether block height has reached the user
   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.
   *
   * @param  {Object} context execution state
   * @param  {Object} err     error
   */
  start: async function(context, web3Error) {
    const constructor = this;
    let currentBlock = override.defaultMaxBlocks;

    // Reject after attempting to get reason string if we shouldn't be waiting.
    if (!handlers.ignoreTimeoutError(context, web3Error)) {
      // We might have been routed here in web3 >= beta.34 by their own status check
      // error. We want to extract the receipt, emit a receipt event
      // and reject it ourselves.
      const receipt = override.extractReceipt(web3Error.message);
      if (receipt) {
        await handlers.receipt(context, receipt);
        return;
      }

      // This will run if there's a reason and no status field
      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true
      const reason = await Reason.get(
        context.params,
        constructor.web3,
        constructor.interfaceAdapter
      );
      if (reason) {
        web3Error.reason = reason;
        web3Error.message += ` -- Reason given: ${reason}.`;
      }

      return context.promiEvent.reject(web3Error);
    }

    // This will run every block from now until contract.timeoutBlocks
    const listener = function(pollID) {
      currentBlock++;

      if (currentBlock > constructor.timeoutBlocks) {
        clearInterval(pollID);
        return;
      }

      constructor.interfaceAdapter
        .getTransactionReceipt(context.transactionHash)
        .then(result => {
          if (!result) return;

          // make sure reporter receives tx receipt promievent
          handlers.receipt(context, result);
          result.contractAddress
            ? constructor
                .at(result.contractAddress)
                .then(context.promiEvent.resolve)
                .catch(context.promiEvent.reject)
            : constructor.promiEvent.resolve(result);
        })
        .catch(err => {
          clearInterval(pollID);
          context.promiEvent.reject(err);
        });
    };

    // Start polling
    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();

    const pollID = setInterval(async () => {
      const newBlock = await constructor.interfaceAdapter.getBlockNumber();

      if (newBlock > currentPollingBlock) {
        currentPollingBlock = newBlock;
        listener(pollID);
      }
    }, override.pollingInterval);
  }
};

module.exports = override;


/***/ }),

/***/ 420302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("contract:promievent");
const DebugUtils = __webpack_require__(93293);
const Web3PromiEvent = __webpack_require__(304017);

function PromiEvent(justPromise, bugger = undefined, isDeploy = false) {
  const { resolve, reject, eventEmitter } = new Web3PromiEvent(justPromise);

  const originalStackTrace = new Error().stack;

  function rejectHijacker(e) {
    debug("hijacking!");
    debug("hash: %s", this.txHash);
    let getSolidityStackTrace;
    if (bugger && this.txHash) {
      debug("debugging time!");
      getSolidityStackTrace = async () => {
        try {
          await bugger.load(this.txHash);
          await bugger.runToEnd();
          const report = bugger.stacktrace();
          await bugger.unload();
          return DebugUtils.formatStacktrace(report, 4); //indent 4 to match node's stacktraces
        } catch (_) {
          //ignore errors
          return undefined;
        }
      };
    } else {
      getSolidityStackTrace = async () => undefined;
    }

    getSolidityStackTrace().then((solidityStackTrace) => {
      debug("e.stack: %s", e.stack);
      debug("originalStackTrace: %s", originalStackTrace);
      debug("solidityStackTrace: %s", solidityStackTrace);
      const initialLinesRegexp = isDeploy
        ? /^.*\n.*\n.*\n.*/ //first 4 lines (note . does not include \n)
        : /^.*\n.*\n.*/; //first 3 lines
      //we replace not just the first line but also the next 2 as they contain
      //useless stuff users shouldn't see; in case of deployments there's one
      //additional to remove
      try {
        let stackTrace = originalStackTrace.replace(
          initialLinesRegexp,
          e.stack.split("\n")[0]
        );
        if (solidityStackTrace) {
          //let's split the solidity stack trace into first line & rest
          let [
            _,
            solidityFirstLine,
            solidityRemaining,
          ] = solidityStackTrace.match(/^(.*?)\r?\n((.|\r|\n)*)$/);

          stackTrace = stackTrace.replace(
            /^.*/, //note that . does not include \n
            solidityRemaining //note: this does not end in \n, so no modification needed
          );
          e.hijackedMessage = e.message;
          e.message = solidityFirstLine;
        }

        e.hijackedStack = e.stack;
        e.stack = stackTrace;
      } catch (_) {
        //again, ignore errors
        //(not sure how this can happen here but I'll leave this block here)
      }
      reject(e);
    });
  }

  this.resolve = resolve;
  this.reject = rejectHijacker.bind(this);
  this.eventEmitter = eventEmitter;
  if (bugger) {
    this.debug = true;
  }
}

PromiEvent.resolve = Web3PromiEvent.resolve;

PromiEvent.prototype.setTransactionHash = function (txHash) {
  debug("setting!");
  debug("hash: %s", txHash);
  this.txHash = txHash;
};

module.exports = PromiEvent;


/***/ }),

/***/ 812630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DebugUtils = __webpack_require__(93293);

/**
 * Methods to fetch and decode reason string from ganache when a tx errors.
 */

const reason = {
  /**
   * Extracts a reason string from `eth_call` response
   * @param  {Object}           res  response from `eth_call` to extract reason
   * @param  {Web3}             web3 a helpful friend
   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend
   * @return {String|Undefined}      decoded reason string
   */
  _extract: function (res, web3, _interfaceAdapter) {
    //I'm not sure why interfaceAdapter is here if it's not used,
    //so I just put an underscore in front of its name for now...
    if (!res || (!res.error && !res.result)) return;

    const isObject =
      res && typeof res === "object" && res.error && res.error.data;
    const isString =
      res && typeof res === "object" && typeof res.result === "string";

    if (isObject) {
      // NOTE that Ganache >=2 returns the reason string when
      // vmErrorsOnRPCResponse === true, which this code could
      // be updated to respect (instead of computing here)
      const data = res.error.data;
      let resData;
      if (typeof data === "string") {
        resData = data; // geth, Ganache >7.0.0
      } else if ("result" in data) {
        // there is a single result (Ganache 7.0.0)
        resData = data.result;
      } else {
        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0
        // NOTE this only works for a single failed transaction at a time.
        const hash = Object.keys(data)[0];
        const errorDetails = data[hash];
        resData = errorDetails.return /* ganache 2.0 */;
      }

      return reason._decode(resData, web3);
    } else if (isString) {
      return reason._decode(res.result, web3);
    } else {
      return undefined;
    }
  },

  _decode: function (rawData, web3) {
    const errorStringHash = "0x08c379a0";
    const panicCodeHash = "0x4e487b71";
    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)
    const wordLength = 2 * 32; //32 bytes (64 hex digits)
    if (!rawData) {
      return undefined;
    } else if (rawData === "0x") {
      //no revert message
      return undefined;
    } else if (rawData.startsWith(errorStringHash)) {
      try {
        return web3.eth.abi.decodeParameter(
          "string",
          rawData.slice(selectorLength)
        );
      } catch (_) {
        //no reasonable way to handle this case at present
        return undefined;
      }
    } else if (rawData.startsWith(panicCodeHash)) {
      if (rawData.length === selectorLength + wordLength) {
        const panicCode = web3.eth.abi.decodeParameter(
          "uint256",
          rawData.slice(selectorLength)
        ); //this returns a decimal string
        return `Panic: ${DebugUtils.panicString(panicCode)}`;
      } else {
        //incorrectly encoded panic...?
        return undefined;
      }
    } else {
      //we can't reasonably handle custom errors here
      //(but we can probably assume it is one?)
      return "Custom error (could not decode)";
    }
  },

  /**
   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.
   * @param  {Object} web3
   * @param  {Object} interfaceAdapter
   * @return {String|Undefined}
   */
  get: function (params, web3, interfaceAdapter) {
    const packet = {
      jsonrpc: "2.0",
      method: "eth_call",
      params: [params, "latest"],
      id: new Date().getTime()
    };

    return new Promise(resolve => {
      web3.currentProvider.send(packet, (err, response) => {
        const reasonString = reason._extract(response, web3, interfaceAdapter);
        resolve(reasonString);
      });
    });
  }
};

module.exports = reason;


/***/ }),

/***/ 190908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Utilities for reformatting web3 outputs
 */
const BigNumber = __webpack_require__(800526);
const web3Utils = __webpack_require__(118269);

/**
 * Converts from string to other number format
 * @param  {String} val    number string returned by web3
 * @param  {String} format name of format to convert to
 * @return {Object|String} converted value
 */
const _convertNumber = function(val, format) {
  const badFormatMsg = `Attempting to convert to unknown number format: ${format}`;

  switch (format) {
    case "BigNumber":
      return new BigNumber(val);
    case "BN":
      return web3Utils.toBN(val);
    case "String":
      return val;
    case "BigInt":
      return BigInt(val);
    default:
      throw new Error(badFormatMsg);
  }
};

/**
 * Converts arrays of number strings to other number formats
 * @param  {String[]} arr       number string array returned by web3
 * @param  {String}   format    name of format to convert to
 * @return {Object[]|String[]}  array of converted values
 */
const _convertNumberArray = function(arr, format, depth = 0) {
  if (depth == 0) return arr.map(item => _convertNumber(item, format));
  // arr is nested
  return arr.map(item => _convertNumberArray(item, format, depth - 1));
};

/**
 * Reformats numbers in the result/result-object of a web3 call.
 * Possible forms of `result` are:
 *   - object (with index keys and optionally, named keys)
 *   - array
 *   - single primitive
 * @param  {String|Object|Array} result      web3 call result
 * @param  {Array}               abiSegment  event params OR .call outputs
 * @return {String|Object|Array} reformatted result
 */
const numbers = function(result, abiSegment) {
  const format = this.numberFormat;

  abiSegment.forEach((output, i) => {
    // output is a number type (uint || int);
    if (output.type.includes("int")) {
      // output is an array type
      if (output.type.includes("[")) {
        // larger than zero if nested array
        let depth = output.type.split("[").length - 2;

        // result is array
        if (Array.isArray(result)) {
          result = _convertNumberArray(result, format, depth);

          // result is object
        } else {
          // output has name
          if (output.name.length) {
            result[output.name] = _convertNumberArray(
              result[output.name],
              format,
              depth
            );
          }
          // output will always have an index key
          result[i] = _convertNumberArray(result[i], format, depth);
        }
        //
      } else if (typeof result === "object") {
        // output has name
        if (output.name.length) {
          result[output.name] = _convertNumber(result[output.name], format);
        }

        // output will always have an index key
        result[i] = _convertNumber(result[i], format);
      } else {
        result = _convertNumber(result, format);
      }
    }
  });
  return result;
};

module.exports = {
  numbers: numbers
};


/***/ }),

/***/ 460550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(673321);
const utils = __webpack_require__(913735);

const defaultGas = 90000;

class StatusError extends TruffleError {
  constructor(args, tx, receipt, reason) {
    let message;
    const gasLimit = args.gas || defaultGas;
    let reasonString = "";

    if (reason) reasonString = `Reason given: ${reason}.`;

    if (utils.bigNumberify(receipt.gasUsed).eq(utils.bigNumberify(gasLimit))) {
      message =
        "Transaction: " +
        tx +
        " exited with an error (status 0) after consuming all gas.\n" +
        "     Please check that the transaction:\n" +
        "     - satisfies all conditions set by Solidity `assert` statements.\n" +
        "     - has enough gas to execute the full transaction.\n" +
        "     - does not trigger an invalid opcode by other means (ex: accessing an array out of bounds).";
    } else {
      message =
        `Transaction: ${tx} exited with an error (status 0). ${reasonString}\n` +
        "     Please check that the transaction:\n" +
        "     - satisfies all conditions set by Solidity `require` statements.\n" +
        "     - does not trigger a Solidity `revert` statement.\n";
    }

    super(message);
    this.tx = tx;
    this.receipt = receipt;
    this.reason = reason;
  }
}

module.exports = StatusError;


/***/ }),

/***/ 150145:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: ENSJS, getEnsAddress } = __webpack_require__(426143);
const { isAddress } = __webpack_require__(118269);

module.exports = {
  convertENSNames: async function ({
    ens,
    inputArgs,
    methodABI,
    inputParams,
    web3,
    networkId
  }) {
    const { registryAddress } = ens;
    let args;
    if (inputArgs.length && methodABI) {
      args = await this.convertENSArgsNames({
        inputArgs,
        methodABI,
        web3,
        registryAddress,
        networkId
      });
    } else {
      args = inputArgs;
    }
    let params;
    if (inputParams) {
      params = await this.convertENSParamsNames({
        inputParams,
        web3,
        registryAddress,
        networkId
      });
    }
    return { args, params };
  },

  getNewENSJS: function ({ provider, registryAddress, networkId }) {
    return new ENSJS({
      provider,
      ensAddress: registryAddress || getEnsAddress(networkId)
    });
  },

  resolveNameToAddress: async function ({
    name,
    provider,
    registryAddress,
    networkId
  }) {
    let ensjs;
    try {
      ensjs = this.getNewENSJS({
        provider,
        registryAddress,
        networkId
      });
    } catch (error) {
      const message =
        "There was a problem initializing the ENS library." +
        "Please ensure you have the address of the registry set correctly." +
        ` Truffle is currently using ${registryAddress}.`;
      throw new Error(`${message} - ${error.message}`);
    }
    return await ensjs.name(name).getAddress("ETH");
  },

  convertENSArgsNames: function ({
    inputArgs,
    methodABI,
    web3,
    registryAddress,
    networkId
  }) {
    if (methodABI.inputs.length === 0) return inputArgs;

    const convertedNames = inputArgs.map((argument, index) => {
      if (index + 1 > methodABI.inputs.length) {
        return argument;
      } else if (methodABI.inputs[index].type === "address") {
        // Check all address arguments for ENS names
        const argIsAddress = isAddress(argument);
        if (argIsAddress) return argument;
        return this.resolveNameToAddress({
          name: argument,
          provider: web3.currentProvider,
          registryAddress,
          networkId
        });
      } else {
        return argument;
      }
    });
    return Promise.all(convertedNames);
  },

  convertENSParamsNames: async function ({
    inputParams,
    web3,
    registryAddress,
    networkId
  }) {
    let outputParams = inputParams;
    if (inputParams.from && !isAddress(inputParams.from)) {
      const newFrom = await this.resolveNameToAddress({
        name: inputParams.from,
        provider: web3.currentProvider,
        networkId,
        registryAddress
      });
      outputParams = {
        ...outputParams,
        from: newFrom
      };
    }
    if (inputParams.accessList && Array.isArray(inputParams.accessList)) {
      const newAccessList = await Promise.all(
        inputParams.accessList.map(async (entry) => {
          if (entry && entry.address && !isAddress(entry.address)) {
            const newAddress = await this.resolveNameToAddress({
              name: entry.address,
              provider: web3.currentProvider,
              networkId,
              registryAddress
            });
            return {
              ...entry,
              address: newAddress
            };
          } else {
            return entry;
          }
        })
      );
      outputParams = {
        ...outputParams,
        accessList: newAccessList
      };
    }
    return outputParams;
  }
};


/***/ }),

/***/ 913735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("contract:utils");
const web3Utils = __webpack_require__(118269);
const { bigNumberify } = __webpack_require__(661895);
const abi = __webpack_require__(893338);
const BlockchainUtils = __webpack_require__(986317);
const reformat = __webpack_require__(190908);
const ens = __webpack_require__(150145);

const allowedTxParams = new Set([
  "from",
  "to",
  "gas",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "value",
  "data",
  "nonce",
  "accessList",
  "type",
  "privateFor",
  "overwrite"
]);

const Utils = {
  is_object(val) {
    return typeof val === "object" && !Array.isArray(val);
  },

  is_big_number(val) {
    if (typeof val !== "object") return false;

    //NOTE: For some reason, contrary to the docs,
    //web3Utils.isBigNumber returns true not only for
    //bignumber.js BigNumbers, but also for ethers BigNumbers,
    //even though these are totally different things.
    return web3Utils.isBN(val) || web3Utils.isBigNumber(val);
  },

  isTxParams(val) {
    if (!Utils.is_object(val)) return false;
    if (Utils.is_big_number(val)) return false;
    return Object.keys(val).some(fieldName => allowedTxParams.has(fieldName));
  },

  decodeLogs(_logs, isSingle) {
    const constructor = this;
    const logs = Utils.toTruffleLog(_logs, isSingle);

    return logs
      .map(log => {
        const logABI = constructor.events[log.topics[0]];

        if (logABI == null) return null;

        const copy = Utils.merge({}, log);

        copy.event = logABI.name;
        copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);

        if (copy.data === "0x") copy.data = "";

        let logArgs;
        try {
          logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);
          copy.args = reformat.numbers.call(
            constructor,
            logArgs,
            logABI.inputs
          );
        } catch (_) {
          return null;
        }

        delete copy.data;
        delete copy.topics;

        return copy;
      })
      .filter(log => log != null);
  },

  toTruffleLog(events, isSingle) {
    // Transform singletons (from event listeners) to the kind of
    // object we find on the receipt
    if (isSingle && typeof isSingle === "boolean") {
      const temp = [];
      temp.push(events);
      return temp.map(log => {
        log.data = log.raw.data;
        log.topics = log.raw.topics;
        return log;
      });
    }

    // Or reformat items in the existing array
    events.forEach(event => {
      if (event.raw) {
        event.data = event.raw.data;
        event.topics = event.raw.topics;
      }
    });

    return events;
  },

  merge() {
    const merged = {};
    const args = Array.prototype.slice.call(arguments);

    for (let i = 0; i < args.length; i++) {
      const object = args[i];
      const keys = Object.keys(object);
      for (let j = 0; j < keys.length; j++) {
        const key = keys[j];
        const value = object[key];
        merged[key] = value;
      }
    }

    return merged;
  },

  linkBytecode(bytecode, links) {
    Object.keys(links).forEach(library_name => {
      const library_address = links[library_name];
      const regex = new RegExp(`__${library_name}_+`, "g");

      bytecode = bytecode.replace(regex, library_address.replace("0x", ""));
    });

    return bytecode;
  },

  // Extracts optional tx params from a list of fn arguments
  getTxParams(methodABI, args, ignoreDefaultGasPriceParams = false) {
    const constructor = this;

    const expectedArgCount = methodABI ? methodABI.inputs.length : 0;

    let txParams = {};
    const lastArg = args[args.length - 1];

    if (args.length === expectedArgCount + 1 && Utils.isTxParams(lastArg)) {
      txParams = args.pop();
    }

    let defaultParams = constructor.class_defaults;
    if (ignoreDefaultGasPriceParams) {
      //this parameter is set when making calls (as opposed to transactions)
      //gas price params can cause problems with those on some networks, so
      //we ignore any defaults, and only include them if they were explicitly
      //specified
      defaultParams = { ...constructor.class_defaults }; //clone
      delete defaultParams.gasPrice;
      delete defaultParams.maxFeePerGas;
      delete defaultParams.maxPriorityFeePerGas;
    }

    return Utils.merge(defaultParams, txParams);
  },

  // Verifies that a contracts libraries have been linked correctly.
  // Throws on error
  checkLibraries() {
    const constructor = this;
    const regex = /__[^_]+_+/g;
    let unlinkedLibraries = constructor.binary.match(regex);

    if (unlinkedLibraries !== null) {
      unlinkedLibraries = unlinkedLibraries
        .map(
          (
            name // Remove underscores
          ) => name.replace(/_/g, "")
        )
        .sort()
        .filter((name, index, arr) => {
          // Remove duplicates
          if (index + 1 >= arr.length) {
            return true;
          }

          return name !== arr[index + 1];
        })
        .join(", ");

      const error = `${constructor.contractName} contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of ${constructor.contractName}: ${unlinkedLibraries}`;

      throw new Error(error);
    }
  },

  convertToEthersBN(original) {
    const converted = [];
    original.forEach(item => {
      // Recurse for arrays
      if (Array.isArray(item)) {
        converted.push(Utils.convertToEthersBN(item));

        // Convert Web3 BN / BigNumber
      } else if (Utils.is_big_number(item)) {
        //HACK: Since we can't rely on web3Utils.isBigNumber to tell
        //whether we have a bignumber.js BigNumber, we'll just check
        //whether it has the toFixed method
        const stringValue = item.toFixed
          ? item.toFixed() //prevents use of scientific notation
          : item.toString();
        const ethersBN = bigNumberify(stringValue);
        converted.push(ethersBN);
      } else {
        converted.push(item);
      }
    });
    return converted;
  },

  /**
   * Multiplies an ethers.js BigNumber and a number with decimal places using
   * integer math rather than using an arbitrary floating-point library like
   * `bignumber.js`.
   * @param  {BigNumber} bignum            an ethers.js BigNumber (use bigNumberify)
   * @param  {Number}    decimal           a number which has 0+ decimal places
   * @param  {Number}    [maxPrecision=5]  the max number of signficant figures
   *                                       `decimal` can have. (default: 5)
   * @return {BigNumber}                   floor(bignum * decimal)
   */
  multiplyBigNumberByDecimal(bignum, decimal, maxPrecision) {
    if (typeof maxPrecision === "undefined") {
      maxPrecision = 5;
    }

    const significantFigures = Math.min(
      decimal.toString().length - 1, // length less one because `.`
      maxPrecision
    );

    const denominator = bigNumberify(10).pow(significantFigures);
    const multiplier = Math.round(decimal * denominator);
    const numerator = bigNumberify(multiplier).mul(bignum);

    return numerator.div(denominator);
  },

  // checks if given contract instance has a set provider
  checkProvider({ currentProvider, contractName }) {
    if (!currentProvider)
      throw new Error(
        `${contractName} error: Please call setProvider() first before calling new().`
      );
  },

  // verifies current network has been assigned to contract instance
  checkNetworkArtifactMatch({ networks, network_id, contractName }) {
    if (networks[network_id] == null)
      throw new Error(
        `${contractName} has not been deployed to detected network (network/artifact mismatch)`
      );
  },

  // verifies contract instance has been deployed
  checkDeployment({ isDeployed, contractName, network_id }) {
    if (!isDeployed())
      throw new Error(
        `${contractName} has not been deployed to detected network (${network_id})`
      );
  },

  // checks if provided contract address has on-chain code
  checkCode(onChainCode, contractName, address) {
    if (!onChainCode || onChainCode.replace("0x", "").replace(/0/g, "") === "")
      throw new Error(
        `Cannot create instance of ${contractName}; no code at address ${address}`
      );
  },

  // parses known contract instance networks
  async parseKnownNetworks(
    { networks, currentProvider, setNetwork, network_id },
    gasLimit
  ) {
    if (!networks && Object.keys(networks).length === 0) {
      return false;
    }
    // go through all the networks that are listed as
    // blockchain uris and see if they match
    for (const network in networks) {
      if (network.startsWith("blockchain://")) {
        const networkMatches = await BlockchainUtils.matches(
          network,
          currentProvider
        );
        if (networkMatches) {
          setNetwork(network);
          return {
            id: network_id,
            blockLimit: gasLimit
          };
        }
      }
    }
    // no match found!
    return false;
  },

  // sets a contract instance network ID
  async setInstanceNetworkID(
    TruffleContractInstance,
    chainNetworkID,
    gasLimit
  ) {
    // if chainNetworkID already present as network configuration, use it
    if (TruffleContractInstance.hasNetwork(chainNetworkID)) {
      TruffleContractInstance.setNetwork(chainNetworkID);
      return {
        id: TruffleContractInstance.network_id,
        blockLimit: gasLimit
      };
    }
    // chainNetworkID not present,
    // parse all known networks
    const matchedNetwork = await Utils.parseKnownNetworks(
      TruffleContractInstance,
      gasLimit
    );
    if (matchedNetwork) return matchedNetwork;

    // network unknown, trust the provider and use given chainNetworkID
    TruffleContractInstance.setNetwork(chainNetworkID);
    return { id: TruffleContractInstance.network_id, blockLimit: gasLimit };
  }
};

Utils.ens = ens;
Utils.bigNumberify = bigNumberify;

module.exports = Utils;


/***/ }),

/***/ 876775:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 876775;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 93293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);
const debug = __webpack_require__(615158)("debug-utils");
const util = __webpack_require__(473837);
const Codec = __webpack_require__(20102);
const BN = __webpack_require__(213550);

const chromafi = __webpack_require__(910298);
const hljsDefineSolidity = __webpack_require__(196988);
hljsDefineSolidity(chromafi.hljs);
const chalk = __webpack_require__(88551);

const panicTable = {
  0x01: "Failed assertion",
  0x11: "Arithmetic overflow",
  0x12: "Division by zero",
  0x21: "Enum value out of bounds",
  0x22: "Malformed string",
  0x31: "Array underflow",
  0x32: "Index out of bounds",
  0x41: "Oversized array or out of memory",
  0x51: "Call to invalid function"
};

const verbosePanicTable = {
  0x01: "An assert() check was not satisfied.",
  0x11: "An arithmetic overflow occurred outside an unchecked { ... } block.",
  0x12: "A division by zero occurred.",
  0x21: "An integer was cast to an enum type that cannot hold it.",
  0x22: "There was an attempt to read an incorrectly-encoded string or bytestring.",
  0x31: "An empty array's pop() method was called.",
  0x32: "An array or bytestring was indexed or sliced with an out-of-bounds index.",
  0x41: "An oversized array was created, or the contract ran out of memory.",
  0x51: "An uninitialized internal function pointer was called."
};

const commandReference = {
  "o": "step over",
  "i": "step into",
  "u": "step out",
  "n": "step next",
  ";": "step instruction (include number to step multiple)",
  "p": "print instruction & state (`p [mem|cal|sto]*`; see docs for more)",
  "l": "print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)",
  "h": "print this help",
  "v": "print variables and values (`v [bui|glo|con|loc]*`)",
  ":": "evaluate expression - see `v`",
  "+": "add watch expression (`+:<expr>`)",
  "-": "remove watch expression (-:<expr>)",
  "?": "list existing watch expressions and breakpoints",
  "b": "add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)",
  "B": "remove breakpoint (similar to adding, or `B all` to remove all)",
  "c": "continue until breakpoint",
  "q": "quit",
  "r": "reset",
  "t": "load new transaction",
  "T": "unload transaction",
  "s": "print stacktrace",
  "g": "turn on generated sources",
  "G": "turn off generated sources except via `;`",
  "y": "(if at end) reset & continue to final error",
  "Y": "reset & continue to previous error"
};

const shortCommandReference = {
  "o": "step over",
  "i": "step into",
  "u": "step out",
  "n": "step next",
  ";": "step instruction",
  "p": "print state",
  "l": "print context",
  "h": "print help",
  "v": "print variables",
  ":": "evaluate",
  "+": "add watch",
  "-": "remove watch",
  "?": "list watches & breakpoints",
  "b": "add breakpoint",
  "B": "remove breakpoint",
  "c": "continue",
  "q": "quit",
  "r": "reset",
  "t": "load",
  "T": "unload",
  "s": "stacktrace",
  "g": "turn on generated sources",
  "G": "turn off generated sources",
  "y": "reset & go to final error",
  "Y": "reset & go to previous error"
};

const truffleColors = {
  mint: chalk.hex("#3FE0C5"),
  orange: chalk.hex("#E4A663"),
  pink: chalk.hex("#E911BD"),
  purple: chalk.hex("#8731E8"),
  green: chalk.hex("#00D717"),
  red: chalk.hex("#D60000"),
  yellow: chalk.hex("#F2E941"),
  blue: chalk.hex("#25A9E0"),
  comment: chalk.hsl(30, 20, 50),
  watermelon: chalk.hex("#E86591"),
  periwinkle: chalk.hex("#7F9DD1")
};

const DEFAULT_TAB_WIDTH = 8;

const trufflePalette = {
  /* base (chromafi special, not hljs) */
  "base": chalk,
  "lineNumbers": chalk,
  "trailingSpace": chalk,
  /* classes hljs-solidity actually uses */
  "keyword": truffleColors.mint,
  "number": truffleColors.red,
  "string": truffleColors.green,
  "params": truffleColors.pink,
  "builtIn": truffleColors.watermelon,
  "built_in": truffleColors.watermelon, //just to be sure
  "literal": truffleColors.watermelon,
  "function": truffleColors.orange,
  "title": truffleColors.orange,
  "class": truffleColors.orange,
  "comment": truffleColors.comment,
  "doctag": truffleColors.comment,
  "operator": truffleColors.blue,
  "punctuation": truffleColors.purple,
  /* classes it might soon use! */
  "meta": truffleColors.pink,
  "metaString": truffleColors.green,
  "meta-string": truffleColors.green, //similar
  /* classes it doesn't currently use but notionally could */
  "type": truffleColors.orange,
  "symbol": truffleColors.orange,
  "metaKeyword": truffleColors.mint,
  "meta-keyword": truffleColors.mint, //again, to be sure
  "property": chalk, //not putting any highlighting here for now
  /* classes that don't make sense for Solidity */
  "regexp": chalk, //solidity does not have regexps
  "subst": chalk, //or string interpolation
  "name": chalk, //or s-expressions
  "builtInName": chalk, //or s-expressions, again
  "builtin-name": chalk, //just to be sure
  /* classes for config, markup, CSS, templates, diffs (not programming) */
  "section": chalk,
  "tag": chalk,
  "attr": chalk,
  "attribute": chalk,
  "variable": chalk,
  "bullet": chalk,
  "code": chalk,
  "emphasis": chalk,
  "strong": chalk,
  "formula": chalk,
  "link": chalk,
  "quote": chalk,
  "selectorAttr": chalk, //lotta redundancy follows
  "selector-attr": chalk,
  "selectorClass": chalk,
  "selector-class": chalk,
  "selectorId": chalk,
  "selector-id": chalk,
  "selectorPseudo": chalk,
  "selector-pseudo": chalk,
  "selectorTag": chalk,
  "selector-tag": chalk,
  "templateTag": chalk,
  "template-tag": chalk,
  "templateVariable": chalk,
  "template-variable": chalk,
  "addition": chalk,
  "deletion": chalk
};

var DebugUtils = {
  truffleColors, //make these externally available

  //panicCode may be either a number, BN, or decimal string
  panicString: function (panicCode, verbose = false) {
    const unknownString = "Unknown panic";
    const verboseUnknownString = "A panic occurred of unrecognized type.";
    if (BN.isBN(panicCode)) {
      try {
        panicCode = panicCode.toNumber();
      } catch (_) {
        return verbose ? verboseUnknownString : unknownString;
      }
    }
    return verbose
      ? verbosePanicTable[panicCode] || verboseUnknownString
      : panicTable[panicCode] || unknownString;
  },

  //attempts to test whether a given compilation is a real compilation,
  //i.e., was compiled all at once.
  //if it is real, it will definitely pass this test, barring a Solidity bug.
  //(anyway worst case failing it just results in a recompilation)
  //if it isn't real, but passes this test anyway... well, I'm hoping it should
  //still be usable all the same!
  isUsableCompilation: function (compilation) {
    //check #1: is the source order reliable?
    if (compilation.unreliableSourceOrder) {
      debug("unreliable source order");
      return false;
    }

    //check #2: are (user) source indices consecutive?
    //(while nonconsecutivity should not be a problem by itself, this probably
    //indicates a name collision of a sort that will be fatal for other
    //reasons)
    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)
    //to return true!  So I'm doing it this way even though it looks wrong
    //(since the real concern is empty spots, not undefined, yet this turns
    //this up anyhow)
    if (compilation.sources.includes(undefined)) {
      debug("nonconsecutive sources");
      return false;
    }

    const lowestInternalIndex = Math.min(
      ...compilation.contracts.map(contract => {
        //find first defined index
        let lowestConstructor = (contract.generatedSources || []).findIndex(
          x => x !== undefined
        );
        if (lowestConstructor === -1) {
          lowestConstructor = Infinity;
        }
        let lowestDeployed = (
          contract.deployedGeneratedSources || []
        ).findIndex(x => x !== undefined);
        if (lowestDeployed === -1) {
          lowestDeployed = Infinity;
        }
        return Math.min(lowestConstructor, lowestDeployed);
      })
    );
    if (lowestInternalIndex !== Infinity) {
      //Infinity would mean there were none
      if (lowestInternalIndex !== compilation.sources.length) {
        //if it's a usable compilation, these should be equal,
        //as length = 1 + last user source
        debug("gap before internal sources");
        return false;
      }
    }

    //check #4: are there any AST ID collisions?
    let astIds = new Set();

    let allIDsUnseenSoFar = node => {
      if (Array.isArray(node)) {
        return node.every(allIDsUnseenSoFar);
      } else if (node !== null && typeof node === "object") {
        if (node.id !== undefined) {
          if (astIds.has(node.id)) {
            debug("id occured twice: %o", node.id);
            return false;
          } else {
            astIds.add(node.id);
          }
        }
        return Object.values(node).every(allIDsUnseenSoFar);
      } else {
        return true;
      }
    };

    //now: walk each Solidity AST
    //(and don't bother checking generated sources as they're
    //never Solidity)
    debug("checking Solidity ASTs for collisions");
    return compilation.sources.every(
      source =>
        !source ||
        source.language !== "Solidity" ||
        allIDsUnseenSoFar(source.ast)
    );
  },

  formatStartMessage: function (withTransaction) {
    if (withTransaction) {
      return "Gathering information about your project and the transaction...";
    } else {
      return "Gathering information about your project...";
    }
  },

  formatTransactionStartMessage: function () {
    return "Gathering information about the transaction...";
  },

  formatCommandDescription: function (commandId) {
    return (
      truffleColors.mint(`(${commandId})`) + " " + commandReference[commandId]
    );
  },

  formatPrompt: function (network, txHash) {
    return txHash !== undefined
      ? `debug(${network}:${txHash.substring(0, 10)}...)> `
      : `debug(${network})> `;
  },

  formatAffectedInstances: function (instances) {
    var hasAllSource = true;

    var lines = Object.keys(instances).map(function (address) {
      var instance = instances[address];

      if (instance.contractName) {
        return " " + address + " - " + instance.contractName;
      }

      if (!instance.source) {
        hasAllSource = false;
      }

      return " " + address + "(UNKNOWN)";
    });

    if (lines.length === 0) {
      lines.push("No affected addresses found.");
    }

    if (!hasAllSource) {
      lines.push("");
      lines.push(
        `${chalk.bold(
          "Warning:"
        )} The source code for one or more contracts could not be found.`
      );
    }

    return lines.join(OS.EOL);
  },

  formatHelp: function (lastCommand = "n") {
    var prefix = [
      "Commands:",
      truffleColors.mint("(enter)") +
        " last command entered (" +
        shortCommandReference[lastCommand] +
        ")"
    ];

    var commandSections = [
      ["o", "i", "u", "n"],
      ["c", "Y"],
      ["y"],
      [";"],
      ["g", "G"],
      ["p"],
      ["l"],
      ["s", "h"],
      ["q", "r", "t", "T"],
      ["b"],
      ["B"],
      ["+", "-"],
      ["?"],
      ["v"],
      [":"]
    ].map(function (shortcuts) {
      return shortcuts.map(DebugUtils.formatCommandDescription).join(", ");
    });

    var suffix = [""];

    var lines = prefix.concat(commandSections).concat(suffix);

    return lines.join(OS.EOL);
  },

  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {
    //note: I'm going to assume for these purposes that everything is
    //basically ASCII and I don't have to worry about astral planes or
    //grapheme clusters.  Sorry. :-/
    let line = "";
    let counter = 0;
    for (let i = 0; i < inputLine.length; i++) {
      if (inputLine[i] === "\t") {
        const remaining = tabLength - counter;
        line += " ".repeat(remaining);
        counter = 0;
      } else if (inputLine[i] === "\n") {
        line += "\n";
        counter = 0;
      } else if (inputLine[i] === "\r" && inputLine[i + 1] === "\n") {
        line += "\n";
        counter = 0;
        i++;
      } else {
        line += inputLine[i];
        counter++;
        if (counter === tabLength) {
          counter = 0;
        }
      }
    }
    return line;
  },

  formatLineNumberPrefix: function (line, number, cols) {
    const prefix = String(number).padStart(cols) + ": ";

    return prefix + line;
  },

  formatLinePointer: function (
    line,
    startCol,
    endCol,
    padding,
    tabLength = DEFAULT_TAB_WIDTH
  ) {
    const prefix = " ".repeat(padding + 2); //account for ": "

    let output = "";
    let counter = 0;
    for (let i = 0; i < line.length; i++) {
      let pointedAt = i >= startCol && i < endCol;

      let additional;
      if (line[i] === "\t") {
        const remaining = tabLength - counter;
        additional = " ".repeat(remaining);
        debug("advancing %d", remaining);
        counter = 0;
      } else {
        additional = " "; // just a space
        counter++;
        if (counter === tabLength) {
          counter = 0;
        }
      }

      if (pointedAt) {
        additional = additional.replace(/./g, "^");
      }

      output += additional;
    }

    return truffleColors.purple(prefix + output);
  },

  //NOTE: source and uncolorizedSource here have already
  //been split into lines here, they're not the raw text
  //ALSO: assuming here that colorized source has been detabbed
  //but that uncolorized source has not
  formatRangeLines: function (
    source,
    range,
    uncolorizedSource,
    contextBefore = 2,
    contextAfter = 0
  ) {
    // range is {
    //   start: { line, column },
    //   end: { line, column}
    // }
    //

    var startIndex = Math.max(range.start.line - contextBefore, 0);
    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);

    var prefixLength = (endIndex + 1 + "").length; //+1 to account for 0-index

    //note: beforeLines now includes the line itself
    var beforeLines = source
      .slice(startIndex, range.start.line + 1)
      .map((line, index) => {
        let number = startIndex + index + 1; // 1 to account for 0-index
        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);
      });
    var afterLines = source
      .slice(range.start.line + 1, endIndex + 1)
      .map((line, index) => {
        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index
        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);
      });

    var pointerStart = range.start.column;
    var pointerEnd;

    let uncolorizedLine = uncolorizedSource[range.start.line];

    // range.end is undefined in some cases
    // null/undefined check to avoid exceptions
    if (range.end && range.start.line === range.end.line) {
      // start and end are same line: pointer ends at column
      pointerEnd = range.end.column;
    } else {
      pointerEnd = uncolorizedLine.length;
    }

    var allLines = beforeLines.concat(
      [
        DebugUtils.formatLinePointer(
          //the line-pointer formatter doesn't work right with colorized
          //lines, so we pass in the uncolored version
          uncolorizedLine,
          pointerStart,
          pointerEnd,
          prefixLength
        )
      ],
      afterLines
    );

    return allLines.join(OS.EOL);
  },

  formatBreakpointLocation: function (
    breakpoint,
    here,
    currentSourceId,
    sourceNames
  ) {
    let baseMessage;
    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {
      baseMessage = here
        ? `this point in line ${breakpoint.line + 1}`
        : `a point in line ${breakpoint.line + 1}`;
      //note we always add 1 to adjust for zero-indexing
    } else {
      baseMessage = `line ${breakpoint.line + 1}`;
    }
    if (breakpoint.sourceId !== currentSourceId) {
      const sourceName = sourceNames[breakpoint.sourceId];
      return baseMessage + ` in ${sourceName}`;
    } else {
      return baseMessage;
    }
  },

  formatCurrentInstruction: function (instruction) {
    const pc = this.formatPC(instruction.pc);
    const formattedInstruction = this.formatInstruction(instruction);
    return "-> " + truffleColors.mint(formattedInstruction) + pc;
  },

  formatInstruction: function (instruction) {
    return truffleColors.mint(
      instruction.name + " " + (instruction.pushData || "")
    );
  },

  formatPC: function (pc) {
    let hex = pc.toString(16);
    if (hex.length % 2 !== 0) {
      hex = "0" + hex; //ensure even length
    }
    return " (PC=" + pc.toString() + ", 0x" + hex + ")";
  },

  formatStack: function (stack) {
    //stack here is an array of hex words (no "0x")
    var formatted = stack.map((item, index) => {
      item = truffleColors.orange(item);
      item = "  " + item;
      if (index === stack.length - 1) {
        item += " (top)";
      } else {
        item += ` (${stack.length - index - 1} from top)`;
      }

      return item;
    });

    if (stack.length === 0) {
      formatted.unshift("  No data on stack.");
    } else {
      formatted.unshift("Stack:");
    }

    return formatted.join(OS.EOL);
  },

  formatMemory: function (memory) {
    //note memory here is an array of hex words (no "0x"),
    //not a single long hex string

    //get longest prefix needed;
    //minimum of 2 so always show at least 2 hex digits
    let maxPrefixLength = Math.max(
      2,
      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length
    );
    if (maxPrefixLength % 2 !== 0) {
      maxPrefixLength++; //make sure to use even # of hex digits
    }

    let formatted = memory.map((word, index) => {
      let address = (index * Codec.Evm.Utils.WORD_SIZE)
        .toString(16)
        .padStart(maxPrefixLength, "0");
      return `  0x${address}:  ${truffleColors.pink(word)}`;
    });

    if (memory.length === 0) {
      formatted.unshift("  No data in memory.");
    } else {
      formatted.unshift("Memory:");
    }

    return formatted.join(OS.EOL);
  },

  formatStorage: function (storage) {
    //storage here is an object mapping hex words to hex words (no 0x)

    //first: sort the keys (slice to clone as sort is in-place)
    //note: we can use the default sort here; it will do the righ thing
    let slots = Object.keys(storage).slice().sort();

    let formatted = slots.map((slot, index) => {
      if (
        index === 0 ||
        !Codec.Conversion.toBN(slot).eq(
          Codec.Conversion.toBN(slots[index - 1]).addn(1)
        )
      ) {
        return `0x${slot}:\n` + `  ${truffleColors.blue(storage[slot])}`;
      } else {
        return `  ${truffleColors.blue(storage[slot])}`;
      }
    });

    if (slots.length === 0) {
      formatted.unshift("  No known relevant data found in storage.");
    } else {
      formatted.unshift("Storage (partial view):");
    }

    return formatted.join(OS.EOL);
  },

  formatCalldata: function (calldata) {
    //takes a Uint8Array
    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);
    let words = [];
    for (
      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;
      wordIndex < calldata.length;
      wordIndex += Codec.Evm.Utils.WORD_SIZE
    ) {
      words.push(
        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)
      );
    }
    let maxWordIndex =
      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +
      Codec.Evm.Utils.SELECTOR_SIZE;
    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);
    if (maxPrefixLength % 2 !== 0) {
      maxPrefixLength++;
    }
    let formattedSelector;
    if (selector.length > 0) {
      formattedSelector =
        "Calldata:\n" +
        `  0x${"00".padStart(maxPrefixLength, "0")}:  ` +
        truffleColors.pink(
          Codec.Conversion.toHexString(selector)
            .slice(2)
            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, "  ")
        );
    } else {
      formattedSelector = "  No data in calldata.";
    }

    let formatted = words.map((word, index) => {
      let address = (
        index * Codec.Evm.Utils.WORD_SIZE +
        Codec.Evm.Utils.SELECTOR_SIZE
      )
        .toString(16)
        .padStart(maxPrefixLength, "0");
      let data = Codec.Conversion.toHexString(word)
        .slice(2)
        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);
      return `  0x${address}:  ${truffleColors.pink(data)}`;
    });

    formatted.unshift(formattedSelector);

    return formatted.join(OS.EOL);
  },

  formatValue: function (value, indent = 0, nativized = false) {
    let inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    };
    let valueToInspect = nativized
      ? value
      : new Codec.Export.ResultInspector(value);
    return util
      .inspect(valueToInspect, inspectOptions)
      .split(/\r?\n/g)
      .map((line, i) => {
        // don't indent first line
        const padding = i > 0 ? Array(indent).join(" ") : "";
        return padding + line;
      })
      .join(OS.EOL);
  },

  //note: only intended to be used for *custom* errors :)
  formatCustomError: function (decoding, indent = 0) {
    const inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    };
    const name = decoding.definedIn
      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`
      : decoding.abi.name;
    return Codec.Export.formatFunctionLike(
      name,
      decoding.arguments,
      inspectOptions,
      false,
      indent
    );
  },

  formatStacktrace: function (stacktrace, indent = 2) {
    //get message or panic code from stacktrace
    const { message, panic, custom } = stacktrace[0];
    //we want to print inner to outer, so first, let's
    //reverse
    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first
    let lines = stacktrace.map(
      ({
        functionName,
        contractName,
        address,
        location,
        isConstructor,
        type
      }) => {
        let name;
        if (contractName && functionName) {
          name = `${contractName}.${functionName}`;
        } else if (contractName) {
          name =
            type === "external" && isConstructor
              ? `new ${contractName}`
              : contractName;
          //for internal calls, it doesn't really make sense
          //to write "new Contract"
        } else if (functionName) {
          name = functionName;
        } else {
          name = "unknown function";
        }
        let locationString;
        if (location) {
          let {
            source: { sourcePath },
            sourceRange: {
              lines: {
                start: { line, column }
              }
            }
          } = location;
          locationString = sourcePath
            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing
            : "unknown location";
        } else {
          locationString = "unknown location";
        }
        let addressString =
          type === "external"
            ? address !== undefined
              ? ` [address ${address}]`
              : " [unknown address]"
            : "";
        return `at ${name}${addressString} (${locationString})`;
      }
    );
    let status = stacktrace[0].status;
    if (status != undefined) {
      let statusLine;
      if (message !== undefined) {
        statusLine = status
          ? `Error: Improper return (caused message: ${message})`
          : `Error: Revert (message: ${message})`;
      } else if (panic !== undefined) {
        statusLine = status
          ? `Panic: Improper return (caused ${DebugUtils.panicString(
              panic
            ).toLowerCase()} (code 0x${panic.toString(16)}))`
          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(
              16
            )})`;
      } else if (custom !== undefined) {
        statusLine = status
          ? `Error: Improper return (caused custom error)`
          : `Error: Revert (custom error)`;
      } else {
        statusLine = status
          ? "Error: Improper return (may be an unexpected self-destruct)"
          : "Error: Revert or exceptional halt";
      }
      lines.unshift(statusLine);
    }
    let indented = lines.map((line, index) =>
      index === 0 ? line : " ".repeat(indent) + line
    );
    return indented.join(OS.EOL);
  },

  colorize: function (code, language = "Solidity") {
    const options = {
      lang: "solidity",
      colors: trufflePalette,
      //we want to turn off basically everything else, as we're
      //handling padding & numbering manually
      lineNumbers: false,
      stripIndent: false,
      codePad: 0,
      tabsToSpaces: false, //we handle this ourself and don't
      //want chromafi's padding
      lineEndPad: false
    };
    switch (language) {
      case "Solidity":
        return chromafi(code, options);
      case "Yul":
        options.lang = "yul"; //registered along with Solidity :)
        return chromafi(code, options);
      case "Vyper":
        options.lang = "python"; //HACK -- close enough for now!
        return chromafi(code, options);
      default:
        //don't highlight
        return code;
    }
  },

  //HACK
  cleanThis: function (variables, replacement) {
    return Object.assign(
      {},
      ...Object.entries(variables).map(([variable, value]) =>
        variable === "this" ? { [replacement]: value } : { [variable]: value }
      )
    );
  },

  /**
   * HACK warning!  This function modifies the debugger state
   * and should only be used in light mode, at startup, in a very specific way!
   *
   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });
   * const sources = await getTransactionSourcesBeforeStarting(bugger);
   * await bugger.startFullMode();
   *
   * Don't go switching transactions after doing this, because there's no
   * way at the moment to switch back into light mode in order to re-run
   * this function.  You do *not* want to run this in full mode.
   */
  getTransactionSourcesBeforeStarting: async function (bugger) {
    await bugger.reset();
    let sources = {};
    const { controller } = bugger.selectors;
    while (!bugger.view(controller.current.trace.finished)) {
      const source = bugger.view(controller.current.location.source);
      const { compilationId, id, internal } = source;
      //stepInto should skip internal sources, but there still might be
      //one at the end
      if (!internal && compilationId !== undefined && id !== undefined) {
        sources[compilationId] = {
          ...sources[compilationId],
          [id]: source
        };
      }
      await bugger.stepInto();
    }
    await bugger.reset();
    //flatten sources before returning
    return [].concat(...Object.values(sources).map(Object.values));
  }
};

module.exports = DebugUtils;


/***/ }),

/***/ 595532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractInstanceDecoder = exports.ContractDecoder = exports.ProjectDecoder = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("decoder:decoders");
const Abi = __importStar(__webpack_require__(207651));
const Codec = __importStar(__webpack_require__(20102));
const codec_1 = __webpack_require__(20102);
const Encoder = __importStar(__webpack_require__(615967));
const encoder_1 = __webpack_require__(615967);
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const bn_js_1 = __importDefault(__webpack_require__(213550));
const errors_1 = __webpack_require__(613552);
const compile_common_1 = __webpack_require__(529833);
//sorry for the untyped import, but...
const SourceMapUtils = __webpack_require__(832731);
/**
 * The ProjectDecoder class.  Decodes transactions and logs.  See below for a method listing.
 * @category Decoder
 */
class ProjectDecoder {
    /**
     * @protected
     */
    constructor(compilations, provider, ensSettings) {
        this.contexts = {}; //all contexts
        this.deployedContexts = {};
        this.contractsAndContexts = [];
        this.codeCache = {};
        if (!provider) {
            throw new errors_1.NoProviderError();
        }
        this.providerAdapter = new encoder_1.ProviderAdapter(provider);
        this.compilations = compilations;
        this.ensSettings = ensSettings || {};
        let allocationInfo;
        ({
            definitions: this.referenceDeclarations,
            typesByCompilation: this.userDefinedTypesByCompilation,
            types: this.userDefinedTypes
        } = codec_1.Compilations.Utils.collectUserDefinedTypesAndTaggedOutputs(this.compilations));
        ({
            contexts: this.contexts,
            deployedContexts: this.deployedContexts,
            contractsAndContexts: this.contractsAndContexts,
            allocationInfo
        } = codec_1.AbiData.Allocate.Utils.collectAllocationInfo(this.compilations));
        this.allocations = {};
        this.allocations.abi = codec_1.AbiData.Allocate.getAbiAllocations(this.userDefinedTypes);
        this.allocations.storage = codec_1.Storage.Allocate.getStorageAllocations(this.userDefinedTypesByCompilation); //not used by project decoder itself, but used by contract decoder
        this.allocations.calldata = codec_1.AbiData.Allocate.getCalldataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.returndata = codec_1.AbiData.Allocate.getReturndataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.event = codec_1.AbiData.Allocate.getEventAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.state = codec_1.Storage.Allocate.getStateAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.storage);
        debug("done with allocation");
    }
    /**
     * @protected
     */
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //if pending, ignore the cache
            if (block === "pending") {
                return codec_1.Conversion.toBytes(yield this.providerAdapter.getCode(address, block));
            }
            //otherwise, start by setting up any preliminary layers as needed
            if (this.codeCache[block] === undefined) {
                this.codeCache[block] = {};
            }
            //now, if we have it cached, just return it
            if (this.codeCache[block][address] !== undefined) {
                return this.codeCache[block][address];
            }
            //otherwise, get it, cache it, and return it
            let code = codec_1.Conversion.toBytes(yield this.providerAdapter.getCode(address, block));
            this.codeCache[block][address] = code;
            return code;
        });
    }
    /**
     * @protected
     */
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof block === "number" || block === "pending") {
                return block;
            }
            if (block === null) {
                return "pending";
            }
            return (yield this.providerAdapter.getBlockByNumber(block)).number;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Transaction]] object and decodes it.  The result is a
     * [[CalldataDecoding]]; see the documentation on that interface for more.
     *
     * Note that decoding of transactions sent to libraries is presently not
     * supported and may have unreliable results.  Limited support for this is
     * planned for future versions.
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeTransactionWithAdditionalContexts(transaction);
        });
    }
    /**
     * @protected
     */
    decodeTransactionWithAdditionalContexts(transaction, additionalContexts = {}, additionalAllocations) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = transaction.blockNumber;
            const blockNumber = yield this.regularizeBlock(block);
            const isConstructor = transaction.to === null;
            const context = yield this.getContextByAddress(transaction.to, blockNumber, transaction.input, additionalContexts);
            let allocations = this.allocations;
            if (context && !(context.context in this.contexts)) {
                //if the context comes from additionalContexts,
                //we'll add the additional allocations to the allocations;
                //however, we'll allow other allocations to override it...
                //it's only supposed to be used if necessary!
                allocations = Object.assign(Object.assign({}, this.allocations), { calldata: Object.assign(Object.assign({}, this.allocations.calldata), { functionAllocations: Object.assign({ [context.context]: additionalAllocations }, this.allocations.calldata.functionAllocations) }) });
            }
            const data = codec_1.Conversion.toBytes(transaction.input);
            const info = {
                state: {
                    storage: {},
                    calldata: data
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations,
                contexts: Object.assign(Object.assign({}, this.deployedContexts), additionalContexts),
                currentContext: context
            };
            const decoder = codec_1.decodeCalldata(info, isConstructor);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return result.value;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Log]] object and decodes it.  Logs can be ambiguous, so
     * this function returns an array of [[LogDecoding|LogDecodings]].
     *
     * Note that logs are decoded in strict mode, so (with one exception) none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.  The one exception to this is that indexed parameters of reference
     * type cannot meaningfully be decoded, so those will decode to an error.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     *
     * 1. Non-anonymous events coming from the contract itself (these will moreover be ordered
     *   from most derived to most base)
     * 2. Non-anonymous events coming from libraries
     * 3. Anonymous events coming from the contract itself (again, ordered from most derived
     *   to most base)
     * 4. Anonymous events coming from libraries
     *
     * You can check the kind and class.contractKind fields to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Using `options.extras = "on"` or `options.extras = "necessary"` will change the
     * above behavior; see the documentation on [[ExtrasAllowed]] for more.
     *
     * If absolutely necessary, you can also set `options.disableChecks = true` to allow
     * looser decoding.  Only use this option if you know what you are doing.
     *
     * @param log The log to be decoded.
     * @param options Options for controlling decoding.
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeLogWithAdditionalOptions(log, options);
        });
    }
    /**
     * @protected
     */
    decodeLogWithAdditionalOptions(log, options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = log.blockNumber;
            const blockNumber = yield this.regularizeBlock(block);
            const data = codec_1.Conversion.toBytes(log.data);
            const topics = log.topics.map(codec_1.Conversion.toBytes);
            const info = {
                state: {
                    storage: {},
                    eventdata: data,
                    eventtopics: topics
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: Object.assign(Object.assign({}, this.deployedContexts), additionalContexts)
            };
            const decoder = codec_1.decodeEvent(info, log.address, options);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return result.value;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Gets all events meeting certain conditions and decodes them.
     * This function is fairly rudimentary at the moment but more functionality
     * will be added in the future.
     * @param options Used to determine what events to fetch and how to decode
     *   them; see the documentation on the [[EventOptions]] type for more.
     * @return An array of [[DecodedLog|DecodedLogs]].
     *   These consist of a log together with its possible decodings; see that
     *   type for more info.  And see [[decodeLog]] for more info on how log
     *   decoding works in general.
     * @example `events({name: "TestEvent"})` -- get events named "TestEvent"
     *   from the most recent block
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eventsWithAdditionalContexts(options);
        });
    }
    /**
     * @protected
     */
    eventsWithAdditionalContexts(options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let { address, name, fromBlock, toBlock } = options;
            if (fromBlock === undefined) {
                fromBlock = "latest";
            }
            if (toBlock === undefined) {
                toBlock = "latest";
            }
            const fromBlockNumber = yield this.regularizeBlock(fromBlock);
            const toBlockNumber = yield this.regularizeBlock(toBlock);
            const logs = yield this.providerAdapter.getPastLogs({
                address,
                fromBlock: fromBlockNumber,
                toBlock: toBlockNumber
            });
            let events = yield Promise.all(logs.map((log) => __awaiter(this, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, log), { decodings: yield this.decodeLogWithAdditionalOptions(log, options, additionalContexts) }));
            })));
            debug("events: %o", events);
            //if a target name was specified, we'll restrict to events that decoded
            //to something with that name.  (note that only decodings with that name
            //will have been returned from decodeLogs in the first place)
            if (name !== undefined) {
                events = events.filter(event => event.decodings.length > 0);
            }
            return events;
        });
    }
    /**
     * Takes a [[CalldataDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyCalldataDecoding(decoding) {
        return Codec.abifyCalldataDecoding(decoding, this.userDefinedTypes);
    }
    /**
     * Takes a [[LogDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyLogDecoding(decoding) {
        return Codec.abifyLogDecoding(decoding, this.userDefinedTypes);
    }
    /**
     * Takes a [[ReturndataDecoding]], which may have been produced in full mode
     * or ABI mode, and converts it to its ABI mode equivalent.  See the README
     * for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyReturndataDecoding(decoding) {
        return Codec.abifyReturndataDecoding(decoding, this.userDefinedTypes);
    }
    //normally, this function gets the code of the given address at the given block,
    //and checks this against the known contexts to determine the contract type
    //however, if this fails and constructorBinary is passed in, it will then also
    //attempt to determine it from that
    getContextByAddress(address, block, constructorBinary, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let code;
            if (address !== null) {
                code = codec_1.Conversion.toHexString(yield this.getCode(address, block));
            }
            else if (constructorBinary) {
                code = constructorBinary;
            }
            //if neither of these hold... we have a problem
            let contexts = Object.assign(Object.assign({}, this.contexts), additionalContexts);
            return codec_1.Contexts.Utils.findContext(contexts, code);
        });
    }
    //finally: the spawners!
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract decoder for a given contract artifact.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     */
    forArtifact(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            let { compilation, contract } = codec_1.Compilations.Utils.findCompilationAndContract(this.compilations, artifact);
            //to be *sure* we've got the right ABI, we trust the input over what was
            //found
            contract = Object.assign(Object.assign({}, contract), { abi: artifact.abi });
            let contractDecoder = new ContractDecoder(contract, compilation, this, artifact);
            yield contractDecoder.init();
            return contractDecoder;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     * @param address The address of the contract instance to decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(artifact, address) {
        return __awaiter(this, void 0, void 0, function* () {
            let contractDecoder = yield this.forArtifact(artifact);
            return yield contractDecoder.forInstance(address);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.  Unlike [[forInstance]], this method doesn't require an artifact; it
     * will automatically detect the class of the given contract.  If it's not in
     * the project, or the decoder can't identify it, you'll get an exception.
     * @param address The address of the contract instance to decode.
     *   If an invalid address is provided, this method will throw an exception.
     * @param block You can include this argument to specify that this should be
     *   based on the addresses content's at a specific block (if say the contract
     *   has since self-destructed).
     */
    forAddress(address, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            address = web3_utils_1.default.toChecksumAddress(address);
            const blockNumber = yield this.regularizeBlock(block);
            const deployedBytecode = codec_1.Conversion.toHexString(yield this.getCode(address, blockNumber));
            const contractAndContexts = this.contractsAndContexts.find(({ deployedContext }) => deployedContext &&
                codec_1.Contexts.Utils.matchContext(deployedContext, deployedBytecode));
            if (!contractAndContexts) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            const { contract, compilationId } = contractAndContexts;
            const compilation = this.compilations.find(compilation => compilation.id === compilationId);
            let contractDecoder = new ContractDecoder(contract, compilation, this); //no artifact
            //(artifact is only used for address autodetection, and here we're supplying the
            //address, so this won't cause any problems)
            yield contractDecoder.init();
            return yield contractDecoder.forInstance(address);
        });
    }
    //the following functions are intended for internal use only
    /**
     * @protected
     */
    getReferenceDeclarations() {
        return this.referenceDeclarations;
    }
    /**
     * @protected
     */
    getUserDefinedTypes() {
        return this.userDefinedTypes;
    }
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getProviderAdapter() {
        return this.providerAdapter;
    }
    /**
     * @protected
     */
    getEnsSettings() {
        return this.ensSettings;
    }
    /**
     * @protected
     */
    getDeployedContexts() {
        return this.deployedContexts;
    }
}
exports.ProjectDecoder = ProjectDecoder;
/**
 * The ContractDecoder class.  Decodes return values, and spawns the
 * [[ContractInstanceDecoder]] class.  Also, decodes transactions logs.  See
 * below for a method listing.
 * @category Decoder
 */
class ContractDecoder {
    /**
     * @protected
     */
    constructor(contract, compilation, projectDecoder, artifact) {
        this.artifact = artifact; //may be undefined; only used for address autodetection in instance decoder
        this.contract = contract;
        this.compilation = compilation;
        this.projectDecoder = projectDecoder;
        this.providerAdapter = projectDecoder.getProviderAdapter();
        this.contexts = projectDecoder.getDeployedContexts();
        this.userDefinedTypes = this.projectDecoder.getUserDefinedTypes();
        this.contractNode = codec_1.Compilations.Utils.getContractNode(this.contract, this.compilation);
        this.allocations = this.projectDecoder.getAllocations();
        //note: ordinarily this.contract.deployedBytecode should equal artifact.deployedBytecode
        //at this point, so it may seem strange that I'm using this longer version (but not
        //doing anything to handle the case we're there not).  This is basically because I don't
        //think such error handling is really necessary right now, but this way at least it won't
        //crash.
        if (this.contract.deployedBytecode &&
            this.contract.deployedBytecode !== "0x") {
            const unnormalizedContext = codec_1.Contexts.Utils.makeContext(this.contract, this.contractNode, this.compilation);
            this.contextHash = unnormalizedContext.context;
            //we now throw away the unnormalized context, instead fetching the correct one from
            //this.contexts (which is normalized) via the context getter below
        }
        else {
            //if there's no bytecode, allocate output data manually
            const referenceDeclarations = this.projectDecoder.getReferenceDeclarations();
            const compiler = this.compilation.compiler || this.contract.compiler;
            this.noBytecodeAllocations = Object.values(codec_1.AbiData.Allocate.getCalldataAllocations([
                {
                    abi: Abi.normalize(this.contract.abi),
                    compilationId: this.compilation.id,
                    compiler,
                    contractNode: this.contractNode,
                    deployedContext: codec_1.Contexts.Utils.makeContext(Object.assign(Object.assign({}, this.contract), { deployedBytecode: "0x" //only time this should ever appear in a context!
                     }), this.contractNode, this.compilation)
                }
            ], referenceDeclarations, this.userDefinedTypes, this.allocations.abi).functionAllocations)[0];
        }
        if (this.contractNode) {
            //note: there used to be code here to do state allocations for the contract,
            //but now the project decoder does this all up-front
            //(I could change this back if for some reason performance is an issue,
            //but this way is simpler TBH)
            //NOTE: does this change make this intermediate class essentially pointless?
            //Yes.  But not going to get rid of it now!
            if (this.allocations.state[this.compilation.id] &&
                this.allocations.state[this.compilation.id][this.contractNode.id]) {
                this.stateVariableReferences =
                    this.allocations.state[this.compilation.id][this.contractNode.id].members;
            }
            //if it doesn't exist, we will leave it undefined, and then throw an exception when
            //we attempt to decode
        }
    }
    /**
     * @protected
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.contractNetwork = yield this.providerAdapter.getNetworkId();
        });
    }
    get context() {
        return this.contexts[this.contextHash];
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes the return value of a call.  Return values can be ambiguous, so
     * this function returns an array of [[ReturndataDecoding|ReturndataDecodings]].
     *
     * Note that return values are decoded in strict mode, so none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     * 1. The decoded return value from a successful call.
     * 2. The decoded revert message from a call that reverted with a message.
     * 3. A decoding indicating that the call reverted with no message.
     * 4. A decoding indicating that the call self-destructed.
     *
     * You can check the kind and field to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Decoding creation calls with this method is not supported.  If you simply
     * want to decode a revert message from an arbitrary call that you know
     * failed, you may also want to see the [[decodeRevert]] function in
     * `@truffle/codec`.
     *
     * @param abi The abi entry for the function call whose return value is being decoded.
     * @param data The data to be decoded, as a hex string (beginning with "0x").
     * @param options Additional options, such as the block the call occurred in.
     *   See [[ReturnOptions]] for more information.
     */
    decodeReturnValue(abi, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeReturnValueWithAdditionalContexts(abi, data, options);
        });
    }
    /**
     * @protected
     */
    decodeReturnValueWithAdditionalContexts(abi, data, options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            abi = Abi.normalizeEntry(abi); //just to be absolutely certain!
            const block = options.block !== undefined ? options.block : "latest";
            const blockNumber = yield this.regularizeBlock(block);
            const status = options.status; //true, false, or undefined
            const selector = codec_1.AbiData.Utils.abiSelector(abi);
            let allocation;
            if (this.contextHash !== undefined) {
                allocation =
                    this.allocations.calldata.functionAllocations[this.contextHash][selector].output;
            }
            else {
                allocation = this.noBytecodeAllocations[selector].output;
            }
            debug("this.allocations: %O", this.allocations);
            const bytes = codec_1.Conversion.toBytes(data);
            const info = {
                state: {
                    storage: {},
                    returndata: bytes
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: Object.assign(Object.assign({}, this.contexts), additionalContexts),
                currentContext: this.context
            };
            const decoder = codec_1.decodeReturndata(info, allocation, status);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return result.value;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of this contract.
     * @param address The address of the contract instance decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let instanceDecoder = new ContractInstanceDecoder(this, address);
            yield instanceDecoder.init();
            return instanceDecoder;
        });
    }
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.getCode(address, block);
        });
    }
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.regularizeBlock(block);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeTransaction]].
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeTransaction(transaction);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     * @param log The log to be decoded.
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeLog(log, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.events]].
     * @param options Used to determine what events to fetch and how to decode them;
     *   see the documentation on the EventOptions type for more.
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.events(options);
        });
    }
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding) {
        return this.projectDecoder.abifyCalldataDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding) {
        return this.projectDecoder.abifyLogDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding) {
        return this.projectDecoder.abifyReturndataDecoding(decoding);
    }
    //the following functions are for internal use
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getStateVariableReferences() {
        return this.stateVariableReferences;
    }
    /**
     * @protected
     */
    getProjectDecoder() {
        return this.projectDecoder;
    }
    /**
     * @protected
     */
    getNoBytecodeAllocations() {
        return this.noBytecodeAllocations;
    }
    /**
     * @protected
     */
    getContractInfo() {
        return {
            compilation: this.compilation,
            contract: this.contract,
            artifact: this.artifact,
            contractNode: this.contractNode,
            contractNetwork: this.contractNetwork,
            contextHash: this.contextHash
        };
    }
}
exports.ContractDecoder = ContractDecoder;
/**
 * The ContractInstanceDecoder class.  Decodes storage for a specified
 * instance.  Also, decodes transactions, logs, and return values.  See below
 * for a method listing.
 *
 * Note that when using this class to decode transactions, logs, and return
 * values, it does have one advantage over using the ProjectDecoder or
 * ContractDecoder.  If the artifact for the class does not have a
 * deployedBytecode field, the ProjectDecoder (and therefore also the
 * ContractDecoder) will not be able to tell that this instance is of that
 * class, and so will fail to decode transactions sent to it or logs
 * originating from it, and will fall back to ABI mode when decoding return
 * values received from it.  However, the ContractInstanceDecoder has that
 * information and will make use of it, making it possible for it to decode
 * transactions sent to this instance, or logs originating from it, or decode
 * return values received from it in full mode, even if the deployedBytecode
 * field is missing.
 * @category Decoder
 */
class ContractInstanceDecoder {
    /**
     * @protected
     */
    constructor(contractDecoder, address) {
        this.contexts = {}; //deployed contexts only
        this.additionalContexts = {}; //for passing to project decoder when contract has no deployedBytecode
        this.mappingKeys = [];
        this.storageCache = {};
        this.contractDecoder = contractDecoder;
        this.projectDecoder = this.contractDecoder.getProjectDecoder();
        this.providerAdapter = this.projectDecoder.getProviderAdapter();
        if (address !== undefined) {
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            this.contractAddress = web3_utils_1.default.toChecksumAddress(address);
        }
        this.referenceDeclarations = this.projectDecoder.getReferenceDeclarations();
        this.userDefinedTypes = this.projectDecoder.getUserDefinedTypes();
        this.contexts = this.projectDecoder.getDeployedContexts();
        let artifact;
        ({
            compilation: this.compilation,
            contract: this.contract,
            artifact,
            contractNode: this.contractNode,
            contractNetwork: this.contractNetwork,
            contextHash: this.contextHash
        } = this.contractDecoder.getContractInfo());
        this.allocations = this.contractDecoder.getAllocations();
        this.stateVariableReferences =
            this.contractDecoder.getStateVariableReferences();
        //note that if we're in the null artifact case, this.contractAddress should have
        //been set by now, so we shouldn't end up here
        if (this.contractAddress === undefined) {
            this.contractAddress = artifact.networks[this.contractNetwork].address;
        }
        this.compiler = this.compilation.compiler || this.contract.compiler;
    }
    /**
     * @protected
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.contractCode = codec_1.Conversion.toHexString(yield this.getCode(this.contractAddress, yield this.providerAdapter.getBlockNumber() //not "latest" because regularized
            ));
            const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(this.contract.deployedBytecode);
            if (!deployedBytecode || deployedBytecode === "0x") {
                //if this contract does *not* have the deployedBytecode field, then the decoder core
                //has no way of knowing that contracts or function pointers with its address
                //are of its class; this is an especial problem for function pointers, as it
                //won't be able to determine what the selector points to.
                //so, to get around this, we make an "additional context" for the contract,
                //based on its *actual* deployed bytecode as pulled from the blockchain.
                //This way the decoder core can recognize the address as the class, without us having
                //to make serious modifications to contract decoding.  And while sure this requires
                //a little more work, I mean, it's all cached, so, no big deal.
                const contractWithCode = Object.assign(Object.assign({}, this.contract), { deployedBytecode: this.contractCode });
                const extraContext = codec_1.Contexts.Utils.makeContext(contractWithCode, this.contractNode, this.compilation);
                this.contextHash = extraContext.context;
                this.additionalContexts = { [extraContext.context]: extraContext };
                //the following line only has any effect if we're dealing with a library,
                //since the code we pulled from the blockchain obviously does not have unresolved link references!
                //(it's not strictly necessary even then, but, hey, why not?)
                this.additionalContexts = codec_1.Contexts.Utils.normalizeContexts(this.additionalContexts);
                //again, since the code did not have unresolved link references, it is safe to just
                //mash these together like I'm about to
                this.contexts = Object.assign(Object.assign({}, this.contexts), this.additionalContexts);
            }
            //set up encoder for wrapping elementary values.
            //we pass it a provider, so it can handle ENS names.
            let { provider: ensProvider, registryAddress } = this.projectDecoder.getEnsSettings();
            if (ensProvider === undefined) {
                //note: NOT if it's null, if it's null we leave it null
                ensProvider = this.providerAdapter.provider;
            }
            this.encoder = yield Encoder.forProjectInternal({
                provider: ensProvider,
                registryAddress,
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                networkId: this.contractNetwork
            });
            //finally: set up internal functions table (only if source order is reliable;
            //otherwise leave as undefined)
            //unlike the debugger, we don't *demand* an answer, so we won't set up
            //some sort of fake table if we don't have a source map, or if any ASTs are missing
            //(if a whole *source* is missing, we'll consider that OK)
            //note: we don't attempt to handle Vyper source maps!
            const compiler = this.compilation.compiler || this.contract.compiler;
            if (!this.compilation.unreliableSourceOrder &&
                this.contract.deployedSourceMap &&
                compiler.name === "solc" &&
                this.compilation.sources.every(source => !source || source.ast)) {
                //WARNING: untyped code in this block!
                let asts = this.compilation.sources.map(source => source ? source.ast : undefined);
                let instructions = SourceMapUtils.getProcessedInstructionsForBinary(this.compilation.sources.map(source => source ? source.source : undefined), this.contractCode, SourceMapUtils.getHumanReadableSourceMap(this.contract.deployedSourceMap));
                try {
                    //this can fail if some of the source files are missing :(
                    this.internalFunctionsTable =
                        SourceMapUtils.getFunctionsByProgramCounter(instructions, asts, asts.map(SourceMapUtils.makeOverlapFunction), this.compilation.id);
                }
                catch (_) {
                    //just leave the internal functions table undefined
                }
            }
        });
    }
    get context() {
        return this.contexts[this.contextHash];
    }
    checkAllocationSuccess() {
        if (!this.contractNode) {
            throw new errors_1.ContractBeingDecodedHasNoNodeError(this.contract.contractName, this.compilation.id);
        }
        if (!this.stateVariableReferences) {
            throw new errors_1.ContractAllocationFailedError(this.contractNode.id, this.contract.contractName, this.compilation.id);
        }
    }
    decodeVariable(variable, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                state: {
                    storage: {},
                    code: codec_1.Conversion.toBytes(this.contractCode)
                },
                mappingKeys: this.mappingKeys,
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: this.contexts,
                currentContext: this.context,
                internalFunctionsTable: this.internalFunctionsTable
            };
            debug("this.contextHash: %s", this.contextHash);
            const decoder = Codec.decodeVariable(variable.definition, variable.pointer, info, this.compilation.id);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "storage":
                        response = yield this.getStorage(this.contractAddress, request.slot, block);
                        break;
                    case "code":
                        response = yield this.getCode(request.address, block);
                        break;
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            debug("definedIn: %o", variable.definedIn);
            let classType = codec_1.Ast.Import.definitionToStoredType(variable.definedIn, this.compilation.id, this.compiler); //can skip reference decls
            return {
                name: variable.definition.name,
                class: classType,
                value: result.value
            };
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Returns information about the state of the contract, but does not include
     * information about the storage or decoded variables.  See the documentation
     * for the [[ContractState]] type for more.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    state(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let blockNumber = yield this.regularizeBlock(block);
            return {
                class: codec_1.Contexts.Import.contextToType(this.context),
                address: this.contractAddress,
                code: this.contractCode,
                balanceAsBN: new bn_js_1.default(yield this.providerAdapter.getBalance(this.contractAddress, blockNumber)),
                nonceAsBN: new bn_js_1.default(yield this.providerAdapter.getTransactionCount(this.contractAddress, blockNumber))
            };
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes the contract's variables; returns an array of these decoded variables.
     * See the documentation of the [[DecodedVariable]] type for more.
     *
     * Note that variable decoding can only operate in full mode; if the decoder wasn't able to
     * start up in full mode, this method will throw a [[ContractAllocationFailedError]].
     *
     * Note that decoding mappings requires first watching mapping keys in order to get any results;
     * see the documentation for [[watchMappingKey]].
     * Additional methods to make mapping decoding a less manual affair are planned for the future.
     *
     * Also, due to a technical limitation, it is not currently possible to
     * usefully decode internal function pointers.  See the
     * [[Format.Values.FunctionInternalValue|FunctionInternalValue]]
     * documentation and the README for more on how these are handled.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    variables(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let blockNumber = yield this.regularizeBlock(block);
            let result = [];
            for (const variable of this.stateVariableReferences) {
                debug("about to decode %s", variable.definition.name);
                const decodedVariable = yield this.decodeVariable(variable, blockNumber);
                debug("decoded");
                result.push(decodedVariable);
            }
            return result;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes an individual contract variable; returns its value as a
     * [[Format.Values.Result|Result]].  See the documentation for
     * [[variables|variables()]] for various caveats that also apply here.
     *
     * If the variable can't be located, throws an exception.
     * @param nameOrId The name (or numeric ID, if you know that) of the
     *   variable.  Can be given as a qualified name, allowing one to get at
     *   shadowed variables from base contracts.  If given by ID, can be given as a
     *   number or numeric string.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     * @example Consider a contract `Derived` inheriting from a contract `Base`.
     *   Suppose `Derived` has a variable `x` and `Base` has variables `x` and
     *   `y`.  One can access `Derived.x` as `variable("x")` or
     *   `variable("Derived.x")`, can access `Base.x` as `variable("Base.x")`,
     *   and can access `Base.y` as `variable("y")` or `variable("Base.y")`.
     */
    variable(nameOrId, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let blockNumber = yield this.regularizeBlock(block);
            let variable = this.findVariableByNameOrId(nameOrId);
            if (variable === undefined) {
                //if user put in a bad name
                throw new errors_1.VariableNotFoundError(nameOrId);
            }
            return (yield this.decodeVariable(variable, blockNumber)).value;
        });
    }
    findVariableByNameOrId(nameOrId) {
        //case 1: an ID was input
        if (typeof nameOrId === "number" || nameOrId.match(/[0-9]+/)) {
            return this.stateVariableReferences.find(({ definition }) => definition.id === nameOrId);
            //there should be exactly one; returns undefined if none
        }
        //case 2: a name was input
        else if (!nameOrId.includes(".")) {
            //we want to search *backwards*, to get most derived version;
            //we use slice().reverse() to clone before reversing since reverse modifies
            return this.stateVariableReferences
                .slice()
                .reverse()
                .find(({ definition }) => definition.name === nameOrId);
        }
        //case 3: a qualified name was input
        else {
            let [className, variableName] = nameOrId.split(".");
            //again, we'll search backwards, although, uhhh...?
            return this.stateVariableReferences
                .slice()
                .reverse()
                .find(({ definition, definedIn }) => definition.name === variableName && definedIn.name === className);
        }
    }
    getStorage(address, slot, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //if pending, bypass the cache
            if (block === "pending") {
                return codec_1.Conversion.toBytes(yield this.providerAdapter.getStorageAt(address, slot, block), Codec.Evm.Utils.WORD_SIZE);
            }
            //otherwise, start by setting up any preliminary layers as needed
            if (this.storageCache[block] === undefined) {
                this.storageCache[block] = {};
            }
            if (this.storageCache[block][address] === undefined) {
                this.storageCache[block][address] = {};
            }
            //now, if we have it cached, just return it
            if (this.storageCache[block][address][slot.toString()] !== undefined) {
                return this.storageCache[block][address][slot.toString()];
            }
            //otherwise, get it, cache it, and return it
            let word = codec_1.Conversion.toBytes(yield this.providerAdapter.getStorageAt(address, slot, block), Codec.Evm.Utils.WORD_SIZE);
            this.storageCache[block][address][slot.toString()] = word;
            return word;
        });
    }
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.getCode(address, block);
        });
    }
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.regularizeBlock(block);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Watches a mapping key; adds it to the decoder's list of watched mapping
     * keys.  This affects the results of both [[variables|variables()]] and
     * [[variable|variable()]].  When a mapping is decoded, only the values at
     * its watched keys will be included in its value.
     *
     * Note that it is possible
     * to watch mappings that are inside structs, arrays, other mappings, etc;
     * see below for more on how to do this.
     *
     * Note that watching mapping keys is
     * only possible in full mode; if the decoder wasn't able to start up in full
     * mode, this method will throw an exception.
     *
     * (A bad variable name will cause an exception though; that input is checked.)
     * @param variable The variable that the mapping lives under; this works like
     *   the nameOrId argument to [[variable|variable()]].  If the mapping is a
     *   top-level state variable, put the mapping itself here.  Otherwise, put the
     *   top-level state variable it lives under.
     * @param indices Further arguments to watchMappingKey, if given, will be
     *   interpreted as indices into or members of the variable identified by the
     *   variable argument; see the example.  Array indices and mapping
     *   keys are specified by value; struct members are specified by name.
     *
     *   Values (for array indices and mapping keys) may be given in any format
     *   understood by Truffle Encoder; see the documentation for
     *   [[Encoder.ProjectEncoder.wrap|ProjectEncoder.wrap]] for details.
     *
     *   Note that if the path to a given mapping key
     *   includes mapping keys above it, any ancestors will also be watched
     *   automatically.
     * @example First, a simple example.  Say we have a mapping `m` of type
     *   `mapping(uint => uint)`.  You could call `watchMappingKey("m", 0)` to
     *   watch `m[0]`.
     * @example Now for a slightly more complicated example.  Say `m` is of type
     *   `mapping(uint => mapping(uint => uint))`, then to watch `m[3][5]`, you
     *   can call `watchMappingKey("m", 3, 5)`.  This will also automatically
     *   watch `m[3]`; otherwise, watching `m[3][5]` wouldn't do much of
     *   anything.
     * @example Now for a well more complicated example.  Say we have a struct
     *   type `MapStruct` with a member called `map` which is a `mapping(string => string)`,
     *   and say we have a variable `arr` of type `MapStruct[]`, then one could
     *   watch `arr[3].map["hello"]` by calling `watchMappingKey("arr", 3, "map", "hello")`.
     */
    watchMappingKey(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let { slot } = yield this.constructSlot(variable, ...indices);
            //add mapping key and all ancestors
            debug("slot: %O", slot);
            while (slot !== undefined &&
                this.mappingKeys.every(existingSlot => !codec_1.Storage.Utils.equalSlots(existingSlot, slot)
                //we put the newness requirement in the while condition rather than a
                //separate if because if we hit one ancestor that's not new, the futher
                //ones won't be either
                )) {
                if (slot.key !== undefined) {
                    //only add mapping keys
                    this.mappingKeys = [...this.mappingKeys, slot];
                }
                slot = slot.path;
            }
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Opposite of [[watchMappingKey]]; unwatches the specified mapping key.  See
     * watchMappingKey for more on how watching mapping keys works, and on how
     * the parameters work.
     *
     * Note that unwatching a mapping key will also unwatch all its descendants.
     * E.g., if `m` is of type `mapping(uint => mapping(uint => uint))`, then
     * unwatching `m[0]` will also unwatch `m[0][0]`, `m[0][1]`, etc, if these
     * are currently watched.
     */
    unwatchMappingKey(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let { slot } = yield this.constructSlot(variable, ...indices);
            if (slot === undefined) {
                return; //not strictly necessary, but may as well
            }
            //remove mapping key and all descendants
            this.mappingKeys = this.mappingKeys.filter(existingSlot => {
                while (existingSlot !== undefined) {
                    if (codec_1.Storage.Utils.equalSlots(existingSlot, slot)) {
                        return false; //if it matches, remove it
                    }
                    existingSlot = existingSlot.path;
                }
                return true; //if we didn't match, keep the key
            });
        });
    }
    //NOTE: if you decide to add a way to remove a mapping key *without* removing
    //all descendants, you'll need to alter watchMappingKey to use an if rather
    //than a while
    /**
     * **This method is asynchronous.**
     *
     * Behaves mostly as [[ProjectDecoder.decodeTransaction]].  However, it is
     * capable of more robustly decoding transactions that were sent to this
     * particular instance.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeTransactionWithAdditionalContexts(transaction, this.additionalContexts, this.contractDecoder.getNoBytecodeAllocations());
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeLogWithAdditionalOptions(log, options, this.additionalContexts);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ContractDecoder.decodeReturnValue]].
     *
     * If the contract artifact is missing its bytecode, using this method,
     * rather than the one in [[ContractDecoder]], can sometimes provide
     * additional decoding information.
     */
    decodeReturnValue(abi, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractDecoder.decodeReturnValueWithAdditionalContexts(abi, data, options, this.additionalContexts);
        });
    }
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding) {
        return this.projectDecoder.abifyCalldataDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding) {
        return this.projectDecoder.abifyLogDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding) {
        return this.projectDecoder.abifyReturndataDecoding(decoding);
    }
    /**
     * **This method is asynchronous.**
     *
     * This mostly behaves as [[ProjectDecoder.events]].
     * However, unlike other variants of this function, this one, by default, restricts to events originating from this instance's address.
     * If you don't want to restrict like that, you can explicitly use `address: undefined` in the options to disable this.
     * (You can also of course set a different address to restrict to that.)
     * @param options Used to determine what events to fetch; see the documentation on the [[EventOptions]] type for more.
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.eventsWithAdditionalContexts(Object.assign({ address: this.contractAddress }, options), this.additionalContexts);
        });
    }
    //in addition to returning the slot we want, it also returns a Type
    //used in the recursive call
    //HOW TO USE:
    //variable may be a variable id (number or numeric string) or name (string) or qualified name (also string)
    //struct members are given by name (string)
    //array indices and numeric mapping keys may be BN, number, or numeric string
    //string mapping keys should be given as strings. duh.
    //bytes mapping keys should be given as hex strings beginning with "0x"
    //address mapping keys are like bytes; checksum case is not required
    //boolean mapping keys may be given either as booleans, or as string "true" or "false"
    constructSlot(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            //base case: we need to locate the variable and its definition
            if (indices.length === 0) {
                let allocation = this.findVariableByNameOrId(variable);
                if (!allocation) {
                    throw new errors_1.VariableNotFoundError(variable);
                }
                let dataType = codec_1.Ast.Import.definitionToType(allocation.definition, this.compilation.id, this.contract.compiler, "storage");
                let pointer = allocation.pointer;
                if (pointer.location !== "storage") {
                    //i.e., if it's a constant
                    return { slot: undefined, type: undefined };
                }
                return { slot: pointer.range.from.slot, type: dataType };
            }
            //main case
            let parentIndices = indices.slice(0, -1); //remove last index
            let { slot: parentSlot, type: parentType } = yield this.constructSlot(variable, ...parentIndices);
            if (parentSlot === undefined) {
                return { slot: undefined, type: undefined };
            }
            let rawIndex = indices[indices.length - 1];
            let slot;
            let dataType;
            switch (parentType.typeClass) {
                case "array":
                    const wrappedIndex = (yield this.encoder.wrapElementaryValue({ typeClass: "uint", bits: 256 }, rawIndex));
                    const index = wrappedIndex.value.asBN;
                    if (parentType.kind === "static" && index.gte(parentType.length)) {
                        throw new errors_1.ArrayIndexOutOfBoundsError(index, parentType.length, variable, indices);
                    }
                    dataType = parentType.baseType;
                    let size = codec_1.Storage.Allocate.storageSize(dataType, this.userDefinedTypes, this.allocations.storage);
                    if (!codec_1.Storage.Utils.isWordsLength(size)) {
                        return { slot: undefined, type: undefined };
                    }
                    slot = {
                        path: parentSlot,
                        offset: index.muln(size.words),
                        hashPath: parentType.kind === "dynamic"
                    };
                    break;
                case "mapping":
                    let keyType = parentType.keyType;
                    const key = yield this.encoder.wrapElementaryValue(keyType, rawIndex);
                    dataType = parentType.valueType;
                    slot = {
                        path: parentSlot,
                        key,
                        offset: new bn_js_1.default(0)
                    };
                    break;
                case "struct":
                    //NOTE: due to the reliance on storage allocations,
                    //we don't need to use fullType or what have you
                    let allocation = this.allocations.storage[parentType.id].members.find(({ name }) => name === rawIndex); //there should be exactly one
                    if (!allocation) {
                        const stringIndex = typeof rawIndex === "string"
                            ? rawIndex
                            : "specified by non-string argument";
                        throw new errors_1.MemberNotFoundError(stringIndex, parentType, variable, indices);
                    }
                    slot = {
                        path: parentSlot,
                        //need type coercion here -- we know structs don't contain constants but the compiler doesn't
                        offset: allocation.pointer.range.from.slot.offset.clone()
                    };
                    dataType = allocation.type;
                    break;
                default:
                    return { slot: undefined, type: undefined };
            }
            return { slot, type: dataType };
        });
    }
}
exports.ContractInstanceDecoder = ContractInstanceDecoder;
//# sourceMappingURL=decoders.js.map

/***/ }),

/***/ 613552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoProviderError = exports.ArrayIndexOutOfBoundsError = exports.MemberNotFoundError = exports.VariableNotFoundError = exports.InvalidAddressError = exports.ContractAllocationFailedError = exports.ContractNotFoundError = exports.ContractBeingDecodedHasNoNodeError = void 0;
const codec_1 = __webpack_require__(20102);
/**
 * This error indicates that the contract you are attempting to decode does not have AST
 * information associated with it, or that the decoder cannot find it.  This error will
 * be thrown if you attempt to use functions that require AST information with such a contract.
 * @category Exception
 */
class ContractBeingDecodedHasNoNodeError extends Error {
    constructor(contractName, compilationId) {
        const message = `Contract ${contractName} does not appear to have been compiled with Solidity (cannot locate contract node)`;
        super(message);
        this.contractName = contractName;
        this.compilationId = compilationId;
        this.name = "ContractBeingDecodedHasNoNodeError";
    }
}
exports.ContractBeingDecodedHasNoNodeError = ContractBeingDecodedHasNoNodeError;
/**
 * This error indicates that the contract you are attempting to decode could not be found in
 * the project info.  This error will be thrown if you attempt to spawn a contract decoder or
 * contract instance decoder for a contract not appearing in the project info.
 * @category Exception
 */
class ContractNotFoundError extends Error {
    constructor(contractName, bytecode, deployedBytecode, address) {
        let message;
        if (contractName) {
            message = `Contract ${contractName} could not be found in the project information`;
        }
        else {
            message = `Contract at ${address} could not be found in the project information`;
        }
        super(message);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.deployedBytecode = deployedBytecode;
        this.address = address;
        this.name = "ContractNotFoundError";
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
/**
 * This error indicates that something went wrong while attempting to determine the location
 * of this contract's state variables.  This error will be thrown if you attempt to use
 * decoding functions after something went wrong during setup.  Unfortunately, we can't
 * always avoid this at the moment; we're hoping to make this more robust in the future
 * with Truffle DB.  In the meantime, it is at least worth noting that you should not encounter
 * this error if your entire project was written in Solidity and all compiled at once.  Sorry.
 * @category Exception
 */
class ContractAllocationFailedError extends Error {
    constructor(id, contractName, compilationId) {
        super(`No allocation found for contract ID ${id} (${contractName}) in compilation ${compilationId}`);
        this.id = id;
        this.contractName = contractName;
        this.compilationId = compilationId;
        this.name = "ContractAllocationFailedError";
    }
}
exports.ContractAllocationFailedError = ContractAllocationFailedError;
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance decoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
class InvalidAddressError extends Error {
    constructor(address) {
        super(`Invalid address ${address}`);
        this.address = address;
        this.name = "InvalidAddressError";
    }
}
exports.InvalidAddressError = InvalidAddressError;
/**
 * This error indicates that the user requested a variable that does not exist.
 * @category Exception
 */
class VariableNotFoundError extends Error {
    constructor(nameOrId) {
        super(`No such variable ${nameOrId}`);
        this.nameOrId = nameOrId;
        this.name = "VariableNotFoundError";
    }
}
exports.VariableNotFoundError = VariableNotFoundError;
/**
 * This error indicates that the user requested a struct member that does not
 * exist.
 * @category Exception
 */
class MemberNotFoundError extends Error {
    constructor(memberName, structType, variable, indices) {
        const message = `Member ${memberName} does not exist on struct type ${codec_1.Format.Types.typeStringWithoutLocation(structType)} in attempting to access variable ${variable}$, indexSequence ${indices.join(", ")}`;
        super(message);
        this.memberName = memberName;
        this.structType = structType;
        this.variable = variable;
        this.indices = indices;
        this.name = "MemberNotFoundError";
    }
}
exports.MemberNotFoundError = MemberNotFoundError;
/**
 * This error indicates that the user requested an array index that is out
 * of bounds.  Note that currently this error is only thrown when an index
 * is requested that is outside *static* bounds; dynamic array bounds are
 * currently not checked.
 * @category Exception
 */
class ArrayIndexOutOfBoundsError extends Error {
    constructor(index, length, variable, indices) {
        const message = `Index ${index} is out of bounds for array of length ${length} in attempting to access variable ${variable}, index sequence ${indices.join(", ")}`;
        super(message);
        this.index = index.clone();
        this.length = length.clone();
        this.variable = variable;
        this.indices = indices;
        this.name = "ArrayIndexOutOfBoundsError";
    }
}
exports.ArrayIndexOutOfBoundsError = ArrayIndexOutOfBoundsError;
/**
 * This error indicates that no provider was passed to the decoder.
 */
class NoProviderError extends Error {
    constructor() {
        super("No provider was given for the decoder to use.");
        this.name = "NoProviderError";
    }
}
exports.NoProviderError = NoProviderError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 18852:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
# Truffle Decoder

This module provides an interface for decoding contract state, transaction
calldata, events, and return values and revert strings.  It's an interface to
the same low-level decoding functionality that Truffle Debugger uses.  However,
it has additional functionality that the debugger does not need, and the
debugger has additional functionality that this decoder does not need.

The interface is split into three classes: The project decoder, the contract
decoder, and the contract instance decoder.  The project decoder is associated
to the project as a whole and decodes transaction calldata and events.  The
contract decoder is associated to a specific contract class.  It has all the
capabilities of the project decoder, but it can also decode return values from
calls made by the given contract class.  The contract instance decoder is
associated to a specific contract instance; it again has all the capabilities
of the project decoder and contract decoder, but it can also decode the state
variables for the specific instance.  (In addition, in the case that the
contract does not include a `deployedBytecode` field in its artifact, which can
hinder decoding certain things, the contract instance decoder can sometimes
work around this where the other decoders cannot.)

This documentation describes the current state of the decoder, but further
improvements are planned.

## Usage

### Initialization

Create a decoder with one of the various constructor functions.

For a project decoder, use the [[forProject|`forProject`]] function.

For a contract decoder, use the [[forArtifact|`forArtifact`]] or
[[forContract|`forContract`]] function.

For a contract instance decoder, use one of the following:
* [[forDeployedArtifact|`forDeployedArtifact`]]
* [[forDeployedContract|`forDeployedContract`]]
* [[forArtifactAt|`forArtifactAt`]]
* [[forContractAt|`forContractAt`]]
* [[forContractInstance|`forContractInstance`]]
* [[forAddress|`forAddress`]]

See the documentation of these functions for details, or below for usage
examples.

All of these functions take a final argument in which information about the
project is specified; currently only a few methods for specifying project
information are allowed, but more are planned.

One can also spawn decoders from other decoders by supplying additional
information.  See the documentation for the individual decoder classes for a
method listing.

### Decoder methods

See the documentation for the individual decoder classes for a method listing.

### Output format information

The decoder outputs lossless, machine-readable [[Format.Values.Result]] objects
containing individual decoded values. See the [[Format|format documentation]]
for an overview and complete module listing.

### Decoding modes, abification, and caveats

The decoder runs in either of two modes: full mode or ABI mode. Full mode
requires some additional constraints but returns substantially more detailed
information. Please see the notes on [decoding modes](../#decoding-modes) for
more about this distinction.

See also the notes about [decoding state variables](../#additional-notes-on-decoding-state-variables) for additional
caveats about what may or may not be fully decodable.

### Basic usage examples

#### Decoding a log with the project decoder

This usage example is for a project with two contracts, `Contract1` and
`Contract2`.

```typescript
import { forProject } from "@truffle/decoder";
const contract1 = artifacts.require("Contract1");
const contract2 = artifacts.require("Contract2");
const provider = web3.currentProvider;
const decoder = await Decoder.forProject(provider, [contract1, contract2]);
const decodings = await decoder.decodeLog(log);
```

The usage of [[ProjectDecoder.decodeTransaction|decodeTransaction]] is similar.

For getting already-decoded logs meeting appropriate conditions, see
[[ProjectDecoder.events]].

#### Decoding state variables with the contract instance decoder

This usage example is for decoding the state variables of a contract `Contract`
in a project that also contains a contract `OtherContract`.

```typescript
import { forContract } from "@truffle/decoder";
const contract = artifacts.require("Contract");
const otherContract = artifacts.require("OtherContract");
const decoder = await Decoder.forContract(contract, [otherContract]);
const instanceDecoder = await decoder.forInstance();
const variables = await instanceDecoder.variables();
```

In this example, we use the deployed version of `Contract`.  If we wanted an
instance at a different address, we could pass the address to `forInstance`.

In addition, rather than using `forContract` and then `forInstance`, we could
also use [[forDeployedContract|`forContractInstance`]] to perform both of these
in one step.  If we wanted to do this with a specified address, we could use
[[forContractAt|`forContractAt`]].

Yet another way would be:
```typescript
import { forContractInstance } from "@truffle/decoder";
const contract = artifacts.require("Contract");
const otherContract = artifacts.require("OtherContract");
const deployedContract = await contract.deployed();
const instanceDecoder = await Decoder.forContractInstance(deployedContract, [otherContract]);
const variables = await instanceDecoder.variables();
```

These examples are not exhaustive.

One can find more advanced decoding examples with
[[ContractInstanceDecoder.variable|`variable`]] and
[[ContractInstanceDecoder.watchMappingKey|`watchMappingKey`]] at the
documentation for these individual functions.
 *
 * @module @truffle/decoder
 * @packageDocumentation
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forAddress = exports.forContractInstance = exports.forContractAt = exports.forArtifactAt = exports.forDeployedContract = exports.forDeployedArtifact = exports.forContract = exports.forArtifact = exports.forProject = exports.NoProviderError = exports.VariableNotFoundError = exports.InvalidAddressError = exports.ContractAllocationFailedError = exports.ContractNotFoundError = exports.ContractBeingDecodedHasNoNodeError = exports.ProjectDecoder = exports.ContractInstanceDecoder = exports.ContractDecoder = void 0;
const decoders_1 = __webpack_require__(595532);
Object.defineProperty(exports, "ContractDecoder", ({ enumerable: true, get: function () { return decoders_1.ContractDecoder; } }));
Object.defineProperty(exports, "ContractInstanceDecoder", ({ enumerable: true, get: function () { return decoders_1.ContractInstanceDecoder; } }));
Object.defineProperty(exports, "ProjectDecoder", ({ enumerable: true, get: function () { return decoders_1.ProjectDecoder; } }));
var errors_1 = __webpack_require__(613552);
Object.defineProperty(exports, "ContractBeingDecodedHasNoNodeError", ({ enumerable: true, get: function () { return errors_1.ContractBeingDecodedHasNoNodeError; } }));
Object.defineProperty(exports, "ContractNotFoundError", ({ enumerable: true, get: function () { return errors_1.ContractNotFoundError; } }));
Object.defineProperty(exports, "ContractAllocationFailedError", ({ enumerable: true, get: function () { return errors_1.ContractAllocationFailedError; } }));
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return errors_1.InvalidAddressError; } }));
Object.defineProperty(exports, "VariableNotFoundError", ({ enumerable: true, get: function () { return errors_1.VariableNotFoundError; } }));
Object.defineProperty(exports, "NoProviderError", ({ enumerable: true, get: function () { return errors_1.NoProviderError; } }));
const codec_1 = __webpack_require__(20102);
/**
 * **This function is asynchronous.**
 *
 * Constructs a project decoder for the project.
 * See the [[DecoderSettings]] documentation for further information.
 * @category Provider-based Constructor
 */
function forProject(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let compilations = codec_1.Compilations.Utils.infoToCompilations(settings.projectInfo);
        let ensSettings = ensSettingsForInfo(settings);
        return new decoders_1.ProjectDecoder(compilations, settings.provider, ensSettings);
    });
}
exports.forProject = forProject;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract decoder for a given contract artifact.
 * @param artifact The artifact for the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!settings.projectInfo) {
            settings = Object.assign(Object.assign({}, settings), { projectInfo: { artifacts: [artifact] } });
        }
        let projectDecoder = yield forProject(settings);
        return yield projectDecoder.forArtifact(artifact);
    });
}
exports.forArtifact = forArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract decoder for a given contract.
 * @param contract The contract constructor object corresponding to the type of
 *   the contract.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forArtifact(contract, Object.assign({ provider: contract.web3.currentProvider }, settings));
    });
}
exports.forContract = forContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a deployed contract instance.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forDeployedArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forArtifact(artifact, settings);
        let instanceDecoder = yield contractDecoder.forInstance();
        return instanceDecoder;
    });
}
exports.forDeployedArtifact = forDeployedArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a deployed contract instance.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forDeployedContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forContract(contract, settings);
        let instanceDecoder = yield contractDecoder.forInstance();
        return instanceDecoder;
    });
}
exports.forDeployedContract = forDeployedContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forArtifactAt(artifact, address, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forArtifact(artifact, settings);
        let instanceDecoder = yield contractDecoder.forInstance(address);
        return instanceDecoder;
    });
}
exports.forArtifactAt = forArtifactAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContractAt(contract, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forContract(contract, settings);
        let instanceDecoder = yield contractDecoder.forInstance(address);
        return instanceDecoder;
    });
}
exports.forContractAt = forContractAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a given contract instance.
 * @param contract The contract abstraction object corresponding to the contract instance.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContractInstance(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forContractAt(contract.constructor, contract.address, settings);
    });
}
exports.forContractInstance = forContractInstance;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a given instance of a contract in this
 * project.  Unlike the other functions, this method doesn't require giving an
 * artifact for the address itself; however, the address had better correspond to
 * a contract of a type given in the project info, or you'll get an exception.
 * @param address The address of the contract instance to decode.
 *   If an invalid address is provided, this method will throw an exception.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forAddress(address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectDecoder = yield forProject(settings);
        return yield projectDecoder.forAddress(address);
    });
}
exports.forAddress = forAddress;
//warning: copypasted from @truffle/encoder!
//Also the category is fake but is put here to hide it :P
/**
 * @category Provider-based constructor
 */
function ensSettingsForInfo(settings) {
    if (settings.ens) {
        return settings.ens;
    }
    else {
        return {
            provider: settings.provider
        };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 771861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getEnsAddress, default: ENSJS } = __webpack_require__(426143);
const contract = __webpack_require__(378883);
const { sha3 } = __webpack_require__(118269);
const { hash } = __webpack_require__(159873);

class ENS {
  constructor({ provider, networkId, ens }) {
    this.networkId = networkId;
    this.provider = provider;
    this.devRegistry = null;
    // we need a reference to the ens field to update it for @truffle/contract
    this.ens = ens;
  }

  determineENSRegistryAddress() {
    if (this.ens.registryAddress) {
      return this.ens.registryAddress;
    } else if (this.ensjs) {
      return this.ensjs.ens.address;
    } else {
      const message =
        `Truffle could not locate the address of the ENS ` +
        `registry for the network you are using. You must either be on a` +
        `known network or a development blockchain.`;
      throw new Error(message);
    }
  }

  async deployNewDevENSRegistry(from) {
    const ENSRegistryArtifact = __webpack_require__(756442);
    const ENSRegistry = contract(ENSRegistryArtifact);
    ENSRegistry.setProvider(this.provider);
    const ensRegistry = await ENSRegistry.new({ from });
    this.ens.registryAddress = ensRegistry.address;
    this.devRegistry = ensRegistry;
    this.setENSJS();
    return ensRegistry;
  }

  async ensureResolverExists({ from, name }) {
    // See if the resolver is set, if not then set it
    const resolverAddress = await this.ensjs.name(name).getResolver();
    // names with no set resolver have 0x0 returned
    if (resolverAddress !== "0x0000000000000000000000000000000000000000") {
      const resolvedAddress = await this.ensjs.name(name).getAddress("ETH");
      return { resolvedAddress };
    }
    // deploy a resolver if one isn't set
    const PublicResolverArtifact = __webpack_require__(332927);
    const PublicResolver = contract(PublicResolverArtifact);
    PublicResolver.setProvider(this.provider);

    let registryAddress = this.determineENSRegistryAddress();

    const publicResolver = await PublicResolver.new(registryAddress, { from });
    await this.ensjs.name(name).setResolver(publicResolver.address, { from });
    return { resolvedAddress: null };
  }

  async setAddress(name, addressOrContract, { from }) {
    this.validateSetAddressInputs({ addressOrContract, name, from });
    const address = this.parseAddress(addressOrContract);
    try {
      this.setENSJS();
    } catch (error) {
      if (error.message.includes("error instantiating the ENS")) {
        await this.deployNewDevENSRegistry(from);
        this.setENSJS();
      }
    }

    // In the case where there is a registry deployed by the user,
    // set permissions so that the resolver can be set by the user
    if (this.devRegistry) await this.setNameOwner({ from, name });

    // Find the owner of the name and compare it to the "from" field
    const nameOwner = await this.ensjs.name(name).getOwner();

    if (nameOwner !== from) {
      const message =
        `The default address or address provided in the "from" ` +
        `field for registering does not own the specified ENS name. The ` +
        `"from" field address must match the owner of the name.` +
        `\n> Failed to register ENS name ${name}` +
        `\n> Address in "from" field - ${from}` +
        `\n> Current owner of '${name}' - ${nameOwner}`;
      throw new Error(message);
    }

    const { resolvedAddress } = await this.ensureResolverExists({ from, name });
    // If the resolver points to a different address or is not set,
    // then set it to the specified address
    if (resolvedAddress !== address) {
      await this.ensjs.name(name).setAddress("ETH", address);
    }
  }

  async setNameOwner({ name, from }) {
    const nameLabels = name.split(".").reverse();

    // Set top-level name
    let builtName = nameLabels[0];
    await this.devRegistry.setSubnodeOwner("0x0", sha3(builtName), from, {
      from
    });

    // If name is only one label, stop here
    if (nameLabels.length === 1) return;

    for (const label of nameLabels.slice(1)) {
      await this.devRegistry.setSubnodeOwner(
        hash(builtName),
        sha3(label),
        from,
        { from }
      );
      builtName = label.concat(`.${builtName}`);
    }
  }

  parseAddress(addressOrContract) {
    if (typeof addressOrContract === "string") return addressOrContract;
    try {
      return addressOrContract.address;
    } catch (error) {
      const message =
        `You have not entered a valid address or contract ` +
        `object with an address property. Please ensure that you enter a ` +
        `valid address or pass in a valid artifact.`;
      throw new Error(message);
    }
  }

  validateSetAddressInputs({ addressOrContract, name, from }) {
    if (
      !addressOrContract ||
      !name ||
      !from ||
      (typeof addressOrContract !== "string" &&
        typeof addressOrContract !== "object") ||
      typeof name !== "string" ||
      typeof from !== "string"
    ) {
      const message =
        `The 'address', 'name', or 'from' parameter is invalid for ` +
        `the call to the setAddress function. Please ensure that you are ` +
        `passing valid values. The received input values were the ` +
        `following:\n   - address: ${addressOrContract}\n   - name: ${name}\n   - from: ` +
        `${from}\n`;
      throw new Error(message);
    }
  }

  setENSJS() {
    let ensAddress;
    try {
      ensAddress = this.ens.registryAddress || getEnsAddress(this.networkId);

      this.ensjs = new ENSJS({
        provider: this.provider,
        ensAddress
      });
    } catch (error) {
      const message =
        `There was an error instantiating the ENS library. ` +
        `Please ensure you have the correct ENS registry address. Truffle` +
        `is currently using ${ensAddress}.`;
      throw new Error(`${message} - ${error.message}`);
    }
  }
}

module.exports = ENS;


/***/ }),

/***/ 400669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const expect = __webpack_require__(414096);
const DeferredChain = __webpack_require__(917162);
const Deployment = __webpack_require__(891432);
const link = __webpack_require__(813690);
const create = __webpack_require__(963218);
const ENS = __webpack_require__(771861);

class Deployer extends Deployment {
  constructor(options) {
    expect.options(options, ["provider", "networks", "network", "network_id"]);
    super(options);

    this.options = options;
    this.chain = new DeferredChain();
    this.network = options.network;
    this.networks = options.networks;
    this.network_id = options.network_id;
    this.provider = options.provider;
    this.known_contracts = {};
    if (options.ens && options.ens.enabled) {
      options.ens.registryAddress = this.networks[this.network].registry
        ? this.networks[this.network].registry.address
        : null;
      this.ens = new ENS({
        provider: options.provider,
        networkId: options.network_id,
        ens: options.ens
      });
    }

    (options.contracts || []).forEach(
      contract => (this.known_contracts[contract.contract_name] = contract)
    );
  }

  // Note: In all code below we overwrite this.chain every time .then() is used
  // in order to ensure proper error processing.
  start() {
    return this.chain.start();
  }

  link(library, destinations) {
    return this.queueOrExec(link(library, destinations, this));
  }

  deploy() {
    const args = Array.prototype.slice.call(arguments);
    const contract = args.shift();
    return this.queueOrExec(this.executeDeployment(contract, args, this));
  }

  new() {
    const args = Array.prototype.slice.call(arguments);
    const contract = args.shift();

    return this.queueOrExec(create(contract, args, this));
  }

  then(fn) {
    return this.queueOrExec(function () {
      return fn(this);
    });
  }

  queueOrExec(fn) {
    return this.chain.started == true
      ? new Promise(accept => accept()).then(fn)
      : this.chain.then(fn);
  }

  finish() {
    this.close();
  }
}

module.exports = Deployer;


/***/ }),

/***/ 813690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Linker = __webpack_require__(506227);

module.exports = function(library, destinations, deployer) {
  return async function() {
    await Linker.link(library, destinations, deployer);
  };
};


/***/ }),

/***/ 963218:
/***/ ((module) => {

module.exports = function (contract, args, deployer) {
  return async function () {
    if (deployer.options.events) {
      await deployer.options.events.emit("deployment:newContract", {
        contract
      });
    }
    return contract.new.apply(contract, args);
  };
};


/***/ }),

/***/ 917162:
/***/ ((module) => {

function DeferredChain() {
  var self = this;
  this.chain = new Promise(function(accept, reject) {
    self._accept = accept;
    self._reject = reject;
  });

  this.await = new Promise(function() {
    self._done = arguments[0];
    self._error = arguments[1];
  });
  this.started = false;
}

DeferredChain.prototype.then = function(fn) {
  var self = this;
  this.chain = this.chain.then(function() {
    var args = Array.prototype.slice.call(arguments);

    return fn.apply(null, args);
  });
  this.chain = this.chain.catch(function(e) {
    self._error(e);
  });

  return this;
};

DeferredChain.prototype.catch = function(fn) {
  this.chain = this.chain.catch(function() {
    var args = Array.prototype.slice.call(arguments);

    return fn.apply(null, args);
  });

  return this;
};

DeferredChain.prototype.start = function() {
  this.started = true;
  this.chain = this.chain.then(this._done);
  this._accept();
  return this.await;
};

module.exports = DeferredChain;


/***/ }),

/***/ 891432:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("deployer:deployment"); // eslint-disable-line no-unused-vars
const sanitizeMessage = __webpack_require__(284331);

/**
 * @class  Deployment
 */
class Deployment {
  /**
   * constructor
   * @param  {Number} confirmations   confirmations needed to resolve an instance
   */
  constructor(options) {
    const networkConfig = options.networks[options.network] || {};
    this.confirmations = options.confirmations || 0;
    this.timeoutBlocks = options.timeoutBlocks || 0;
    this.pollingInterval = networkConfig.deploymentPollingInterval || 4000;
    this.promiEventEmitters = [];
    this.confirmationsMap = {};
    this.blockPoll;
    this.options = options;
  }

  async emit(name, data) {
    if (this.options && this.options.events) {
      return await this.options.events.emit(name, data);
    }
  }

  // ------------------------------------  Utils ---------------------------------------------------

  /**
   * Stub for future error code assignments on process.exit
   * @private
   * @param  {String} name contract name
   * @return {Number}      code to exit
   */
  _errors() {
    return `Migrations failure`;
  }

  /**
   * Helper to parse a deploy statement's overwrite option
   * @private
   * @param  {Arry}    args        arguments passed to deploy
   * @param  {Boolean} isDeployed  is contract deployed?
   * @return {Boolean}             true if overwrite is ok
   */
  _canOverwrite(args, isDeployed) {
    const lastArg = args[args.length - 1];
    const isObject = typeof lastArg === "object";

    const overwrite = isObject && isDeployed && lastArg.overwrite === false;

    isObject && delete lastArg.overwrite;
    return !overwrite;
  }

  /**
   * Gets arbitrary values from constructor params, if they exist.
   * @private
   * @param  {Array}              args constructor params
   * @return {Any|Undefined}      gas value
   */
  _extractFromArgs(args, key) {
    let value;

    args.forEach(arg => {
      const hasKey =
        !Array.isArray(arg) &&
        typeof arg === "object" &&
        Object.keys(arg).includes(key);

      if (hasKey) value = arg[key];
    });
    return value;
  }

  /**
   * Emits a `block` event on each new block heard. This polling is
   * meant to be cancelled immediately on resolution of the
   * contract instance or on error. (See stopBlockPolling)
   * @private
   * @param  {Object}    interfaceAdapter
   */
  async _startBlockPolling(interfaceAdapter) {
    const self = this;
    const startTime = new Date().getTime();

    let secondsWaited = 0;
    let blocksWaited = 0;
    let currentBlock = await interfaceAdapter.getBlockNumber();

    self.blockPoll = setInterval(async () => {
      const newBlock = await interfaceAdapter.getBlockNumber();

      blocksWaited = newBlock - currentBlock + blocksWaited;
      currentBlock = newBlock;
      secondsWaited = Math.floor((new Date().getTime() - startTime) / 1000);

      const data = {
        blockNumber: newBlock,
        blocksWaited: blocksWaited,
        secondsWaited: secondsWaited
      };

      await self.emit("deployment:block", data);
    }, self.pollingInterval);
  }

  /**
   * Clears the interval timer initiated by `startBlockPolling
   * @private
   */
  _stopBlockPolling() {
    clearInterval(this.blockPoll);
  }

  /**
   * Waits `n` blocks after a tx is mined, firing a pseudo
   * 'confirmation' event for each one.
   * @private
   * @param  {Number} blocksToWait
   * @param  {Object} receipt
   * @param  {Object} interfaceAdapter
   * @return {Promise}             Resolves after `blockToWait` blocks
   */
  async _waitBlocks(blocksToWait, state, interfaceAdapter) {
    const self = this;
    let currentBlock = await interfaceAdapter.getBlockNumber();

    return new Promise(accept => {
      let blocksHeard = 0;

      const poll = setInterval(async () => {
        const newBlock = await interfaceAdapter.getBlockNumber();
        if (newBlock > currentBlock) {
          blocksHeard = newBlock - currentBlock + blocksHeard;
          currentBlock = newBlock;

          const data = {
            contractName: state.contractName,
            receipt: state.receipt,
            num: blocksHeard,
            block: currentBlock
          };
          await self.emit("deployment:confirmation", data);
        }

        if (blocksHeard >= blocksToWait) {
          clearInterval(poll);
          accept();
        }
      }, self.pollingInterval);
    });
  }

  /**
   * Sanity checks catch-all:
   * Are we connected?
   * Is contract deployable?
   * @private
   * @param  {Object} contract TruffleContract
   * @return {Promise}         throws on error
   */
  async _preFlightCheck(contract) {
    // Check that contract is not array
    if (Array.isArray(contract)) {
      const data = {
        type: "noBatches",
        contract
      };
      const message = await this.emit("deployment:error", data);

      throw new Error(sanitizeMessage(message));
    }

    // Check bytecode
    if (contract.bytecode === "0x") {
      const data = {
        type: "noBytecode",
        contract
      };
      const message = await this.emit("deployment:error", data);

      throw new Error(sanitizeMessage(message));
    }

    // Check network
    await contract.detectNetwork();
  }

  /**
   * Handler for contract's `transactionHash` event. Rebroadcasts as a deployer event
   * @private
   * @param  {Object} parent Deployment instance. Local `this` belongs to promievent
   * @param  {String} hash   tranactionHash
   */
  async _hashCb(parent, state, hash) {
    const eventArgs = {
      contractName: state.contractName,
      transactionHash: hash
    };
    state.transactionHash = hash;
    await parent.emitter.emit("transactionHash", eventArgs);
    this.removeListener("transactionHash", parent._hashCb);
  }

  /**
   * Handler for contract's `receipt` event. Rebroadcasts as a deployer event
   * @private
   * @param  {Object} parent  Deployment instance. Local `this` belongs to promievent
   * @param  {Object} state   store for the receipt value
   * @param  {Object} receipt
   */
  async _receiptCb(parent, state, receipt) {
    const eventArgs = {
      contractName: state.contractName,
      receipt: receipt
    };

    // We want this receipt available for the post-deploy event
    // so gas reporting is at hand there.
    state.receipt = receipt;
    await parent.emitter.emit("receipt", eventArgs);
    this.removeListener("receipt", parent._receiptCb);
  }

  // ----------------- Confirmations Handling (temporarily disabled) -------------------------------
  /**
  * There are outstanding issues at both geth (with websockets) & web3 (with confirmation handling
  @@ -247,27 +221,6 @@ class Deployment {
  });
  }

  /**
  * Handler for contract's `confirmation` event. Rebroadcasts as a deployer event
  * and maintains a table of txHashes & their current confirmation number. This
  * table gets polled if the user needs to wait a few blocks before getting
  * an instance back.
  * @private
  * @param  {Object} parent  Deployment instance. Local `this` belongs to promievent
  * @param  {Number} num     Confirmation number
  * @param  {Object} receipt transaction receipt
  */
  async _confirmationCb(parent, state, num, receipt) {
    const eventArgs = {
      contractName: state.contractName,
      num: num,
      receipt: receipt
    };

    parent.confirmationsMap[receipt.transactionHash] = num;
    await parent.emitter.emit("confirmation", eventArgs);
  }

  // ----------------- Confirmations Handling (temporarily disabled) -------------------------------
  /**
   * There are outstanding issues at both geth (with websockets) & web3 (with confirmation handling
   * over RPC) that impair the confirmations handlers' reliability. In the interim we're using
   * simple block polling instead. (See also _confirmationCb )
   *
   * Queries the confirmations mapping periodically to see if we have
   * heard enough confirmations for a given tx to allow `deploy` to complete.
   * Resolves when this is true.
   *
   * @private
   * @param  {String} hash contract creation tx hash
   * @return {Promise}
   */
  async _waitForConfirmations(hash) {
    let interval;
    const self = this;

    return new Promise(accept => {
      interval = setInterval(() => {
        if (self.confirmationsMap[hash] >= self.confirmations) {
          clearInterval(interval);
          accept();
        }
      }, self.pollingInterval);
    });
  }

  // ------------------------------------ Methods --------------------------------------------------
  /**
   *
   * @param  {Object} contract  Contract abstraction
   * @param  {Array}  args      Constructor arguments
   * @return {Promise}          Resolves an instance
   */
  executeDeployment(contract, args) {
    const self = this;
    return async function () {
      await self._preFlightCheck(contract);

      let instance;
      let eventArgs;
      let shouldDeploy = true;
      let state = {
        contractName: contract.contractName
      };

      const isDeployed = contract.isDeployed();
      const newArgs = await Promise.all(args);
      const currentBlock = await contract.interfaceAdapter.getBlock("latest");

      // Last arg can be an object that tells us not to overwrite.
      if (newArgs.length > 0) {
        shouldDeploy = self._canOverwrite(newArgs, isDeployed);
      }

      // Case: deploy:
      if (shouldDeploy) {
        /*
          Set timeout override. If this value is zero,
          @truffle/contract will defer to web3's defaults:
          - 50 blocks (websockets) OR 50 * 15sec (http)
        */
        contract.timeoutBlocks = self.timeoutBlocks;

        eventArgs = {
          state: state,
          contract: contract,
          deployed: isDeployed,
          blockLimit: currentBlock.gasLimit,
          gas: self._extractFromArgs(newArgs, "gas") || contract.defaults().gas,
          gasPrice:
            self._extractFromArgs(newArgs, "gasPrice") ||
            contract.defaults().gasPrice,
          from:
            self._extractFromArgs(newArgs, "from") || contract.defaults().from
        };

        // Get an estimate for previews / detect constructor revert
        // NB: web3 does not strip the revert msg here like it does for `deploy`
        try {
          eventArgs.estimate = await contract.new.estimateGas.apply(
            contract,
            newArgs
          );
        } catch (err) {
          eventArgs.estimateError = err;
        }

        // Emit `deployment:start` & send transaction
        await self.emit("deployment:start", eventArgs);

        const promiEvent = contract.new.apply(contract, newArgs);

        // Track emitters for cleanup on exit
        self.promiEventEmitters.push(promiEvent);

        // Subscribe to contract events / rebroadcast them to any reporters
        promiEvent
          .on("transactionHash", async hash => {
            const data = {
              contractName: state.contractName,
              transactionHash: hash
            };
            await self.emit("deployment:txHash", data);
          })
          .on("receipt", receipt => {
            // We want this receipt available for the post-deploy event
            // so gas reporting is at hand there.
            state.receipt = receipt;
          });

        await self._startBlockPolling(contract.interfaceAdapter);

        // Get instance (or error)
        try {
          instance = await promiEvent;
          self._stopBlockPolling();
        } catch (err) {
          self._stopBlockPolling();
          eventArgs.error = err.error || err;
          const message = await self.emit("deployment:failed", eventArgs);
          self.close();
          throw new Error(sanitizeMessage(message));
        }

        // Case: already deployed
      } else {
        instance = await contract.deployed();
      }

      // Emit `postDeploy`
      eventArgs = {
        contract: contract,
        instance: instance,
        deployed: shouldDeploy,
        receipt: state.receipt
      };

      await self.emit("deployment:succeed", eventArgs);

      // Wait for `n` blocks
      if (self.confirmations !== 0 && shouldDeploy) {
        await self._waitBlocks(
          self.confirmations,
          state,
          contract.interfaceAdapter
        );
      }
      // Finish: Ensure the address and tx-hash are set on the contract.
      contract.address = instance.address;
      contract.transactionHash = instance.transactionHash;
      return instance;
    };
  }

  /**
   * Cleans up promiEvents' emitter listeners
   */
  close() {
    this.promiEventEmitters.forEach(item => {
      item.removeAllListeners();
    });
  }
}

module.exports = Deployment;


/***/ }),

/***/ 506227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const sanitizeMessage = __webpack_require__(284331);

module.exports = {
  link: async function (library, destinations, deployer) {
    let eventArgs;
    let libraryName = library.contractName;
    if (libraryName == null && library.constructor) {
      //allow for the possibility that library is an instance rather
      //than a class
      libraryName = library.constructor.contractName;
    }

    // Validate name (it might still be undefined)
    if (libraryName == null) {
      eventArgs = {
        type: "noLibName"
      };

      let message;
      if (deployer.options && deployer.options.events) {
        message = await deployer.options.events.emit(
          "deployment:error",
          eventArgs
        );
      }
      throw new Error(sanitizeMessage(message));
    }

    // Validate address: don't want to use .address directly because it will throw.
    let hasAddress;

    typeof library.isDeployed === "function"
      ? (hasAddress = library.isDeployed())
      : (hasAddress = library.address != null);

    if (!hasAddress) {
      eventArgs = {
        type: "noLibAddress",
        contract: library
      };

      let message;
      if (deployer.options && deployer.options.events) {
        message = await deployer.options.events.emit(
          "deployment:error",
          eventArgs
        );
      }
      throw new Error(sanitizeMessage(message));
    }
    // Link all destinations
    if (!Array.isArray(destinations)) {
      destinations = [destinations];
    }

    for (let destination of destinations) {
      // Don't link if result will have no effect.
      const alreadyLinked = destination.links[libraryName] === library.address;
      const noLinkage = !destination.unlinked_binary.includes(libraryName);

      if (alreadyLinked || noLinkage) continue;

      eventArgs = {
        libraryName,
        libraryAddress: library.address,
        contractName: destination.contractName,
        contractAddress: destination.contractAddress
      };

      if (deployer.options && deployer.options.events) {
        await deployer.options.events.emit("deployment:linking", eventArgs);
      }
      destination.link(library);
    }
  }
};


/***/ }),

/***/ 284331:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("deployer:sanitizeMessage");

module.exports = message => {
  if (Array.isArray(message)) {
    // for some reason, message is returned as an array padded with many
    // empty arrays - should investigate this further later
    debug("processing the following message - %o", message);
    return message[0];
  }
  return message;
};


/***/ }),

/***/ 812165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderAdapter = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("decoder:adapter");
const stringWhitelist = [
    "latest",
    "pending",
    "genesis",
    "earliest"
];
const formatBlockSpecifier = (block) => {
    if (typeof block === "string" && stringWhitelist.includes(block)) {
        // block is one of 'latest', 'pending', 'earliest', or 'genesis'
        return block === "genesis"
            ? // convert old web3 input format which uses 'genesis'
                "earliest"
            : block;
    }
    else if (typeof block === "string" && !isNaN(parseInt(block))) {
        // block is a string representation of a number
        if (block.startsWith("0x"))
            return block;
        // convert to hex and add '0x' prefix in case block is decimal
        return `0x${parseInt(block).toString(16)}`;
    }
    else if (typeof block === "number") {
        return `0x${block.toString(16)}`;
    }
    else {
        throw new Error("The block specified must be a number or one of the strings 'latest'," +
            "'pending', or 'earliest'.");
    }
};
const formatBlock = (block) => {
    return Object.assign(Object.assign({}, block), { number: parseInt(block.number), size: parseInt(block.size), gasLimit: parseInt(block.gasLimit), gasUsed: parseInt(block.gasUsed), timestamp: parseInt(block.timestamp) });
};
// EIP-1193 providers use `request()` instead of `send()`
// NOTE this provider returns `response.result` already unwrapped
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md
const isEip1193Provider = (provider) => "request" in provider;
/**
 * @hidden
 */
class ProviderAdapter {
    constructor(provider) {
        this.provider = provider;
    }
    sendRequest({ method, params, formatOutput }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider) {
                throw new Error("There is not a valid provider present.");
            }
            let result;
            if (isEip1193Provider(this.provider)) {
                result = yield this.provider.request({ method, params });
            }
            else {
                // HACK MetaMask's injected provider doesn't allow `.send()` with
                // a callback, so prefer `.sendAsync()` if it's defined
                const send = ("sendAsync" in this.provider
                    ? // uses `any` because LegacyProvider type doesn't define sendAsync
                        this.provider.sendAsync
                    : this.provider.send).bind(this.provider);
                // HACK this uses a manual `new Promise` instead of promisify because
                // users reported difficulty running this package in a browser extension
                result = yield new Promise((accept, reject) => send({
                    jsonrpc: "2.0",
                    id: new Date().getTime(),
                    method,
                    params
                }, ((error, response) => {
                    if (error) {
                        return reject(error);
                    }
                    const { result: res } = response;
                    accept(res);
                })));
            }
            if (formatOutput)
                return formatOutput(result);
            return result;
        });
    }
    getCode(address, block //making this one not regularized to support encoder
    ) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockToFetch = formatBlockSpecifier(block);
            return yield this.sendRequest({
                method: "eth_getCode",
                params: [address, blockToFetch]
            });
        });
    }
    getBlockByNumber(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockToFetch = formatBlockSpecifier(block);
            return yield this.sendRequest({
                method: "eth_getBlockByNumber",
                params: [blockToFetch, false],
                formatOutput: formatBlock
            });
        });
    }
    getPastLogs({ address, fromBlock, toBlock }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "eth_getLogs",
                params: [{ fromBlock, toBlock, address }]
            });
        });
    }
    getNetworkId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "net_version",
                params: [],
                formatOutput: result => parseInt(result)
            });
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "eth_blockNumber",
                params: [],
                formatOutput: result => parseInt(result)
            });
        });
    }
    getBalance(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "eth_getBalance",
                params: [address, formatBlockSpecifier(block)],
                formatOutput: result => parseInt(result).toString()
            });
        });
    }
    getTransactionCount(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "eth_getTransactionCount",
                params: [address, formatBlockSpecifier(block)],
                formatOutput: result => parseInt(result).toString()
            });
        });
    }
    getStorageAt(address, position, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sendRequest({
                method: "eth_getStorageAt",
                params: [address, `0x${position.toString(16)}`, formatBlockSpecifier(block)]
            });
        });
    }
}
exports.ProviderAdapter = ProviderAdapter;
//# sourceMappingURL=adapter.js.map

/***/ }),

/***/ 113247:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractInstanceEncoder = exports.ContractEncoder = exports.ProjectEncoder = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("encoder:encoders");
const bignumber_1 = __webpack_require__(539370);
const address_1 = __webpack_require__(89623);
const Codec = __importStar(__webpack_require__(20102));
const Abi = __importStar(__webpack_require__(207651));
const big_js_1 = __importDefault(__webpack_require__(116598));
const web3_utils_1 = __importDefault(__webpack_require__(118269));
const adapter_1 = __webpack_require__(812165);
const Utils = __importStar(__webpack_require__(789916));
const errors_1 = __webpack_require__(500079);
const compile_common_1 = __webpack_require__(529833);
//sorry for untyped imports!
const { default: ENS, getEnsAddress } = __webpack_require__(502402);
const nonIntegerMessage = "Input value was not an integer";
/**
 * The ProjectEncoder class.  Can wrap values; can also encode transactions and
 * resolve overloads if sufficient information is provided.  See below for a
 * method listing.
 * @category Encoder
 */
class ProjectEncoder {
    /**
     * @protected
     */
    constructor(info) {
        this.registryAddress = undefined;
        this.ensCache = {};
        this.contractsAndContexts = [];
        //first, set up the basic info that we need to run
        if (info.userDefinedTypes && info.allocations) {
            debug("internal route!");
            this.userDefinedTypes = info.userDefinedTypes;
            this.allocations = info.allocations;
        }
        else {
            if (!info.compilations) {
                throw new errors_1.NoInternalInfoError();
            }
            this.compilations = info.compilations;
            ({
                definitions: this.referenceDeclarations,
                types: this.userDefinedTypes
            } = Codec.Compilations.Utils.collectUserDefinedTypesAndTaggedOutputs(info.compilations));
            let allocationInfo;
            ({ allocationInfo, contractsAndContexts: this.contractsAndContexts } =
                Codec.AbiData.Allocate.Utils.collectAllocationInfo(info.compilations));
            this.allocations = {};
            //only doing the relevant allocations: abi & calldata
            this.allocations.abi = Codec.AbiData.Allocate.getAbiAllocations(this.userDefinedTypes);
            this.allocations.calldata = Codec.AbiData.Allocate.getCalldataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        }
        this.provider = info.provider || null;
        debug("provider: %o", this.provider);
        if (info.registryAddress !== undefined) {
            this.registryAddress = info.registryAddress;
        }
        debug("registryAddress: %o", this.registryAddress);
        this.networkId = info.networkId || null;
    }
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getUserDefinedTypes() {
        return this.userDefinedTypes;
    }
    /**
     * @protected
     */
    getNetworkId() {
        return this.networkId;
    }
    /**
     * @protected
     */
    getReferenceDeclarations() {
        return this.referenceDeclarations;
    }
    /**
     * @protected
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.provider) {
                debug("provider given!");
                if (this.registryAddress !== undefined) {
                    debug("using custom registry address: %o", this.registryAddress);
                    this.ens = new ENS({
                        provider: this.provider,
                        ensAddress: this.registryAddress
                    });
                }
                else {
                    //if we weren't given a registry address, we use the default one,
                    //but what is that?  We have to look it up.
                    //NOTE: ENS is supposed to do this for us in the constructor,
                    //but due to a bug it doesn't.
                    debug("using default registry address");
                    const networkId = yield new adapter_1.ProviderAdapter(this.provider).getNetworkId();
                    const registryAddress = getEnsAddress(networkId);
                    if (registryAddress) {
                        this.ens = new ENS({
                            provider: this.provider,
                            ensAddress: registryAddress
                        });
                    }
                    else {
                        //there is no default registry on this chain
                        this.ens = null;
                    }
                }
            }
            else {
                debug("no provider given, ens off");
                this.ens = null;
            }
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This is a restricted version of [[wrap]], which only handles elementary
     * types and values (those that can be used as mapping keys in Solidity);
     * it's present here for type convenience.  See the [[wrap]] and
     * [[ContractEncoder.encodeTransaction]] documentation
     * for further information.
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.wrap(dataType, input));
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a given data type and attempts
     * to interpret it as a value of that type.  It will throw a
     * [[TypeMismatchError]] if it cannot do this.
     *
     * For documentation of the accepted forms of input, see
     * [[ContractEncoder.encodeTransaction]].
     *
     * @param dataType The data type that the given value is to be interpreted
     *   as.
     * @param input The value to be interpreted.  This can take a number of
     *   forms depending on the data type, as documented above.
     * @return The interpreted value wrapped as a [[Format.Values.Value|Value]]
     *   object.
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.driveGenerator(Codec.Wrap.wrap(dataType, input, {
                userDefinedTypes: this.userDefinedTypes,
                loose: true
            }));
        });
    }
    /**
     * @protected
     */
    wrapForTransaction(method, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("wrapForTransaction");
            return yield this.driveGenerator(Codec.Wrap.wrapForMethod(method, inputs, {
                userDefinedTypes: this.userDefinedTypes,
                allowOptions: Boolean(options.allowOptions)
            }));
        });
    }
    /**
     * @protected
     */
    resolveAndWrap(methods, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.driveGenerator(Codec.Wrap.resolveAndWrap(methods, inputs, {
                userDefinedTypes: this.userDefinedTypes,
                allowOptions: Boolean(options.allowOptions)
            }));
        });
    }
    driveGenerator(generator) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let next = generator.next();
            while (!next.done) {
                const request = next.value;
                debug("request: %O", request);
                // @ts-ignore: HACK HACK to make typedoc work
                // (the TS is fine with strict null checks on,
                // but typedoc has it turned off, so... :-/ )
                // please remove this ts-ignore once you turn on
                // strict null checks in typedoc
                response = yield this.respond(request);
                debug("response: %O", response);
                next = generator.next(response);
            }
            debug("returning: %O", next.value);
            return next.value;
        });
    }
    respond(request) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (request.kind) {
                case "integer":
                    return this.recognizeInteger(request.input);
                case "decimal":
                    return this.recognizeDecimal(request.input);
                case "address":
                    return yield this.recognizeAddress(request.name);
            }
        });
    }
    /**
     * @protected
     */
    encodeTxNoResolution(method, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("encoding transaction");
            const resolution = yield this.wrapForTransaction(method, inputs, options);
            const data = (Codec.AbiData.Encode.encodeTupleAbiWithSelector(resolution.arguments, Codec.Conversion.toBytes(resolution.method.selector), this.allocations.abi));
            //note that the data option on resolution.options is ignored;
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            let encoded = Object.assign(Object.assign({}, resolution.options), { data: Codec.Conversion.toHexString(data) });
            if (method.abi.type === "constructor") {
                delete encoded.to;
            }
            return encoded;
        });
    }
    /**
     * @protected
     */
    encodeTransaction(methods, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("resolve & encode");
            const resolution = yield this.resolveAndWrap(methods, inputs, options);
            const data = (Codec.AbiData.Encode.encodeTupleAbiWithSelector(resolution.arguments, Codec.Conversion.toBytes(resolution.method.selector), this.allocations.abi));
            //note that the data option on resolution.options is ignored;
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            return {
                tx: Object.assign(Object.assign({}, resolution.options), { data: Codec.Conversion.toHexString(data) }),
                abi: resolution.method.abi
            };
        });
    }
    recognizeInteger(input) {
        if (Utils.isBigNumber(input)) {
            if (input.isInteger()) {
                return {
                    kind: "integer",
                    value: BigInt(input.toFixed())
                };
            }
            else {
                return {
                    kind: "integer",
                    value: null,
                    reason: nonIntegerMessage,
                    partiallyRecognized: true
                };
            }
        }
        else if (Utils.isEthersBigNumber(input)) {
            const asHexString = input.toHexString();
            const asBigInt = asHexString[0] === "-"
                ? -BigInt(asHexString.slice(1))
                : BigInt(asHexString);
            return {
                kind: "integer",
                value: asBigInt
            };
        }
        else if (bignumber_1.FixedNumber.isFixedNumber(input)) {
            //they had to make this one a pain...
            const asString = input.toString();
            //problem: the string might still have trailing ".0" on the end,
            //so let's run it through something that recognizes that (hack?)
            const asBig = new big_js_1.default(asString);
            if (Codec.Conversion.countDecimalPlaces(asBig) === 0) {
                return {
                    kind: "integer",
                    value: BigInt(asBig.toFixed())
                };
            }
            else {
                return {
                    kind: "integer",
                    value: null,
                    reason: nonIntegerMessage,
                    partiallyRecognized: true
                };
            }
        }
        else {
            return {
                kind: "integer",
                value: null
            };
        }
    }
    recognizeDecimal(input) {
        if (Utils.isBigNumber(input)) {
            if (input.isFinite()) {
                return {
                    kind: "decimal",
                    value: new big_js_1.default(input.toFixed())
                };
            }
            else {
                return {
                    kind: "decimal",
                    value: null,
                    reason: "Input was not a finite value",
                    partiallyRecognized: true
                };
            }
        }
        else if (Utils.isEthersBigNumber(input)) {
            //as before, this has to come after
            return {
                kind: "decimal",
                value: new big_js_1.default(input.toString())
            };
        }
        else if (bignumber_1.FixedNumber.isFixedNumber(input)) {
            return {
                kind: "decimal",
                value: new big_js_1.default(input.toString())
            };
        }
        else {
            return {
                kind: "decimal",
                value: null
            };
        }
    }
    recognizeAddress(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let address = null;
            try {
                address = address_1.getAddress(input); //maybe it's an ICAP address?
                return {
                    kind: "address",
                    address
                };
            }
            catch (error) {
                debug("address error: %O", error);
                if (!error) {
                    throw error; //rethrow unepxected errors
                }
                switch (error.reason) {
                    case "bad address checksum":
                        //note: this won't be visible because we've already
                        //checked this for ourselves
                        return {
                            kind: "address",
                            address: null,
                            reason: Codec.Wrap.Messages.checksumFailedMessage,
                            partiallyRecognized: true
                        };
                    case "bad icap checksum":
                        return {
                            kind: "address",
                            address: null,
                            reason: "ICAP address had bad checksum",
                            partiallyRecognized: true
                        };
                    case "invalid address":
                        //in this case, try resolving it as an ENS name
                        const address = yield this.resolveENSName(input);
                        if (address !== null) {
                            return {
                                kind: "address",
                                address
                            };
                        }
                        else {
                            return {
                                kind: "address",
                                address: null,
                                reason: "Input was not recognizable as an address or ENS name"
                            };
                        }
                    default:
                        throw error; //rethrow unexpected errors
                }
            }
        });
    }
    resolveENSName(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ens === null) {
                return null;
            }
            if (input in this.ensCache) {
                return this.ensCache[input];
            }
            let address;
            try {
                address = yield this.ens.name(input).getAddress();
            }
            catch (_a) {
                //Normally I'd rethrow unexpected errors, but given the context here
                //that seems like it might be a problem
                address = null;
            }
            if (address === Codec.Evm.Utils.ZERO_ADDRESS) {
                //ENS returns zero address to indicate "not found"
                address = null;
            }
            this.ensCache[input] = address;
            return address;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract encoder for a given contract in this project.
     * @param artifact The contract the encoder is for.  If you want to
     *   encode contract creation transactions, it must have all of
     *   its libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     */
    forArtifact(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.compilations) {
                throw new errors_1.NoCompilationsForSpawnerError();
            }
            let { compilation, contract } = Codec.Compilations.Utils.findCompilationAndContract(this.compilations, artifact);
            //to be *sure* we've got the right ABI, we trust the input over what was
            //found
            contract = Object.assign(Object.assign({}, contract), { abi: artifact.abi });
            return new ContractEncoder(this, compilation, contract, artifact);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract encoder for a given contract in this project.
     * @param contract The contract the encoder is for.  If you want to
     *   encode contract creation transactions, it must have all of
     *   its libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     */
    forContract(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.forArtifact(contract);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given contract instance.
     * @param artifact The artifact for the contract the encoder is for.  If you
     *   want to encode contract creation transactions, it must have all of its
     *   libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     * @param address The address of the contract instance.
     *   If omitted, but the project encoder has a provider or network ID,
     *   it will be autodetected.  If there is no provider or network ID,
     *   it must be included.
     *
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(artifact, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractEncoder = yield this.forArtifact(artifact);
            return yield contractEncoder.forInstance(address);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given instance of a contract in this
     * project.  Unlike [[forInstance]], this method doesn't require an artifact; it
     * will automatically detect the class of the given contract.  If it's not in
     * the project, or the encoder can't identify it, you'll get an exception.
     * @param address The address of the contract instance to encoder for.
     *   If an invalid address is provided, this method will throw an exception.
     * @param block You can include this argument to specify that this should be
     *   based on the addresses content's at a specific block (if say the contract
     *   has since self-destructed).
     */
    forAddress(address, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            //code duplication warning: this method is basically copypasted
            //from the decoder!
            if (!this.compilations) {
                throw new errors_1.NoCompilationsForSpawnerError();
            }
            if (this.provider === null) {
                throw new errors_1.NoNetworkError();
            }
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            address = web3_utils_1.default.toChecksumAddress(address);
            const deployedBytecode = yield new adapter_1.ProviderAdapter(this.provider).getCode(address, block);
            const contractAndContexts = this.contractsAndContexts.find(({ deployedContext }) => deployedContext &&
                Codec.Contexts.Utils.matchContext(deployedContext, deployedBytecode));
            if (!contractAndContexts) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            const { contract, compilationId } = contractAndContexts;
            const compilation = this.compilations.find(compilation => compilation.id === compilationId);
            if (!compilation) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            //no artifact... hope you don't need to link any bytecode!
            const contractEncoder = new ContractEncoder(this, compilation, contract);
            return yield contractEncoder.forInstance(address);
        });
    }
}
exports.ProjectEncoder = ProjectEncoder;
/**
 * The ContractEncoder class.
 * Can encode transactions, resolve overloads, and wrap values.
 * See below for a method listing.
 * @category Encoder
 */
class ContractEncoder {
    /**
     * @protected
     */
    constructor(projectEncoder, compilation, contract, artifact) {
        this.projectEncoder = projectEncoder;
        this.contract = contract;
        this.abi = Abi.normalize(contract.abi);
        this.artifact = artifact;
        this.compilation = compilation;
        this.contractNode = Codec.Compilations.Utils.getContractNode(this.contract, this.compilation);
        //set up constructor binary w/resolved link references
        const networkId = this.projectEncoder.getNetworkId();
        const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode); //sorry, codec still uses legacy, to be changed in future
        const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
        //determine linked bytecode -- we'll determine it ourself rather than
        //using contract.binary
        const links = networkId !== null
            ? (((artifact || { networks: {} }).networks || {})[networkId] || {
                links: {}
            }).links || {}
            : {};
        this.constructorBinary = Utils.link(bytecode, links);
        //now, set up context hashes
        if (bytecode && bytecode !== "0x") {
            this.constructorContextHash = Codec.Conversion.toHexString(Codec.Evm.Utils.keccak256({
                type: "string",
                value: bytecode //has link references unresolved
            }));
        }
        if (deployedBytecode && deployedBytecode !== "0x") {
            this.deployedContextHash = Codec.Conversion.toHexString(Codec.Evm.Utils.keccak256({
                type: "string",
                value: deployedBytecode //has link references unresolved
            }));
        }
        else {
            //if there's no bytecode, allocate input data manually
            const compiler = this.compilation.compiler || this.contract.compiler;
            this.noBytecodeAllocations = Object.values(Codec.AbiData.Allocate.getCalldataAllocations([
                {
                    abi: this.abi,
                    compilationId: this.compilation.id,
                    //@ts-ignore sorry this is what happens when you mix strictNullChecks on with off
                    compiler,
                    contractNode: this.contractNode,
                    deployedContext: Codec.Contexts.Utils.makeContext(Object.assign(Object.assign({}, this.contract), { deployedBytecode: "0x" //only time this should ever appear in a context!
                     }), this.contractNode, this.compilation)
                }
            ], this.projectEncoder.getReferenceDeclarations(), this.projectEncoder.getUserDefinedTypes(), this.projectEncoder.getAllocations().abi).functionAllocations)[0];
        }
    }
    /**
     * Just used for testing, currently
     * @protected
     */
    getProjectEncoder() {
        return this.projectEncoder;
    }
    /**
     * See [[ProjectEncoder.wrapElementaryValue]].
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectEncoder.wrapElementaryValue(dataType, input);
        });
    }
    /**
     * See [[ProjectEncoder.wrap]].
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectEncoder.wrap(dataType, input);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a transaction.  It will throw
     * a [[TypeMismatchError]] if it cannot do this.  This method requires
     * that the precise function be specified; it does not perofrm overload
     * resolution.  See [[encodeTransaction]] for documentation of the accepted
     * forms of input.
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.
     *
     * Note that use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * @param method ABI entry for the transaction being prepared.  Must be one
     *   associated with this contract.  Can be for either a function or a
     *   constructor.
     * @param inputs An array of the inputs to the transaction.  May include a
     *   transaction options argument on the end if the `allowOptions` flag is
     *   set.
     * @param options Contains options to control the operation of this method.
     * @return The interpretation of the input, as a
     *   [[Resolution]] object.
     */
    wrapForTransaction(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = this.getMethod(abi);
            return yield this.projectEncoder.wrapForTransaction(method, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method attempts to perform overload resolution given user input
     * to one of several possible methods.  If the given input matches more than
     * one of these methods, it will attempt to select the best match.  See
     * [[encodeTransaction]] for documentation of the acccepted input forms.
     *
     * If it is not possible for the given input to match any of the given methods,
     * either a [[TypeMismatchError]] or a
     * [[NoOverloadsMatchedError]] will be
     * thrown.  If more than one overload matches but none can be considered the
     * unique best, you will get a
     * [[NoUniqueBestOverloadError]].
     * If due to inputting a nonexistent function name there are no overloads to
     * check, you will get a [[NoFunctionByThatNameError]].
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.
     *
     * Note that use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * **Overload resolution system**
     *
     * If it is necessary to perform overload resolution by type rather than
     * simply by length, the encoder will select among the overloads that
     * could work the one it considers to be the best match.  To be the best
     * match, it must be a best match for each argument.  An overload is
     * a best match for a given argument if the type it would assign that
     * argument is highest-priority among all types it could assign that
     * argument (selected from overloads that match overall).
     *
     * Note that when doing this the match checker will be somewhat stricter than
     * usual; inputs for structs/tuples will not be allowed to contain extra
     * keys, numeric input (including odd-length hex strings)
     * will not be accepted for dynamic-length bytestrings,
     * and if a value is given as a [[Format.Values.Value|Value]], it
     * will only match its specific type, rather than being allowed to match
     * other types as usual (unless it is itself wrapped in a type/value pair).
     *
     * The overall order of priority of types is as follows:
     * 1. transaction options
     * 2. arrays
     * 3. structs and tuples
     * 4. addresses and contracts
     * 5. bytestrings (`bytesN` and `bytes`)
     * 6. external function pointers
     * 7. numeric types
     * 8. `enum`s
     * 9. `string`
     * 10. `bool`
     *
     * (Note that if the encoder does not know that a certain argument is
     * supposed to be an enum, it will of course just be treated as the
     * underlying numeric type.)
     *
     * Moreover, within each category there is a priority ordering (which is
     * not always total).  Specifically:
     * * For arrays, if `S` has priority over `T`, then `S[]` has priority
     *   over `T[]`, and `S[n]` has priority over `T[n]`.  Moreover, `S[n]`
     *   has priority over `S[]` and so also over `T[]`.
     * * Structs and tuples mostly act the same as the overall arguments list; for
     *   one such type `S` to have priority over another type `T`, each
     *   member type of `S` must have priority over the corresponding member type
     *   of `T` (correspondence being determined by the order of the members).
     *   However, if the two types `S` and `T` also have exactly the same
     *   component names (and each has all of its components named), then
     *   this will also be checked with correspondence by name instead of
     *   position, and `S` will only be considered more specific than `T` if
     *   both checks pass.
     * * `bytesN` has priority over `bytesM` if `N<=M`, and has priority over
     *   `bytes`
     * * A numeric type `S` has priority over a numeric type `T` if the values
     *   representable by `S` are a subset of those representable by `T`.
     *
     * If you are not getting the overload you want, you can use explicit
     * type-value input as discussed in the documentation for
     * [[encodeTransaction]], or you can skip overload resolution and explicitly
     * select an overload by other means.  For enums you may also specify the
     * enum type as documented in [[encodeTransaction]].
     *
     * @param abisOrName The ABI entries for the overloads, or the name of the
     *   function.  Note that if you are inputting ABI entries, they must be
     *   for functions, not constructors.  The entries must be ones associated
     *   with this contract.
     * @param inputs An array of the inputs to the transaction.  May include a
     *   transaction options argument on the end if the `allowOptions` flag is
     *   set.
     * @param options Contains options to control the operation of this method.
     * @return The interpretation of the input and the resolved method, as a
     *   [[Resolution]] object.
     */
    resolveAndWrap(abisOrName, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const abis = this.getAbis(abisOrName);
            const methods = abis.map(abi => this.getMethod(abi));
            //note we can't just write abis.map(this.getMethod)
            //because this would be undefined inside of it... I could
            //write abis.map(this.getMethod.bind(this)), but I find the
            //arrow way to be more readable
            return yield this.projectEncoder.resolveAndWrap(methods, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method is similar to [[encodeTransaction]], except that it does not
     * perform overload resolution; it takes a single ABI entry, rather than a
     * list of them or a function name.  Note that unlike [[encodeTransaction]],
     * it can also encode contract creation transactions.
     *
     * Because this method does not perform overload resolution, it only returns
     * the resulting transaction options (including the encoded `data`), and does
     * not bother returning the ABI used (as this was user-supplied.)
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.  Any non-`data` options not specified in such a transaction
     * options argument will be simply omitted; it you want some options to have
     * defaults, it is up to the you to set these options as appropriate
     * afterwards.
     *
     * If the transaction options parameter has a `data` option, this option will
     * be recognized but ignored.  Similarly, when encoding a contract creation,
     * the `to` option will also be ignored.
     *
     * See [[encodeTransaction]] for documentation of most of the inputs.
     *
     * @param abi The ABI entry for the transaction to encode for.  Note it must
     *   be one for this contract.  May be for either a function or a constructor.
     * @return The resulting transaction options, including the encoded `data`.
     */
    encodeTxNoResolution(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = this.getMethod(abi);
            return yield this.projectEncoder.encodeTxNoResolution(method, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a given set of contract methods,
     * attempts to interpret it as valid input for one of them, and then
     * encodes the result.  (That is to say, it performs overload resolution,
     * then encodes.)  Note that this method cannot be used to encode contract
     * creations; use [[encodeTxNoResolution]] for that.
     *
     * If this method cannot match the user input to any of the possible
     * overloads, it will throw a [[TypeMismatchError]] or a
     * [[NoOverloadsMatchedError]].  If more than one overload matches but none
     * can be considered the unique best, you will get a
     * [[NoUniqueBestOverloadError]].  If due to inputting a nonexistent function
     * name there are no overloads to check, you will get a
     * [[NoFunctionByThatNameError]].  See below for a full list of the accepted
     * forms of input, and see [[resolveAndWrap]] for full documentation of the
     * overload resolution system.
     *
     * Be aware that overload resolution may not always be fully reliable; if you
     * want to be absolutely certain that you get the right overload, you can use
     * [[encodeTxNoResolution]], which does not perform overload resolution, but
     * requires you to specify exactly which overload you mean.  However, you can
     * also adjust your input to this function to get the overload you want; see
     * below about `{ type: ..., value: ... }` input and enum string input for
     * details.
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.  Any non-`data` options not specified in such a transaction
     * options argument will be simply omitted; it you want some options to have
     * defaults, it is up to the you to set these options as appropriate
     * afterwards.  Also, if the transaction options parameter has a `data`
     * option, this option will be recognized but ignored.
     *
     * Use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * **Accepted forms of input**
     *
     * The `input` argument may come in a number of forms, depending on the
     * target data type.  A list of the specific inputs accepted for each type is
     * below.  However first we must note a few generic forms that inputs are
     * accepted in.
     *
     * Inputs may be given as an object of the form `{ type: ..., value: ... }`
     * (additional fields not allowed), where `type` is a string describing the
     * type, and `value` is anything that would be accepted for that type (other
     * than another type/value object).  This form of input is not very useful
     * with *this* method, but it is useful when performing overload resolution
     * (see [[resolveAndWrap]]) to restrict the overloads that will be selected
     * from.  Note that for arrays, `type` should simply be `"array"`; for
     * structs and tuples, `"struct"` or `"tuple"`; for addresses and contracts,
     * `"address"` or `"contract"`; for external functions, `"function"`; for
     * transaction options, `"options"`; and for enums, it can be either `"enum"`
     * (or the underlying uint type).  For other Solidity types, it should be the
     * name of the type; note that `"uint"`, `"int"`, `"fixed"`, `"ufixed"`, and
     * `"byte"` are accepted.  Vyper's `"decimal"` type is also accepted.
     * Also, user-defined value types use exactly the same
     * `type` field as the underlying type; this input format does not distinguish
     * between them and the underlying type.
     *
     * Note that input in the form of a [[Format.Values.Value|Value]] is
     * accepted, so long as the type is appropriate, but error results are
     * typically not accepted (exceptions are discussed below).
     *
     * Now then, the list of accepted inputs by type, excluding the above:
     *
     * **Strings**: The input may be given as string (or `String`); note that
     * strings with invalid UTF-16 will not be accepted.  It may also be given as a
     * `Uint8Array` (or anything that mimics one; see below about bytestrings), which
     * will be treated as UTF-8; note that invalid UTF-8 is allowed in this format.
     * Strings may also be given as a [[Format.Values.StringValue|StringValue]].
     *
     * **Integer types**: Input for integer types may take a variety of forms.
     * The input may be a `number` (or `Number`); note that if so it must be a
     * safe integer.  For larger integers, you must use other forms of input.
     * For instance, the input may be a `BigInt`.  The input may also be one
     * of several recognized big number classes:
     *   * [`BN`](https://github.com/indutny/bn.js)
     *   * [`Big`](https://github.com/MikeMcl/Big.js)
     *   * MikeMcl's [`BigNumber`](https://github.com/MikeMcl/bignumber.js)
     *   * Ethers's [`BigNumber` or `FixedNumber`](https://www.npmjs.com/package/@ethersproject/bignumber)
     * Of course, any numeric input, no matter the format, must be integral.
     * Input may also take the form of a numeric string (or `String`).
     * The string may be decimal, but it may also be hexadecimal with `"0x"`
     * prefix, octal with `"0o"` prefix, or binary with `"0xb"` prefix.
     * You can also use a negated hexadecimal, octal, or binary string to
     * represent a negative number.  Whitespace before or after the number is OK,
     * and you may use underscores to separate groups of digits (in any base).
     * For decimal strings, scientific notation (e.g. `1.1e4`) is also accepted.
     * It is also possible to affix one of the units `"wei"`, `"gwei"`,
     * `"shannon"`, `"finney"`, `"szabo"`, or `"ether"` (these are case-insensitive)
     * onto a decimal numeric string (you may include space inbetween the
     * quantity and the unit) to act as a multiplier (where here the
     * assumption is that 1 wei means the number 1).  You may also use a
     * unit by itself, with no specified quantity, to mean 1 of that unit.
     * (E.g., an input of `"wei"` will be interpreted as 1.)  Note that it's OK
     * if the quantity before the unit is not itself an integer, so long as the
     * overall resulting quantity is an integer; e.g., "1.1 gwei" is legal integer
     * input.  In addition to giving the input in any of these obviously numeric
     * forms, the input may also be given a a `Uint8Array` or anything that
     * mimics one (see above about bytestrings); in this case the input will
     * be interpreted as the big-endian byte representation of an unsigned
     * integer (or in other words, it will be interpreted as base 256).
     * Negative numbers cannot be represented in this way.
     * Finally, the input may be given as a
     * [[Format.Values.UintValue|UintValue]],
     * [[Format.Values.IntValue|IntValue]],
     * [[Format.Values.UfixedValue|UfixedValue]],
     * [[Format.Values.FixedValue|FixedValue]],
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of one of these,
     * or [[Format.Values.EnumValue|EnumValue]]; the type is not required to
     * match unless strict checking is on (see [[resolveAndWrap]]), in which case
     * the type must match exactly.  In addition, the input may also be a
     * [[Format.Errors.EnumErrorResult|EnumErrorResult]] so long as
     * the error is a
     * [[Format.Errors.EnumOutOfRangeError|EnumOutOfRangeError]];
     * other types of error results are not accepted.
     *
     * **Enums**: Enums accept all the same forms of input as integer types.
     * However, if the encoder is aware that a particular argument or field is in
     * fact an enum and not just an integer, it accepts one additional form of
     * input; the input may be a string (or `String`) containing the name of the
     * enumerated option.  So, for instance, given the following Solidity code:
     * ```solidity
     * contract MyContract {
     *   enum Ternary {
     *     No, Yes, Maybe
     *   }
     * }
     * ```
     * then `"Yes"` would be a valid input for an enum of type
     * `MyContract.Ternary`.  Moreover, `"Ternary.Yes"` and
     * `"MyContract.Ternary.Yes"` would also work; these latter forms will only
     * match enum types with the appropriate name and optionally defining
     * contract, so you can use these to restrict matching for overload
     * resolution, much like type/value input.  Note these forms do not require
     * the enum to be defined inside of a contract; those defined outside of
     * contracts are supported too, so long as the encoder was initialized to
     * know about them.
     *
     * **Bytestrings**: Bytestrings can be given in several forms.  Note that for
     * all forms of input, if the specified type is `bytesN`, it is OK if the
     * length of the input is shorter than N bytes; it will automatically be
     * right-padded with zero bytes in this case.  (The exception is if the input
     * is a [[Format.Values.BytesValue|BytesValue]] and strict checking is
     * on; see [[resolveAndWrap]].)  Bytestrings may be given as `"0x"`-prefixed
     * even-length hex strings (a `String` may be used in place of a string);
     * underscores may be used to separate groups of hex digits.
     * Bytestrings may also be given as a `Uint8Array`, or anything resembling a
     * `Uint8Array` -- any object with a `length` field which is a `number`, and
     * which has fields from `0` to `length-1` all `number`s from 0 to 255, will
     * be accepted.  Input may also be given as a
     * [[Format.Values.BytesValue|BytesValue]] or a
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]]
     * on top of one; the specific type does not
     * have to match unless strict checking is on.  In addition, a bytestring may be
     * given as an object with just the fields `text` and `encoding`; in this
     * case, `text` should be a string (it must not have invalid UTF-16) and
     * `encoding` an encoding to encode it as.  The only supported encoding
     * currently is `"utf8"`.  Finally, for compatibility with ethers, when
     * strict checking is off (see [[resolveAndWrap]]), a
     * bytestring of dynamic length (`bytes`) may have its input given numerically.
     * The valid formats for this are the same as for integer types, except that
     * wrapped numeric values are not accepted, numeric strings may not use
     * scientific notation or units, and the number may not be negative.  For
     * compatibility reasons, if the number zero is given as input in this way,
     * it will be treated as a bytestring consisting of a single zero byte, rather
     * than the empty bytestring.  Warning: an odd-length hex string will be
     * treated as numeric input!  (Effectively, it will be padded on the left
     * with a zero hex digit.)
     *
     * **Addresses and contracts**: Input may be given as a hex string
     * representing 20 bytes, with capitalization according to the Ethereum
     * address checksum.  The `"0x"` prefix is optional.  If the hex string
     * is all lowercase or all uppercase, however, then the checksum check will
     * be skipped, and the input accepted regardless.  Input may also be given
     * as an ICAP address; again, the checksum must be correct.  Finally, if ENS
     * resolution has been configured, input may be given as an ENS name.
     * All of these may also be given as `String`s instead of strings.
     * Input may also be given as an object with an `address` field, although the
     * contents of that address field must be a `"0x"`-prefixed hex string (not
     * `String`), and not any other address format.  Input may also be given
     * as a [[Format.Values.AddressValue|AddressValue]],
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of such, or
     * [[Format.Values.ContractValue|ContractValue]]; the specific type
     * does not matter.
     *
     * **Booleans**: Almost any input is accepted (as long as it's not type/value
     * input for a different type), but how it is interpreted depends on the
     * input.  A boolean will be interpreted in the obvious way, and a `Boolean`
     * will be unwrapped.  A string will be considered true unless it is falsy or
     * is equal (ignoring case) to the string `"false"`.  A `String` will be
     * considered true if and only if the underlying string is.  A number will be
     * considered true so long as it is truthy, and a `Number` will be considered
     * true if and only if the underlying number is.  A
     * [[Format.Values.BoolValue|BoolValue]], or
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of such,
     * will be considered true so
     * long as it represents a true value.  Moreover, two types of
     * [[Format.Errors.BoolErrorResult|BoolErrorResult]] also count as
     * true: Those where the error is a
     * [[Format.Errors.BoolOutOfRangeError|BoolOutOfRangeError]] and
     * those where the error is a
     * [[Format.Errors.BoolPaddingError|BoolPaddingError]].  This also applies to
     * a [[Format.Errors.UserDefinedTypeValue|UserDefinedTypeErrors]] on top of one
     * of these.  All other
     * error results, and all [[Format.Values.Value|Values]] that are not
     * [[Format.Values.BoolValue|BoolValues]] or a
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of one,
     * will be rejected.  All other inputs will be considered true so long as
     * they are truthy.
     *
     * **Decimal fixed-point types**: Input for fixed-point decimal types is
     * similar to input for integer types.  The differences are as follows:
     *   * Units are not accepted in numeric strings (or `String`s).
     *   * Hexadecimal, octal, and binary strings (or `String`s) are not
     *     accepted.
     *   * `Uint8Array`s, or objects that mimic them, are not accepted.
     *   * Numeric values do not have to be integral.
     * Note that if the input is a `number` (or `Number`) or MikeMcl
     * [BigNumber](https://github.com/MikeMcl/bignumber.js), it must be a finite
     * value.  Also, the number of decimal places in the input may not exceed the
     * number of decimal places allowed in the type.  Finally, just as integer
     * types do not allow `number`s (or `Number`s) that are unsafe integers as
     * input, decimal types will not accept a `number` (or `Number`) as input if
     * that `number` is outside the safe range for that type, i.e., it is large
     * enough that there may be loss of precision.  (This means that `1` is not
     * valid input for a `fixed128x18`!)  Using other, safer, forms of input is
     * encouraged.
     *
     * **User-defined value types**: These take exactly the same input as the
     * underlying type.
     *
     * **Arrays**: The input may be an array, or it may be a
     * [[Format.Values.ArrayValue|ArrayValue]].  In the latter case,
     * whether it is static-length or dynamic-length does not need to match
     * (unless strict checking is on, see [[resolveAndWrap]]).
     *
     * **Structs and tuples**: The input can be given either as an array or as an
     * object.  If given as an array, the elements should be the members of the
     * struct/tuple, in order.  If given as an object, it should be keyed by the
     * struct or tuple's field names; if any of the elements of the tuple are
     * unnamed, then input cannot be given as an object.  Additional keys are
     * also allowed unless strict checking is on.  Input may also be given as a
     * [[Format.Values.StructValue|StructValue]] or
     * [[Format.Values.TupleValue|TupleValue]]; the specific type does not
     * matter.
     *
     * **External function pointers**: These may be given as an object with fields
     * `address` and `selector` (additional fields are allowed); the `address`
     * field may be anything that would be recognized as an address (see above),
     * and the `selector` field may be anything that would be recgonized as a
     * `bytes4` (see above).  Alternatively, this may be given as a bytestring
     * (even length `"0x"`-prefixed hex string or `String`) of 24 bytes,
     * specifying the address followed by the selector; in this case, the address
     * does not need to be checksummed.  Finally, input may of course also be
     * given as a
     * [[Format.Values.FunctionExternalValue|FunctionExternalValue]];
     * its more specific type does not matter.
     *
     * * Transaction options: These are given as an object with fields for the
     * desired options (you can leave options out or have them be `undefined` and
     * they'll be ignored).  Note that, in order to maintain compatibility with
     * older versions of Truffle, additional keys are accepted, but there must be
     * at least one key that belongs in a transaction options object.  Note that
     * if any field exists, and is not `undefined`, but the value of that field
     * cannot be interpreted as input of the appropriate type, the input will be
     * rejected.  Otherwise, inputs for each field can be anything that the
     * encoder will understand for this field.  Accepted fields are:
     *   * `gas`, `gasPrice`, `value`, `nonce`: These take integer input
     *     (see above).
     *   * `from`, `to`: These take address input (see above).
     *   * `data`: This takes `bytes` input (see above).
     *   * `overwrite`: This takes boolean input (see above).
     *   * `type`: This takes integer input, which must be in the range from
     *     0 to `0xbf`.
     *   * `accessList`: This takes input as if for an array of type `AccessListForAddress[]`,
     *      if `AccessListForAddress` were a struct with two fields, `address` and `storageKeys`,
     *      with `address` being an `address` and `storageKeys` being of type `uint256[]`.
     *      Yes, this means storage keys may be given numerically; it also means that if a
     *      storage key is given as a hex string representing less than 32 bytes, it will be
     *      padded on the left, rather than on the right.
     *   * `privateFor`: This one is a special case, and requires a specific
     *     form of input.  Input must be an array of base64-encoded
     *     bytestrings (as strings or `String`s), each with a decoded length of
     *     32 bytes.
     * In addition, input may also be given as a
     * [[Format.Values.OptionsValue|OptionsValue]].
     *
     * @param abisOrName The ABI entries for the overloads, or the name of the
     *   function.  Note that if you are inputting ABI entries, they must be
     *   for functions, not constructors.  The entries must be ones associated
     *   with this contract.
     * @param input The value to be interpreted.  This can take a number of
     *   forms depending on the data type, as documented above.
     * @return An object with a `tx` field, holding the transaction options,
     *   including the encoded `data`, and an `abi` field, indicating which
     *   ABI entry was used for encoding.
     */
    encodeTransaction(abisOrName, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const abis = this.getAbis(abisOrName);
            const methods = abis.map(abi => this.getMethod(abi));
            //note we can't just write abis.map(this.getMethod)
            //because this would be undefined inside of it... I could
            //write abis.map(this.getMethod.bind(this)), but I find the
            //arrow way to be more readable
            return yield this.projectEncoder.encodeTransaction(methods, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given instance of the
     * contract this encoder is for.
     * @param address The address of the contract instance.
     *   If omitted, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (address === undefined) {
                const networkId = this.projectEncoder.getNetworkId();
                if (networkId === null) {
                    throw new errors_1.NoNetworkError();
                }
                address = ((this.artifact || { networks: {} }).networks || {})[networkId]
                    .address;
                if (address === undefined) {
                    throw new errors_1.ContractNotDeployedError(this.contract.contractName, networkId);
                }
            }
            return new ContractInstanceEncoder(this, address);
        });
    }
    getAbis(abisOrName) {
        const abis = typeof abisOrName === "string"
            ? this.abi.filter((abi) => abi.type === "function" && abi.name === abisOrName)
            : abisOrName;
        if (typeof abisOrName === "string" && abis.length === 0) {
            //we don't throw this if the input was an empty list of ABIs
            //rather than a name... the user knew what they were doing if they
            //did that :P
            throw new errors_1.NoFunctionByThatNameError(abisOrName, this.contract.contractName);
        }
        return abis;
    }
    getMethod(abi) {
        abi = Abi.normalizeEntry(abi); //just to be absolutely certain!
        const allocations = this.projectEncoder.getAllocations();
        debug("got allocations");
        switch (abi.type) {
            case "constructor": {
                debug("constructor binary: %s", this.constructorBinary);
                //first check that we have constructor binary, and that it's all linked
                if (!this.constructorBinary || this.constructorBinary === "0x") {
                    throw new errors_1.NoBytecodeError(this.contract.contractName);
                }
                else if (!this.constructorBinary.match(/^0x([0-9a-fA-F]{2})+$/)) {
                    throw new errors_1.UnlinkedContractError(this.contract.contractName, this.artifact ? this.artifact.bytecode : undefined);
                }
                //otherwise, we're good to go!
                const allocation = 
                //@ts-ignore: We set this up and checked this earlier
                allocations.calldata.constructorAllocations[this.constructorContextHash].input;
                const inputs = allocation.arguments.map(input => ({ type: input.type, name: input.name || undefined }) //convert "" to undefined
                );
                return {
                    selector: this.constructorBinary,
                    inputs,
                    abi
                };
            }
            case "function": {
                const selector = Codec.AbiData.Utils.abiSelector(abi);
                const allocation = this
                    .deployedContextHash
                    ? //@ts-ignore: This is set up earlier
                        allocations.calldata.functionAllocations[this.deployedContextHash][selector].input
                    : this.noBytecodeAllocations[selector].input;
                const inputs = allocation.arguments.map(input => ({ type: input.type, name: input.name || undefined }) //convert "" to undefined
                );
                return {
                    name: abi.name,
                    selector,
                    inputs,
                    abi
                };
            }
        }
    }
}
exports.ContractEncoder = ContractEncoder;
/**
 * The ContractInstanceEncoder class.
 * Can encode transactions, resolve overloads, and wrap values.
 * Differs from the [[ContractEncoder]] only in that it carries
 * a `to` address for non-constructor transactions.
 * See below for a method listing.
 * @category Encoder
 */
class ContractInstanceEncoder {
    /**
     * @protected
     */
    constructor(contractEncoder, toAddress) {
        this.contractEncoder = contractEncoder;
        if (!web3_utils_1.default.isAddress(toAddress)) {
            throw new errors_1.InvalidAddressError(toAddress);
        }
        this.toAddress = web3_utils_1.default.toChecksumAddress(toAddress);
    }
    /**
     * See [[ProjectEncoder.wrapElementaryValue]].
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractEncoder.wrapElementaryValue(dataType, input);
        });
    }
    /**
     * See [[ProjectEncoder.wrap]].
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractEncoder.wrap(dataType, input);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.wrapForTransaction]],
     * except that, when preparing a function transaction, the `to` option is
     * automatically set to this contract instance's address.  If an explicit
     * `to` address is passed as a transaction option, it will be recognized
     * but ignored.
     */
    wrapForTransaction(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolution = yield this.contractEncoder.wrapForTransaction(abi, inputs, options);
            if (!resolution.options.to && abi.type === "function") {
                resolution.options.to = this.toAddress;
            }
            return resolution;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.resolveAndWrap]],
     * except that the `to` option is automatically set to this contract
     * instance's address.  If an explicit `to` address is passed as a
     * transaction option, it will be recognized but ignored.
     */
    resolveAndWrap(abis, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolution = yield this.contractEncoder.resolveAndWrap(abis, inputs, options);
            resolution.options.to = this.toAddress;
            return resolution;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.encodeTxNoResolution]],
     * except that, when preparing a function transaction, the `to` option is
     * automatically set to this contract instance's address.  If an explicit
     * `to` address is passed as a transaction option, it will be recognized
     * but ignored.
     */
    encodeTxNoResolution(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this.contractEncoder.encodeTxNoResolution(abi, inputs, options);
            //note that the to options is simply overridden
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            if (abi.type === "function") {
                encoded.to = this.toAddress;
            }
            else if (abi.type === "constructor") {
                delete encoded.to;
            }
            return encoded;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.encodeTransaction]],
     * except that the `to` option is automatically set to this contract
     * instance's address.  If an explicit `to` address is passed as a
     * transaction option, it will be recognized but ignored.
     */
    encodeTransaction(abisOrName, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this.contractEncoder.encodeTransaction(abisOrName, inputs, options);
            //note that the to options is simply overridden
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            encoded.tx.to = this.toAddress;
            return encoded;
        });
    }
}
exports.ContractInstanceEncoder = ContractInstanceEncoder;
//# sourceMappingURL=encoders.js.map

/***/ }),

/***/ 500079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractNotFoundError = exports.NoNetworkError = exports.NoBytecodeError = exports.ContractNotDeployedError = exports.UnlinkedContractError = exports.InvalidAddressError = exports.NoFunctionByThatNameError = exports.NoCompilationsForSpawnerError = exports.NoInternalInfoError = void 0;
/**
 * @category Exception
 * @protected
 */
class NoInternalInfoError extends Error {
    constructor() {
        super("No compilations provided, but userDefinedTypes or allocations is missing");
        this.name = "NoInternalInfoError";
    }
}
exports.NoInternalInfoError = NoInternalInfoError;
/**
 * @category Exception
 * @protected
 */
class NoCompilationsForSpawnerError extends Error {
    constructor() {
        super("Contract decoders cannot be spawned without compilations info");
        this.name = "NoCompilationsForSpawnerError";
    }
}
exports.NoCompilationsForSpawnerError = NoCompilationsForSpawnerError;
/**
 * @category Exception
 * @protected
 */
class NoFunctionByThatNameError extends Error {
    constructor(functionName, contractName) {
        const message = contractName
            ? `Contract ${contractName} has no function named ${functionName}`
            : `This contract has no function named ${functionName}`;
        super(message);
        this.functionName = functionName;
        this.contractName = contractName;
        this.name = "NoFunctionByThatNameError";
    }
}
exports.NoFunctionByThatNameError = NoFunctionByThatNameError;
//warning: copypasted from @truffle/decoder!
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance encoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
class InvalidAddressError extends Error {
    constructor(address) {
        super(`Invalid address ${address}`);
        this.address = address;
        this.name = "InvalidAddressError";
    }
}
exports.InvalidAddressError = InvalidAddressError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that has not had all of its libraries linked.
 * @category Exception
 */
class UnlinkedContractError extends Error {
    constructor(contractName, bytecode) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has not had all its libraries linked`);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.name = "UnlinkedContractError";
    }
}
exports.UnlinkedContractError = UnlinkedContractError;
/**
 * This error indicates that you attempted to use address autodetection
 * for a contract that isn't deployed to the current network.
 * @category Exception
 */
class ContractNotDeployedError extends Error {
    constructor(contractName, networkId) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has not been deployed to network ${networkId} with deployer; address must be given explicitly`);
        this.contractName = contractName;
        this.name = "ContractNotDeployedError";
    }
}
exports.ContractNotDeployedError = ContractNotDeployedError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that lacks constructor bytecode.
 * @category Exception
 */
class NoBytecodeError extends Error {
    constructor(contractName) {
        const nameString = contractName !== undefined
            ? contractName + " "
            : "";
        super(`Contract ${nameString}has missing or empty constructor bytecode`);
        this.contractName = contractName;
        this.name = "NoBytecodeError";
    }
}
exports.NoBytecodeError = NoBytecodeError;
/**
 * This error indicates that the user attempted to do something that
 * requires a network ID (e.g.: autodetect an address for a deployed
 * contract) when no network ID or provider was set.
 * @category Exception
 */
class NoNetworkError extends Error {
    constructor() {
        super("This operation requires a provider or network ID.");
        this.name = "NoNetworkError";
    }
}
exports.NoNetworkError = NoNetworkError;
/**
 * This error indicates that the contract you are attempting to create an
 * encoder for does not appear in the project info.
 * @category Exception
 */
class ContractNotFoundError extends Error {
    constructor(contractName, bytecode, deployedBytecode, address) {
        let message;
        if (contractName) {
            message = `Contract ${contractName} could not be found in the project information`;
        }
        else if (address) {
            message = `Contract at ${address} could not be found in the project information`;
        }
        else {
            message = `Contract could not be found in the project information`;
        }
        super(message);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.deployedBytecode = deployedBytecode;
        this.name = "ContractNotFoundError";
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 615967:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * # Truffle Encoder
 *
 * This module provides an interface for recognizing JavaScript user input of
 * Solidity values, encoding those values for use in a transaction, and performing
 * overload resolution based on those values to determine which Solidity method to
 * encode for.
 *
 * The interface is split into three classes: The project encoder, the contract
 * encoder, and the contract instance encoder.  The project encoder is associated
 * to the project as a whole; it can recognize user input, encode transactions,
 * and resolve overloads, although the interface for the latter two is somewhat
 * inconvenient.  The contract encoder is associated to a specific contract class.
 * It is similar to the project encoder, but presents an easier-to-use interface
 * for transaction encoding and overload resolution, so long as one is dealing
 * with methods of the specified class.  The contract instance encoder is
 * associated to a specific contract instance; it is like the contract encoder,
 * but is associated to a specific address, allowing the `to` option in
 * transactions to be populated automatically.
 *
 * ## Usage
 *
 * ### Initialization
 *
 * Create a encoder with one of the various constructor functions.
 *
 * For a project encoder, use the [[forProject|`forProject`]] function.
 *
 * For a contract encoder, use the [[forArtifact|`forArtifact`]] or
 * [[forContract|`forContract`]] function.
 *
 * For a contract instance encoder, use one of the following:
 * * [[forDeployedArtifact|`forDeployedArtifact`]]
 * * [[forDeployedContract|`forDeployedContract`]]
 * * [[forArtifactAt|`forArtifactAt`]]
 * * [[forContractAt|`forContractAt`]]
 * * [[forContractInstance|`forContractInstance`]]
 *
 * See the documentation of these functions for details, or below for usage
 * examples.
 *
 * All of these functions take a final argument in which information about the
 * project is specified; currently only a few methods for specifying project
 * information are allowed, but more are planned.
 *
 * One can also spawn encoders from other encoders by supplying additional
 * information.  See the documentation for the individual encoder classes for a
 * method listing.
 *
 * ### Encoder methods
 *
 * See the documentation for the individual encoder classes for a method listing.
 *
 * ### Wrapped format information
 *
 * When using the various "wrap" functions, values will be wrapped in
 * machine-readable [[Format.Values.Value]] objects containing individual wrapped
 * values.  (This is the same format that `@truffle/decoder` produces output in.)
 * See the [[Format|format documentation]] for an overview and complete module
 * listing.
 *
 * ### Use of project information and encoding of enums
 *
 * The encoder can do purely ABI-based encoding, like other encoders; however it
 * has the capability to use project information to do more.
 *
 * The most significant use of this is that if further project information is
 * present, this allows for enums to be entered as strings with the name of
 * the option, rather than having to be entered via the underlying number.
 * See the documentation of [[ProjectEncoder.wrap]] for more.
 *
 * Similarly, if project information is present, the encoder will also throw an
 * error if you attempt to put an out-of-range value into an enum type, and
 * refuse to consider overloads that would result in this during overload
 * resolution.  If project information is absent, the encoder will be unable to
 * recognize any error in these situations.
 *
 * ### ENS resolution
 *
 * The encoder supports ENS resolution for address and contract types if
 * initialized to support such.  See the documentation of the [[EncoderSettings]]
 * and [[EnsSettings]] types for more.
 *
 * ### Basic usage examples
 *
 * These usage examples are for a project with two contracts, `Contract1` and
 * `Contract2`.  Let's suppose these look like the following:
 *
 * ```solidity
 *pragma solidity ^0.8.0;
 *
 *contract Contract1 {
 *  function enumExample(Contract2.Ternary x) public payable {
 *  }
 *
 *  function overloaded(uint x) public payable {
 *  }
 *
 *  function overloaded(string x) public payable {
 *  }
 *}
 *
 *contract Contract2 {
 *  enum Ternary { No, Yes, Maybe }
 *}
 * ```
 *
 * #### Encoding a transaction
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abi = Contract1.abi.find(abiEntry => abiEntry.name === "enumExample");
 *const tx = await encoder.encodeTransaction(
 *  abi,
 *  ["Maybe", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * ### Performing overload resolution
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abis = Contract1.abi.filter(abiEntry => abiEntry.name === "overloaded");
 *const { tx, abi } = await encoder.encodeTransaction(
 *  abis,
 *  ["hello", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * @module @truffle/encoder
 * @packageDocumentation
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forContractInstance = exports.forContractAt = exports.forArtifactAt = exports.forDeployedContract = exports.forDeployedArtifact = exports.forContract = exports.forArtifact = exports.forProjectInternal = exports.forProject = exports.ProviderAdapter = exports.ContractNotDeployedError = exports.ContractNotFoundError = exports.UnlinkedContractError = exports.NoInternalInfoError = exports.InvalidAddressError = exports.ContractInstanceEncoder = exports.ContractEncoder = exports.ProjectEncoder = void 0;
const encoders_1 = __webpack_require__(113247);
Object.defineProperty(exports, "ProjectEncoder", ({ enumerable: true, get: function () { return encoders_1.ProjectEncoder; } }));
Object.defineProperty(exports, "ContractEncoder", ({ enumerable: true, get: function () { return encoders_1.ContractEncoder; } }));
Object.defineProperty(exports, "ContractInstanceEncoder", ({ enumerable: true, get: function () { return encoders_1.ContractInstanceEncoder; } }));
var errors_1 = __webpack_require__(500079);
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return errors_1.InvalidAddressError; } }));
Object.defineProperty(exports, "NoInternalInfoError", ({ enumerable: true, get: function () { return errors_1.NoInternalInfoError; } }));
Object.defineProperty(exports, "UnlinkedContractError", ({ enumerable: true, get: function () { return errors_1.UnlinkedContractError; } }));
Object.defineProperty(exports, "ContractNotFoundError", ({ enumerable: true, get: function () { return errors_1.ContractNotFoundError; } }));
Object.defineProperty(exports, "ContractNotDeployedError", ({ enumerable: true, get: function () { return errors_1.ContractNotDeployedError; } }));
const adapter_1 = __webpack_require__(812165);
Object.defineProperty(exports, "ProviderAdapter", ({ enumerable: true, get: function () { return adapter_1.ProviderAdapter; } }));
const codec_1 = __webpack_require__(20102);
/**
 * **This function is asynchronous.**
 *
 * Constructs a project encoder for the project.
 * @category Constructors
 */
function forProject(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const compilations = codec_1.Compilations.Utils.infoToCompilations(settings.projectInfo);
        const ens = ensSettingsForInfo(settings);
        const networkId = yield networkIdForInfo(settings);
        const encoder = new encoders_1.ProjectEncoder(Object.assign({ compilations, networkId }, ens));
        yield encoder.init();
        return encoder;
    });
}
exports.forProject = forProject;
/**
 * @protected
 * @category Constructors
 */
function forProjectInternal(info) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoder = new encoders_1.ProjectEncoder(info);
        yield encoder.init();
        return encoder;
    });
}
exports.forProjectInternal = forProjectInternal;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract artifact.
 * @param artifact The artifact for the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Constructors
 */
function forArtifact(artifact, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!settings.projectInfo) {
            settings = Object.assign(Object.assign({}, settings), { projectInfo: { artifacts: [artifact] } });
        }
        let projectEncoder = yield forProject(settings);
        return yield projectEncoder.forArtifact(artifact);
    });
}
exports.forArtifact = forArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract.
 * @param contract The contract the encoder is for.  It should have all of
 *   its libraries linked.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forArtifact(contract, Object.assign({ provider: contract.web3.currentProvider, networkId: parseInt(contract.network_id) || undefined }, settings));
    });
}
exports.forContract = forContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * You must pass in a provider or network ID to use this function.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use, including the provider or
 *   network id; see the documentation for that type for more information.
 * @category Constructors
 */
function forDeployedArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance();
        return instanceEncoder;
    });
}
exports.forDeployedArtifact = forDeployedArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forDeployedContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return yield contractEncoder.forInstance();
    });
}
exports.forDeployedContract = forDeployedContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Provider-based Constructor
 */
function forArtifactAt(artifact, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance(address);
        return instanceEncoder;
    });
}
exports.forArtifactAt = forArtifactAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a contract instance at a given address.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractAt(contract, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return contractEncoder.forInstance(address);
    });
}
exports.forContractAt = forContractAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract abstraction object corresponding to the contract instance.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractInstance(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return forContractAt(contract.constructor, contract.address, settings);
    });
}
exports.forContractInstance = forContractInstance;
/**
 * @category Constructors
 */
function ensSettingsForInfo(settings) {
    if (settings.ens) {
        return settings.ens;
    }
    else {
        return {
            provider: settings.provider
        };
    }
}
/**
 * @category Constructors
 */
function networkIdForInfo(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (settings.networkId !== undefined) {
            return settings.networkId;
        }
        else if (settings.provider) {
            return yield new adapter_1.ProviderAdapter(settings.provider).getNetworkId();
        }
        else {
            return null;
        }
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 789916:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.link = exports.isEthersBigNumber = exports.isBigNumber = void 0;
const bignumber_js_1 = __importDefault(__webpack_require__(874868));
const bignumber_1 = __webpack_require__(539370);
const escapeRegExp_1 = __importDefault(__webpack_require__(435207));
// Unfortunately, both BigNumber and EthersBigNumber's isBigNumber methods
// **both return false positives on the other BigNumber class**.
// (This is because they both just check for the _isBigNumber flag.)
// As such, we've made our own method to recognize these, by
// A. using the appropriate method, but then also
// B. checking for the presence of a method that one class has but the other
// doesn't.
function isBigNumber(input) {
    return bignumber_js_1.default.isBigNumber(input) && Boolean(input.toFixed);
}
exports.isBigNumber = isBigNumber;
function isEthersBigNumber(input) {
    return bignumber_1.BigNumber.isBigNumber(input) && Boolean(input.toHexString);
}
exports.isEthersBigNumber = isEthersBigNumber;
//warning: copied (OK, adapted) from Truffle Contract!
function link(bytecode, links) {
    if (!bytecode) {
        return bytecode;
    }
    const names = Object.keys(links).sort((a, b) => b.length - a.length); //sort from longest to shortest
    //(this allows overlong names to be handled properly)
    for (const name of names) {
        const address = links[name];
        bytecode = bytecode.replace(
        //we have to escape as names may include '$'
        new RegExp(`__${escapeRegExp_1.default(name)}_*`, "g"), 
        //note: we don't have to worry about link references running into
        //one another, because each one is always preceded by a PUSH20 (0x73)
        address.slice(2) //cut off initial 0x
        );
    }
    return bytecode;
}
exports.link = link;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 296412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const debug = __webpack_require__(615158)("external-compile");
const { exec, execSync } = __webpack_require__(532081);
const resolve = (__webpack_require__(371017).resolve);
const { promisify } = __webpack_require__(473837);
const glob = promisify(__webpack_require__(312884));
const fs = __webpack_require__(657147);
const expect = __webpack_require__(414096);
const Schema = __webpack_require__(418370);
const web3Utils = __webpack_require__(118269);
const { Shims, Compilations } = __webpack_require__(529833);
const Config = __webpack_require__(120553);

const DEFAULT_ABI = [
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  }
];

/**
 * buffer a line of data, yielding each full line
 *
 * returned generator alternates between two states:
 * 1. reset
 * 2. read/write
 *
 * usage:
 *
 *   let gen = bufferLines();
 *
 *   // first reset
 *   gen.next(); // reset
 *
 *   // pass string data with zero or more new lines
 *   // or pass `null` to signal EOF
 *   let { value, done } = gen.next(data);
 *
 *   // if done, value possibly contains string value with unterminated output
 *   // otherwise, value contains any/all complete lines
 */
function* bufferLines() {
  let buffer = [];

  while (true) {
    // read input string or null as eof
    const input = yield;

    // eof returns buffer
    if (input == null) {
      const unterminated = buffer.join("");

      return unterminated ? [`${unterminated}%`] : [];
    }

    // split lines
    // last element is always partial line
    const data = input.split("\n");

    // add first element to buffer
    let [first] = data.slice(0);
    buffer.push(first);

    if (data.length > 1) {
      // split off partial line to save as new buffer
      const [last] = data.slice(-1);
      const [...middle] = data.slice(1, -1);

      // use buffer as first element (now complete line)
      // and yield all complete lines
      const lines = [buffer.join(""), ...middle];
      yield lines;

      // reset buffer
      buffer = [last];
    } else {
      // nothing to see yet
      yield [];
    }
  }
}

/**
 * run a command, forwarding data to arbitrary logger.
 * invokes callback when process exits, error on nonzero exit code.
 */
const runCommand = promisify(function (command, options, callback) {
  const { cwd, logger, input } = options;
  const child = exec(command, { cwd, input });

  // wrap buffer generator for easy use
  const buffer = func => {
    const gen = bufferLines();

    return data => {
      gen.next();

      let { value: lines } = gen.next(data);
      for (let line of lines) {
        func(line);
      }
    };
  };

  const log = buffer(logger.log);
  const warn = buffer(logger.warn || logger.log);

  child.stdout.on("data", data => log(data.toString()));
  child.stderr.on("data", data => warn(data.toString()));

  child.on("close", function (code) {
    // close streams to flush unterminated lines
    log(null);
    warn(null);

    // If the command didn't exit properly, show the output and throw.
    if (code !== 0) {
      var err = new Error("Unknown exit code: " + code);
      return callback(err);
    }

    callback();
  });
});

/**
 * identify and process contents as one of:
 * 1. JSON literal
 * 2. Hex string
 * 3. Raw binary data
 */
function decodeContents(contents) {
  // JSON
  try {
    return JSON.parse(contents);
  } catch (e) {
    /* no-op */
  }

  // hex string
  if (contents.toString().startsWith("0x")) {
    return contents.toString();
  }

  // raw binary
  return web3Utils.bytesToHex(contents);
}

async function processTargets(targets, cwd, logger) {
  const contracts = [];
  for (let target of targets) {
    let targetContracts = await processTarget(target, cwd, logger);
    for (let contract of Object.values(targetContracts)) {
      contracts.push(Schema.validate(contract));
    }
  }

  return contracts;
}

async function processTarget(target, cwd, logger) {
  const usesPath = target.path != undefined;
  const usesCommand = target.command != undefined;
  const usesStdin = target.stdin || target.stdin == undefined; // default true
  const usesProperties = target.properties || target.fileProperties;

  if (usesProperties && usesPath) {
    throw new Error(
      "External compilation target cannot define both properties and path"
    );
  }

  if (usesProperties && usesCommand) {
    throw new Error(
      "External compilation target cannot define both properties and command"
    );
  }

  if (usesCommand && !usesPath) {
    // just run command
    const output = execSync(target.command, { cwd });
    const contract = JSON.parse(output);
    return { [contract.contractName]: contract };
  }

  if (usesPath && !glob.hasMagic(target.path)) {
    // individual file
    const filename = resolve(cwd, target.path);
    let input, command, execOptions;
    if (usesStdin) {
      input = fs.readFileSync(filename).toString();
      command = target.command;
      execOptions = { cwd, input };
    } else {
      command = `${target.command} ${filename}`;
      execOptions = { cwd };
    }

    const output = usesCommand ? execSync(command, execOptions) : input;

    const contract = JSON.parse(output);
    return { [contract.contractName]: contract };
  }

  if (usesPath && glob.hasMagic(target.path)) {
    // glob expression, recurse after expansion
    let paths = await glob(target.path, { cwd, follow: true });
    // copy target properties, overriding path with expanded form
    let targets = paths.map(path => Object.assign({}, target, { path }));
    return await processTargets(targets, cwd, logger);
  }

  if (usesProperties) {
    // contract properties listed individually
    const contract = Object.assign({}, target.properties || {});

    for (let [key, path] of Object.entries(target.fileProperties || {})) {
      const contents = fs.readFileSync(resolve(cwd, path));
      const value = decodeContents(contents);

      contract[key] = value;
    }

    if (!contract.contractName) {
      throw new Error("External compilation target must specify contractName");
    }

    if (!contract.abi) {
      contract.abi = DEFAULT_ABI;
    }

    if (!contract.bytecode && logger) {
      logger.log(
        "Warning: contract " +
          contract.contractName +
          " does not specify bytecode. You won't be able to deploy it."
      );
    }

    return { [contract.contractName]: contract };
  }
}

const Compile = {
  async all(options) {
    return await Compile.sources({
      // currently you cannot specify sources here
      sources: undefined,
      options
    });
  },

  async necessary(options) {
    return await Compile.sources({
      // currently you cannot specify sources here
      sources: undefined,
      options
    });
  },

  // compile-common defines object argument to include `sources`, but this is
  // unused as the user is responsible for dealing with compiling their sources
  async sources({ options }) {
    options = Config.default().merge(options);
    if (options.logger == null) {
      options.logger = console;
    }

    expect.options(options, ["compilers"]);
    expect.options(options.compilers, ["external"]);
    expect.options(options.compilers.external, ["command", "targets"]);

    const { command, targets } = options.compilers.external;
    const cwd =
      options.compilers.external.workingDirectory ||
      options.compilers.external.working_directory || // just in case
      options.working_directory;
    const logger = options.logger;

    debug("running compile command: %s", command);
    await runCommand(command, { cwd, logger });

    const contracts = await processTargets(targets, cwd, logger);
    const compilations = [
      {
        contracts: contracts.map(Shims.LegacyToNew.forContract),
        // sourceIndexes is empty because we have no way of
        // knowing for certain the source paths for the contracts
        sourceIndexes: [],
        // since we don't know the sourcePaths, we can't really provide
        // the source info reliably
        sources: [],
        compiler: {
          name: "external",
          version: undefined
        }
      }
    ];
    return Compilations.promoteCompileResult({ compilations });
  },

  async sourcesWithDependencies({ options }) {
    return await Compile.sources({ options });
  }
};

module.exports = {
  Compile,
  DEFAULT_ABI,
  processTarget
};


/***/ }),

/***/ 687440:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:debug");
const Codec = __importStar(__webpack_require__(20102));
class DebugRecognizer {
    constructor(bugger) {
        this.addressesToSkip = new Set();
        this.badFetchAddresses = [];
        this.badCompileAddresses = [];
        this.badFetchers = [];
        this.bugger = bugger; //no clone, note!
    }
    getErrors() {
        return {
            fetch: this.badFetchAddresses,
            compile: this.badCompileAddresses,
            fetchers: this.badFetchers
        };
    }
    //helper method
    getUnrecognizedAddresses() {
        debug("getting unknown addresses");
        const instances = this.bugger.view(this.bugger.selectors.session.info.affectedInstances);
        debug("got instances");
        return Object.entries(instances)
            .filter(([_, { contractName }]) => contractName === undefined)
            .map(([address, _]) => address);
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return this.getUnrecognizedAddresses().includes(address);
    }
    getAnUnrecognizedAddress() {
        return this.getUnrecognizedAddresses().find(address => !this.addressesToSkip.has(address));
    }
    markUnrecognizable(address, reason) {
        //debugger does not keep track of detailed errors
        if (reason) {
            switch (reason) {
                case "fetch":
                    this.badFetchAddresses.push(address);
                    break;
                case "compile":
                    this.badCompileAddresses.push(address);
                    break;
                default:
                    //just ignore ones with unsupported language
                    break;
            }
        }
        this.addressesToSkip.add(address);
    }
    markBadFetcher(fetcherName) {
        this.badFetchers.push(fetcherName);
    }
    addCompiledInfo(info, address) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("compileResult: %O", info.compileResult);
            const compilations = info.compileResult.compilations;
            const shimmedCompilations = Codec.Compilations.Utils.shimCompilations(compilations, `externalFor(${address})Via(${info.fetchedVia})`);
            yield this.bugger.addExternalCompilations(shimmedCompilations);
        });
    }
}
exports.DebugRecognizer = DebugRecognizer;
//# sourceMappingURL=debug.js.map

/***/ }),

/***/ 350588:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSortedFetcherConstructors = exports.fetchAndCompileForRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:fetch");
const semver_1 = __importDefault(__webpack_require__(517110));
const source_fetcher_1 = __importDefault(__webpack_require__(887031));
const source_fetcher_2 = __webpack_require__(887031);
const config_1 = __importDefault(__webpack_require__(120553));
const { Compile } = __webpack_require__(4273); //sorry for untyped import!
const utils_1 = __webpack_require__(373727);
function fetchAndCompileForRecognizer(recognizer, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const fetcherConstructors = getSortedFetcherConstructors(utils_1.normalizeFetcherNames(normalizedOptions));
        const fetchers = yield getFetchers(fetcherConstructors, normalizedOptions, recognizer);
        //now: the main loop!
        let address;
        while ((address = recognizer.getAnUnrecognizedAddress()) !== undefined) {
            yield tryFetchAndCompileAddress(address, fetchers, recognizer, normalizedOptions);
        }
    });
}
exports.fetchAndCompileForRecognizer = fetchAndCompileForRecognizer;
//sort/filter fetchers by user's order, if given; otherwise use default order
function getSortedFetcherConstructors(userFetcherNames) {
    let sortedFetchers = [];
    if (userFetcherNames) {
        for (let name of userFetcherNames) {
            let Fetcher = source_fetcher_1.default.find(Fetcher => Fetcher.fetcherName === name);
            if (Fetcher) {
                sortedFetchers.push(Fetcher);
            }
            else {
                throw new Error(`Unknown external source service ${name}.`);
            }
        }
    }
    else {
        sortedFetchers = source_fetcher_1.default;
    }
    return sortedFetchers;
}
exports.getSortedFetcherConstructors = getSortedFetcherConstructors;
function getFetchers(fetcherConstructors, options, recognizer) {
    return __awaiter(this, void 0, void 0, function* () {
        const networkId = options.network.networkId;
        //make fetcher instances. we'll filter out ones that don't support this
        //network (and note ones that yielded errors)
        return (yield Promise.all(fetcherConstructors.map((Fetcher) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield Fetcher.forNetworkId(networkId, ((options.fetch || {}).fetcherOptions || {})[Fetcher.fetcherName]);
            }
            catch (error) {
                if (!(error instanceof source_fetcher_2.InvalidNetworkError)) {
                    //if it's *not* just an invalid network, log the error.
                    recognizer.markBadFetcher(Fetcher.fetcherName);
                }
                //either way, filter this fetcher out
                return null;
            }
        })))).filter((fetcher) => fetcher !== null);
    });
}
function tryFetchAndCompileAddress(address, fetchers, recognizer, fetchAndCompileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        let found = false;
        let failureReason; //undefined if no failure
        let failureError;
        //(this includes if no source is found)
        for (const fetcher of fetchers) {
            //now comes all the hard parts!
            //get our sources
            let result;
            try {
                debug("getting sources for %s via %s", address, fetcher.fetcherName);
                result = yield fetcher.fetchSourcesForAddress(address);
            }
            catch (error) {
                debug("error in getting sources! %o", error);
                failureReason = "fetch";
                failureError = error;
                continue;
            }
            if (result === null) {
                debug("no sources found");
                //null means they don't have that address
                continue;
            }
            //if we do have it, extract sources & options
            debug("got sources!");
            const { sources, options } = result; //not same options as above, sorry for name confusion
            if (options.language === "Vyper") {
                //if it's not Solidity, bail out now
                debug("found Vyper, bailing out!");
                recognizer.markUnrecognizable(address, "language");
                //break out of the fetcher loop, since *no* fetcher will work here
                break;
            }
            //set up the config
            let externalConfig = config_1.default.default().with({
                compilers: {
                    solc: options
                }
            });
            //if using docker, transform it (this does nothing if not using docker)
            externalConfig = transformIfUsingDocker(externalConfig, fetchAndCompileOptions);
            //compile the sources
            let compileResult;
            try {
                compileResult = yield Compile.sources({
                    options: externalConfig.with({ quiet: true }),
                    sources
                });
            }
            catch (error) {
                debug("compile error: %O", error);
                failureReason = "compile";
                failureError = error;
                continue; //try again with a different fetcher, I guess?
            }
            //add it!
            yield recognizer.addCompiledInfo({
                compileResult,
                sourceInfo: result,
                fetchedVia: fetcher.fetcherName
            }, address);
            failureReason = undefined; //mark as *not* failed in case a previous fetcher failed
            failureError = undefined;
            //check: did this actually help?
            debug("checking result");
            if (!recognizer.isAddressUnrecognized(address)) {
                debug("address %s successfully recognized via %s", address, fetcher.fetcherName);
                found = true;
                //break out of the fetcher loop -- we got what we want
                break;
            }
            debug("address %s still unrecognized", address);
        }
        if (found === false) {
            //if we couldn't find it, add it to the list of addresses to skip
            recognizer.markUnrecognizable(address, failureReason, failureError);
        }
    });
}
function transformIfUsingDocker(externalConfig, fetchAndCompileOptions) {
    const useDocker = Boolean((fetchAndCompileOptions.compile || {}).docker);
    if (!useDocker) {
        //if they're not using docker, no need to transform anything :)
        return externalConfig;
    }
    const givenVersion = externalConfig.compilers.solc.version;
    //if they are, we have to ask: are they using a nightly?
    if (semver_1.default.prerelease(givenVersion)) {
        //we're not going to attempt to make Docker work with nightlies.
        //just keep Docker turned off.
        return externalConfig;
    }
    //otherwise, turn on Docker, and reduce the version to its simple form.
    const simpleVersion = semver_1.default.valid(givenVersion);
    if (simpleVersion === null) {
        //this should never happen
        throw new Error("Fetched source has unparseable compiler version");
    }
    return externalConfig.merge({
        compilers: {
            solc: {
                version: simpleVersion,
                docker: true
            }
        }
    });
}
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ 705523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSupportedNetworks = exports.fetchAndCompileForDebugger = exports.fetchAndCompileMultiple = exports.fetchAndCompile = exports.fetchAndCompileForRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile");
const recognizer_1 = __webpack_require__(436846);
const multiple_1 = __webpack_require__(700943);
const debug_2 = __webpack_require__(687440);
const fetch_1 = __webpack_require__(350588);
Object.defineProperty(exports, "fetchAndCompileForRecognizer", ({ enumerable: true, get: function () { return fetch_1.fetchAndCompileForRecognizer; } }));
const utils_1 = __webpack_require__(373727);
function fetchAndCompile(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new recognizer_1.SingleRecognizer(address);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getResult();
    });
}
exports.fetchAndCompile = fetchAndCompile;
/**
 * warning: while this function deduplicates inputs,
 * it does *not* make any further effort to avoid redundant
 * fetches (e.g. if multiple addresses share the same source),
 * unlike fetchAndCompileForDebugger
 */
function fetchAndCompileMultiple(addresses, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new multiple_1.MultipleRecognizer(addresses);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getResults();
    });
}
exports.fetchAndCompileMultiple = fetchAndCompileMultiple;
//note: this function is called primarily for its side-effects
//(i.e. adding compilations to the debugger), NOT its return value!
function fetchAndCompileForDebugger(bugger, //sorry; this should be a debugger object
options) {
    return __awaiter(this, void 0, void 0, function* () {
        const normalizedOptions = utils_1.normalizeFetchAndCompileOptions(options);
        const recognizer = new debug_2.DebugRecognizer(bugger);
        yield fetch_1.fetchAndCompileForRecognizer(recognizer, normalizedOptions);
        return recognizer.getErrors();
    });
}
exports.fetchAndCompileForDebugger = fetchAndCompileForDebugger;
function getSupportedNetworks(optionsOrFetcherNames) {
    const fetcherNames = utils_1.normalizeFetcherNames(optionsOrFetcherNames);
    const fetchers = fetch_1.getSortedFetcherConstructors(fetcherNames);
    //strictly speaking these are fetcher constructors, but since we
    //won't be using fetcher instances in this function, I'm not going
    //to worry about the difference
    let supportedNetworks = {};
    for (const fetcher of fetchers) {
        const fetcherNetworks = fetcher.getSupportedNetworks();
        for (const name in fetcherNetworks) {
            if (name in supportedNetworks) {
                supportedNetworks[name].fetchers.push(fetcher.fetcherName);
            }
            else {
                supportedNetworks[name] = Object.assign(Object.assign({}, fetcherNetworks[name]), { fetchers: [fetcher.fetcherName] });
            }
        }
    }
    return supportedNetworks;
}
exports.getSupportedNetworks = getSupportedNetworks;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 700943:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultipleRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:multiple");
const web3_utils_1 = __importDefault(__webpack_require__(118269));
class MultipleRecognizer {
    constructor(addresses) {
        this.addressesToSkip = new Set();
        this.results = {};
        this.failureLog = {};
        this.unrecognizedAddresses = [
            ...new Set(addresses.map(web3_utils_1.default.toChecksumAddress))
        ]; //remove duplicates (checksum to make case-insensitive & canonical) and clone
    }
    getResults() {
        return {
            results: this.results,
            failures: this.failureLog
        };
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return this.unrecognizedAddresses.includes(address);
    }
    getAnUnrecognizedAddress() {
        return this.unrecognizedAddresses.find(address => !this.addressesToSkip.has(address));
    }
    markUnrecognizable(address, reason, error) {
        this.failureLog[address] = { reason, error };
        this.addressesToSkip.add(address);
    }
    markBadFetcher(_fetcherName) {
        //do nothing
    }
    addCompiledInfo(info, address) {
        this.results[address] = info;
        const index = this.unrecognizedAddresses.indexOf(address);
        this.unrecognizedAddresses.splice(index, 1); //delete the address from the array
    }
}
exports.MultipleRecognizer = MultipleRecognizer;
//# sourceMappingURL=multiple.js.map

/***/ }),

/***/ 436846:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SingleRecognizer = void 0;
const debug_1 = __importDefault(__webpack_require__(356514));
const debug = debug_1.default("fetch-and-compile:recognizer");
class SingleRecognizer {
    constructor(address) {
        this.recognized = false;
        this.address = address;
    }
    getResult() {
        return {
            compileResult: this.compileResult,
            sourceInfo: this.sourceInfo,
            fetchedVia: this.fetchedVia
        };
    }
    /*
     * Interface methods follow
     */
    isAddressUnrecognized(address) {
        return !this.recognized || address !== this.address; //I guess?
    }
    getAnUnrecognizedAddress() {
        return this.recognized ? undefined : this.address;
    }
    markUnrecognizable(address, reason, error) {
        //just throw...
        if (error) {
            throw error;
        }
        else if (reason) {
            switch (reason) {
                case "fetch":
                    throw new Error(`Error in fetching sources for ${address}`);
                case "compile":
                    throw new Error(`Error in compiling sources for ${address}`);
                case "language":
                    throw new Error(`Sources for ${address} were not in a supported language`);
            }
        }
        else {
            throw new Error(`No verified sources found for ${address}`);
        }
    }
    markBadFetcher(_fetcherName) {
        //do nothing
    }
    addCompiledInfo(info, address) {
        this.compileResult = info.compileResult;
        this.sourceInfo = info.sourceInfo;
        if (address === this.address) {
            //I guess? this should never be false
            this.recognized = true;
            this.fetchedVia = info.fetchedVia;
        }
    }
}
exports.SingleRecognizer = SingleRecognizer;
//# sourceMappingURL=recognizer.js.map

/***/ }),

/***/ 373727:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeFetcherNames = exports.normalizeFetchAndCompileOptions = void 0;
const config_1 = __importDefault(__webpack_require__(120553));
const source_fetcher_1 = __importDefault(__webpack_require__(887031));
function normalizeFetchAndCompileOptions(options) {
    if (options instanceof config_1.default) {
        let normalizedOptions = {
            network: {
                networkId: options.network_id
            },
            compile: {
                docker: ((options.compilers || {}).solc || {}).docker
            },
            fetch: {
                precedence: options.sourceFetchers,
                fetcherOptions: {}
            }
        };
        for (const fetcher of source_fetcher_1.default) {
            const fetcherName = fetcher.fetcherName;
            const fetcherOptions = options[fetcherName];
            //@ts-ignore TS can't recognize that the objects we just set up are definitely not undefined :-/
            normalizedOptions.fetch.fetcherOptions[fetcherName] = fetcherOptions;
        }
        return normalizedOptions;
    }
    else {
        return options;
    }
}
exports.normalizeFetchAndCompileOptions = normalizeFetchAndCompileOptions;
function normalizeFetcherNames(optionsOrFetcherNames) {
    if (Array.isArray(optionsOrFetcherNames)) {
        return optionsOrFetcherNames;
    }
    else if (!optionsOrFetcherNames) {
        return optionsOrFetcherNames;
    }
    else {
        const options = normalizeFetchAndCompileOptions(optionsOrFetcherNames);
        return ((options || {}).fetch || {}).precedence;
    }
}
exports.normalizeFetcherNames = normalizeFetcherNames;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 219798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("migrate:Migration");
const path = __webpack_require__(371017);
const Deployer = __webpack_require__(400669);
const Require = __webpack_require__(868992);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const ResolverIntercept = __webpack_require__(112715);
const { getTruffleDb } = __webpack_require__(570972);
const emitEvent = __webpack_require__(734578);

class Migration {
  constructor(file, config) {
    this.file = path.resolve(file);
    this.number = parseInt(path.basename(file));
    this.isFirst = false;
    this.isLast = false;
    this.dryRun = config.dryRun;
    this.interactive = config.interactive;
    this.config = config || {};
  }

  // ------------------------------------- Private -------------------------------------------------
  /**
   * Loads & validates migration, then runs it.
   * @param  {Object}   options  config and command-line
   * @param  {Object}   context  web3 & interfaceAdapter
   * @param  {Object}   deployer truffle module
   * @param  {Object}   resolver truffle module
   */
  async _load(options, context, deployer, resolver) {
    // Load assets and run `execute`
    const accounts = await context.interfaceAdapter.getAccounts();
    const requireOptions = {
      file: this.file,
      context: context,
      resolver: resolver,
      args: [deployer]
    };

    const fn = Require.file(requireOptions);

    const unRunnable = !fn || !fn.length || fn.length == 0;

    if (unRunnable) {
      const msg = `Migration ${this.file} invalid or does not take any parameters`;
      throw new Error(msg);
    }

    // `migrateFn` might be sync or async. We negotiate that difference in
    // `execute` through the deployer API.
    const migrateFn = fn(deployer, options.network, accounts);
    await this._deploy(options, context, deployer, resolver, migrateFn);
  }

  /**
   * Initiates deployer sequence, then manages migrations info
   * publication to chain / artifact saving.
   * @param  {Object}   options     config and command-line
   * @param  {Object}   context     web3 & interfaceAdapter
   * @param  {Object}   deployer    truffle module
   * @param  {Object}   resolver    truffle module
   * @param  {[type]}   migrateFn   module.exports of a migrations.js
   */
  async _deploy(options, context, deployer, resolver, migrateFn) {
    try {
      await deployer.start();
      // Allow migrations method to be async and
      // deploy to use await
      if (migrateFn && migrateFn.then !== undefined) {
        await deployer.then(() => migrateFn);
      }

      // Migrate without saving
      if (options.save === false) return;

      let Migrations;
      // Attempt to write migrations record to chain
      try {
        Migrations = resolver.require("Migrations");
      } catch (error) {
        // do nothing, Migrations contract optional
      }

      if (Migrations && Migrations.isDeployed()) {
        const message = `Saving migration to chain.`;
        if (!this.dryRun) {
          const data = { message: message };
          await emitEvent(
            options,
            "migrate:settingCompletedMigrations:start",
            data
          );
        }

        const migrations = await Migrations.deployed();
        const receipt = await migrations.setCompleted(this.number);

        if (!this.dryRun) {
          const data = { receipt: receipt, message: message };
          await emitEvent(
            options,
            "migrate:settingCompletedMigrations:succeed",
            data
          );
        }
      }

      const eventArgs = {
        isLast: this.isLast,
        interfaceAdapter: context.interfaceAdapter
      };

      await emitEvent(options, "migrate:migration:succeed", eventArgs);

      let artifacts = resolver
        .contracts()
        .map(abstraction => abstraction._json);
      if (this.config.db && this.config.db.enabled && artifacts.length > 0) {
        // currently if Truffle Db fails to load, getTruffleDb returns `null`
        const Db = getTruffleDb();

        if (Db) {
          const db = Db.connect(this.config.db);
          const project = await Db.Project.initialize({
            db,
            project: {
              directory: this.config.working_directory
            }
          });

          const result = await project
            .connect({ provider: this.config.provider })
            .loadMigrate({
              network: {
                name: this.config.network
              },
              artifacts
            });

          ({ artifacts } = result);

          await project.assignNames({
            assignments: {
              networks: [result.network]
            }
          });
        }
      }

      // Save artifacts to local filesystem
      await options.artifactor.saveAll(artifacts);

      deployer.finish();

      // Cleanup
      if (this.isLast) {
        // Exiting w provider-engine appears to be hopeless. This hack on
        // our fork just swallows errors from eth-block-tracking
        // as we unwind the handlers downstream from here.
        if (this.config.provider && this.config.provider.engine) {
          this.config.provider.engine.silent = true;
        }
      }
    } catch (error) {
      const errorData = {
        type: "migrateErr",
        error: error
      };

      await emitEvent(options, "migrate:migration:error", errorData);
      deployer.finish();
      throw error;
    }
  }

  // ------------------------------------- Public -------------------------------------------------
  /**
   * Instantiates a deployer, connects this migration and its deployer to the reporter
   * and launches a migration file's deployment sequence
   * @param  {Object}   options  config and command-line
   */
  async run(options) {
    const { interfaceAdapter, resolver, context, deployer } =
      this.prepareForMigrations(options);

    // Get file path and emit pre-migration event
    const file = path.relative(options.migrations_directory, this.file);
    const block = await interfaceAdapter.getBlock("latest");

    const preMigrationsData = {
      file: file,
      number: this.number,
      isFirst: this.isFirst,
      network: options.network,
      networkId: options.network_id,
      blockLimit: block.gasLimit
    };

    await emitEvent(options, "migrate:migration:start", preMigrationsData);
    await this._load(options, context, deployer, resolver);
  }

  prepareForMigrations(options) {
    const interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    const web3 = new Web3Shim({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });

    const resolver = new ResolverIntercept(options.resolver);

    // Initial context.
    const context = { web3, interfaceAdapter, config: this.config };

    const deployer = new Deployer(options);

    return { interfaceAdapter, resolver, context, deployer };
  }

  /**
   * Returns a serializable version of `this`
   * @returns  {Object}
   */
  serializeable() {
    return {
      file: this.file,
      number: this.number,
      isFirst: this.isFirst,
      isLast: this.isLast,
      dryRun: this.dryRun,
      interactive: this.interactive
    };
  }
}

module.exports = Migration;


/***/ }),

/***/ 112715:
/***/ ((module) => {

class ResolverIntercept {
  constructor(resolver) {
    this.resolver = resolver;
    this.cache = [];
  }

  require(contractName) {
    // remove file extension if present on name
    const sanitizedContractName = contractName
      .replace(/^\.\//, "")
      .replace(/\.sol$/i, "");

    // there may be more than one contract of the same name which will be
    // problematic - only return the first one found in the cache for now
    for (const contract of this.cache) {
      if (contract.contract_name === sanitizedContractName) {
        return contract;
      }
    }

    // Note, will error if nothing is found.
    const resolved = this.resolver.require(sanitizedContractName);

    this.cache.push(resolved);

    // During migrations, we could be on a network that takes a long time to accept
    // transactions (i.e., contract deployment close to block size). Because successful
    // migration is more important than wait time in those cases, we'll synchronize "forever".
    resolved.synchronization_timeout = 0;

    return resolved;
  }

  contracts() {
    return this.cache;
  }
}

module.exports = ResolverIntercept;


/***/ }),

/***/ 734578:
/***/ ((module) => {

module.exports = async (options, name, data) => {
  if (options.events) {
    return await options.events.emit(name, data);
  }
};


/***/ }),

/***/ 523459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(657147);
const path = __webpack_require__(371017);
const glob = __webpack_require__(312884);
const expect = __webpack_require__(414096);
const Config = __webpack_require__(120553);
const Migration = __webpack_require__(219798);
const emitEvent = __webpack_require__(734578);
const inquirer = __webpack_require__(496062);

/**
 *  This API is consumed by `@truffle/core` at the `migrate` and `test` commands via
 *  the `.runMigrations` method.
 */
const Migrate = {
  Migration: Migration,
  logger: null,

  promptToAcceptDryRun: async function (options) {
    const prompt = [
      {
        type: "confirm",
        name: "proceed",
        message: `Dry-run successful. Do you want to proceed with real deployment?  >> (y/n): `,
        default: false
      }
    ];

    const answer = await inquirer.prompt(prompt);
    if (answer.proceed) {
      return true;
    }
    await emitEvent(options, "migrate:dryRun:notAccepted");
    return false;
  },

  assemble: function (options) {
    const config = Config.detect(options);
    if (
      !fs.existsSync(config.migrations_directory) ||
      !fs.readdirSync(config.migrations_directory).length > 0
    ) {
      return [];
    }

    const migrationsDir = config.migrations_directory;
    const directoryContents = glob.sync(`${migrationsDir}${path.sep}*`);
    const files = directoryContents.filter(item => fs.statSync(item).isFile());

    if (files.length === 0) return [];

    let migrations = files
      .filter(file => isNaN(parseInt(path.basename(file))) === false)
      .filter(
        file =>
          path.extname(file).match(config.migrations_file_extension_regexp) !=
          null
      )
      .map(file => new Migration(file, config));

    // Make sure to sort the prefixes as numbers and not strings.
    migrations = migrations.sort((a, b) => {
      if (a.number > b.number) return 1;
      if (a.number < b.number) return -1;
      return 0;
    });
    return migrations;
  },

  run: async function (options, callback) {
    const callbackPassed = typeof callback === "function";
    try {
      expect.options(options, [
        "working_directory",
        "migrations_directory",
        "contracts_build_directory",
        "provider",
        "artifactor",
        "resolver",
        "network",
        "network_id",
        "logger",
        "from" // address doing deployment
      ]);

      if (options.reset === true) {
        await this.runAll(options);
        if (callbackPassed) return callback();
        return;
      }

      const lastMigration = await this.lastCompletedMigration(options);

      // Don't rerun the last completed migration.
      await this.runFrom(lastMigration + 1, options);

      if (callbackPassed) return callback();
      return;
    } catch (error) {
      if (callbackPassed) return callback(error);
      throw error;
    }
  },

  runFrom: async function (number, options) {
    let migrations = this.assemble(options);

    while (migrations.length > 0) {
      if (migrations[0].number >= number) break;
      migrations.shift();
    }

    if (options.to) {
      migrations = migrations.filter(
        migration => migration.number <= options.to
      );
    }
    return await this.runMigrations(migrations, options);
  },

  runAll: async function (options) {
    return await this.runFrom(0, options);
  },

  runMigrations: async function (migrations, options) {
    // Perform a shallow clone of the options object
    // so that we can override the provider option without
    // changing the original options object passed in.
    const clone = {};

    Object.keys(options).forEach(key => (clone[key] = options[key]));

    if (options.quiet) clone.logger = { log: function () {} };

    clone.resolver = this.wrapResolver(options.resolver, clone.provider);

    // Make migrations aware of their position in sequence
    const total = migrations.length;
    if (total) {
      migrations[0].isFirst = true;
      migrations[total - 1].isLast = true;
    }

    await emitEvent(options, "migrate:runMigrations:start", {
      migrations,
      dryRun: options.dryRun
    });

    try {
      global.artifacts = clone.resolver;
      global.config = clone;
      for (const migration of migrations) {
        await migration.run(clone);
      }

      await emitEvent(options, "migrate:runMigrations:finish", {
        dryRun: options.dryRun,
        error: null
      });
      return;
    } catch (error) {
      await emitEvent(options, "migrate:runMigrations:finish", {
        dryRun: options.dryRun,
        error: error.toString()
      });
      throw error;
    } finally {
      delete global.artifacts;
      delete global.config;
    }
  },

  wrapResolver: function (resolver, provider) {
    return {
      require: function (import_path, search_path) {
        const abstraction = resolver.require(import_path, search_path);
        abstraction.setProvider(provider);
        return abstraction;
      },
      resolve: resolver.resolve
    };
  },

  lastCompletedMigration: async function (options) {
    let Migrations;

    try {
      Migrations = options.resolver.require("Migrations");
    } catch (error) {
      // don't throw, Migrations contract optional
      return 0;
    }

    if (Migrations.isDeployed() === false) return 0;

    const migrationsOnChain = async migrationsAddress => {
      return (
        (await Migrations.interfaceAdapter.getCode(migrationsAddress)) !== "0x"
      );
    };

    // Two possible Migrations.sol's (lintable/unlintable)
    const lastCompletedMigration = migrationsInstance => {
      try {
        return migrationsInstance.last_completed_migration.call();
      } catch (error) {
        if (error instanceof TypeError)
          return migrationsInstance.lastCompletedMigration.call();
        throw new Error(error);
      }
    };

    const migrations = await Migrations.deployed();
    let completedMigration;
    if (await migrationsOnChain(migrations.address)) {
      completedMigration = await lastCompletedMigration(migrations);
    } else {
      completedMigration = 0;
    }
    return parseInt(completedMigration);
  },

  needsMigrating: function (options) {
    return new Promise((resolve, reject) => {
      if (options.reset === true) return resolve(true);

      return this.lastCompletedMigration(options)
        .then(number => {
          const migrations = this.assemble(options);
          while (migrations.length > 0) {
            if (migrations[0].number >= number) break;
            migrations.shift();
          }

          return resolve(
            migrations.length > 1 || (migrations.length && number === 0)
          );
        })
        .catch(error => reject(error));
    });
  }
};

module.exports = Migrate;


/***/ }),

/***/ 207702:
/***/ ((module) => {

"use strict";

const provision = (contractAbstraction, truffleConfig) => {
    if (truffleConfig.provider) {
        contractAbstraction.setProvider(truffleConfig.provider);
    }
    if (truffleConfig.network_id) {
        contractAbstraction.setNetwork(truffleConfig.network_id);
    }
    if (truffleConfig.network && truffleConfig.networks) {
        contractAbstraction.setNetworkType(truffleConfig.networks[truffleConfig.network].type);
        // this is a workaround to allow users to opt out of the block polling that
        // web3 performs when we listen for confirmations which causes problems in testing
        if (truffleConfig.networks[truffleConfig.network]) {
            const { disableConfirmationListener } = truffleConfig.networks[truffleConfig.network];
            contractAbstraction.disableConfirmationListener = disableConfirmationListener;
        }
    }
    contractAbstraction.ens = truffleConfig.ens;
    [
        "from",
        "gas",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "type"
    ].forEach(key => {
        if (truffleConfig[key]) {
            const obj = {};
            obj[key] = truffleConfig[key];
            contractAbstraction.defaults(obj);
        }
    });
    return contractAbstraction;
};
module.exports = provision;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 868992:
/***/ ((module, exports, __webpack_require__) => {

const fs = __webpack_require__(657147);
const path = __webpack_require__(371017);
const Module = __webpack_require__(498188);
const vm = __webpack_require__(626144);
const originalrequire = __webpack_require__(344516);
const expect = __webpack_require__(414096);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const Config = __webpack_require__(120553);

// options.file: path to file to execute. Must be a module that exports a function.
// options.args: arguments passed to the exported function within file. If a callback
//   is not included in args, exported function is treated as synchronous.
// options.context: Object containing any global variables you'd like set when this
//   function is run.
const Require = {
  file: function (options) {
    let source;
    const file = options.file;
    const config = options.config;

    expect.options(options, ["file"]);

    options = Config.default().with(options);

    source = fs.readFileSync(options.file, { encoding: "utf8" });

    // Modified from here: https://gist.github.com/anatoliychakkaev/1599423
    const m = new Module(file);

    // Provide all the globals listed here: https://nodejs.org/api/globals.html
    const context = {
      __dirname: path.dirname(file),
      __filename: file,
      Buffer,
      clearImmediate,
      clearInterval,
      clearTimeout,
      console,
      exports,
      global,
      process,
      setImmediate,
      setInterval,
      setTimeout,
      config,
      module: m,
      artifacts: options.resolver,
      require: pkgPath => {
        // Ugh. Simulate a full require function for the file.
        pkgPath = pkgPath.trim();

        // If absolute, just require.
        if (path.isAbsolute(pkgPath)) return originalrequire(pkgPath);

        // If relative, it's relative to the file.
        if (pkgPath[0] === ".") {
          return originalrequire(path.join(path.dirname(file), pkgPath));
        } else {
          // Not absolute, not relative, must be a globally or locally installed module.
          // Try local first.
          // Here we have to require from the node_modules directory directly.

          var moduleDir = path.dirname(file);
          while (true) {
            try {
              return originalrequire(
                path.join(moduleDir, "node_modules", pkgPath)
              );
            } catch (e) {}
            var oldModuleDir = moduleDir;
            moduleDir = path.join(moduleDir, "..");
            if (moduleDir === oldModuleDir) break;
          }

          // Try global, and let the error throw.
          return originalrequire(pkgPath);
        }
      }
    };

    // Now add contract names.
    Object.keys(options.context || {}).forEach(key => {
      context[key] = options.context[key];
    });

    const old_cwd = process.cwd();

    process.chdir(path.dirname(file));

    const script = vm.createScript(source, file);
    script.runInNewContext(context);

    process.chdir(old_cwd);

    return m.exports;
  },

  exec: function (options, done) {
    expect.options(options, [
      "contracts_build_directory",
      "file",
      "resolver",
      "provider",
      "network",
      "network_id"
    ]);

    const interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    const web3 = new Web3Shim({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });

    try {
      const fn = this.file({
        file: options.file,
        context: { web3, interfaceAdapter },
        resolver: options.resolver,
        config: options
      });
      fn(done);
    } catch (error) {
      done(error);
    }
  }
};

module.exports = Require;


/***/ }),

/***/ 648511:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resolver = void 0;
const resolver_1 = __webpack_require__(629931);
Object.defineProperty(exports, "Resolver", ({ enumerable: true, get: function () { return resolver_1.Resolver; } }));
exports["default"] = resolver_1.Resolver;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 629931:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resolver = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("resolver");
const contract = __webpack_require__(378883);
const expect = __webpack_require__(414096);
const provision = __webpack_require__(207702);
const sources_1 = __webpack_require__(912493);
class Resolver {
    constructor(options, resolverOptions = {}) {
        expect.options(options, [
            "working_directory",
            "contracts_build_directory",
            "contracts_directory"
        ]);
        const { includeTruffleSources } = resolverOptions;
        this.options = options;
        let basicSources = [
            new sources_1.EthPMv1(options.working_directory),
            new sources_1.NPM(options.working_directory),
            new sources_1.GlobalNPM(),
            new sources_1.FS(options.working_directory, options.contracts_build_directory)
        ];
        if (includeTruffleSources) {
            basicSources.unshift(new sources_1.Truffle(options));
        }
        //set up abi-to-sol resolution
        this.sources = [].concat(...basicSources.map(source => [new sources_1.ABI(source), source]));
        //set up vyper resolution rules
        this.sources = [
            new sources_1.Vyper(basicSources, options.contracts_directory),
            ...this.sources //for Vyper this is redundant
        ];
    }
    // This function might be doing too much. If so, too bad (for now).
    require(import_path, search_path) {
        let abstraction;
        this.sources.forEach((source) => {
            const result = source.require(import_path, search_path);
            if (result) {
                abstraction = contract(result);
                provision(abstraction, this.options);
            }
        });
        if (abstraction)
            return abstraction;
        throw new Error("Could not find artifacts for " + import_path + " from any sources");
    }
    resolve(importPath, importedFrom, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = null;
            let filePath = null;
            let source = null;
            for (source of this.sources) {
                ({ body, filePath } = yield source.resolve(importPath, importedFrom, options));
                if (body !== undefined) {
                    break;
                }
            }
            if (body === undefined) {
                let message = `Could not find ${importPath} from any sources`;
                if (importedFrom) {
                    message += "; imported from " + importedFrom;
                }
                throw new Error(message);
            }
            return {
                body,
                filePath,
                source
            };
        });
    }
}
exports.Resolver = Resolver;
//# sourceMappingURL=resolver.js.map

/***/ }),

/***/ 769136:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABI = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const abi_to_sol_1 = __webpack_require__(801324);
class ABI {
    constructor(wrappedSource) {
        this.wrappedSource = wrappedSource;
    }
    // requiring artifacts is out of scope for this ResolverSource
    // just return `null` here and let another ResolverSource handle it
    require() {
        return null;
    }
    /**
     * @dev This attempts to resolve an ABI JSON file as Solidity using the
     *      abi-to-sol utility.
     *
     *      Note the **precondition** that `compiler`, if passed, will always
     *      refer to a version of solc, since this ResolverSource is explicitly
     *      disabled for Vyper.
     */
    resolve(importPath, importedFrom = "", options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { compiler } = options;
            if (!compiler || compiler.name !== "solc") {
                //this resolver source for use by solc only!
                //vyper doesn't need it and would be quite thrown off by it
                return { filePath: undefined, body: undefined };
            }
            let filePath;
            let body;
            if (!importPath.endsWith(".json")) {
                return { filePath, body };
            }
            const resolution = yield this.wrappedSource.resolve(importPath, importedFrom, options);
            if (resolution.body === undefined) {
                return { filePath, body };
            }
            const solidityVersion = determineSolidityVersion(compiler);
            ({ filePath, body } = resolution);
            // extract basename twice to support .json and .abi.json
            const name = path_1.default.basename(path_1.default.basename(filePath, ".json"), ".abi");
            try {
                const abi = JSON.parse(body);
                const soliditySource = abi_to_sol_1.generateSolidity({
                    name,
                    abi,
                    license: "MIT",
                    solidityVersion
                });
                return {
                    filePath,
                    body: soliditySource
                };
            }
            catch (_) {
                //we use this not-quite-empty Solidity to avoid warnings
                //pragma statement introduced in 0.4.0 so can't go earlier
                //than that :)
                const emptySolidity = `
        // SPDX-License-Identifier: MIT
        pragma solidity >=0.4.0;
      `;
                return {
                    filePath,
                    body: emptySolidity
                };
            }
        });
    }
    resolveDependencyPath(importPath, dependencyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            //just defer to wrapped source
            return yield this.wrappedSource.resolveDependencyPath(importPath, dependencyPath);
        });
    }
}
exports.ABI = ABI;
function determineSolidityVersion(compiler) {
    const { version } = compiler;
    // resolver.resolve's `compiler` option may include the full version string,
    // including commit and build target information. abi-to-sol only accepts a
    // short-form version range, i.e. <major>.<minor>.<patch>
    return version.split("+")[0];
}
//# sourceMappingURL=abi.js.map

/***/ }),

/***/ 310680:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EthPMv1 = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_1 = __importDefault(__webpack_require__(657147));
class EthPMv1 {
    constructor(workingDirectory) {
        this.workingDirectory = workingDirectory;
    }
    require(importPath) {
        if (importPath.indexOf(".") === 0 || importPath.indexOf("/") === 0) {
            return null;
        }
        // Look to see if we've compiled our own version first.
        var contract_name = path_1.default.basename(importPath, ".sol");
        // We haven't compiled our own version. Assemble from data in the lockfile.
        var separator = importPath.indexOf("/");
        var package_name = importPath.substring(0, separator);
        var install_directory = path_1.default.join(this.workingDirectory, "installed_contracts");
        var lockfile = path_1.default.join(install_directory, package_name, "lock.json");
        try {
            lockfile = fs_1.default.readFileSync(lockfile, "utf8");
        }
        catch (e) {
            return null;
        }
        lockfile = JSON.parse(lockfile);
        // TODO: contracts that reference other types
        // TODO: contract types that specify a hash as their key
        // TODO: imported name doesn't match type but matches deployment name
        var contract_types = lockfile.contract_types || {};
        var type = contract_types[contract_name];
        // No contract name of the type asked.
        if (!type)
            return null;
        var json = {
            abi: type.abi,
            contract_name: contract_name,
            networks: {},
            unlinked_binary: type.bytecode
        };
        // Go through deployments and save all of them
        Object.keys(lockfile.deployments || {}).forEach(function (blockchain) {
            var deployments = lockfile.deployments[blockchain];
            Object.keys(deployments).forEach(function (name) {
                var deployment = deployments[name];
                if (deployment.contract_type === contract_name) {
                    json.networks[blockchain] = {
                        events: {},
                        links: {},
                        address: deployment.address
                    };
                }
            });
        });
        return json;
    }
    resolve(importPath) {
        return __awaiter(this, void 0, void 0, function* () {
            var separator = importPath.indexOf("/");
            var package_name = importPath.substring(0, separator);
            var internal_path = importPath.substring(separator + 1);
            var installDir = this.workingDirectory;
            // If nothing's found, body returns `undefined`
            var body;
            while (true) {
                var file_path = path_1.default.join(installDir, "installed_contracts", importPath);
                try {
                    body = fs_1.default.readFileSync(file_path, { encoding: "utf8" });
                    break;
                }
                catch (err) { }
                file_path = path_1.default.join(installDir, "installed_contracts", package_name, "contracts", internal_path);
                try {
                    body = fs_1.default.readFileSync(file_path, { encoding: "utf8" });
                    break;
                }
                catch (err) { }
                // Recurse outwards until impossible
                var oldInstallDir = installDir;
                installDir = path_1.default.join(installDir, "..");
                if (installDir === oldInstallDir) {
                    break;
                }
            }
            return { body, filePath: importPath };
        });
    }
    // We're resolving package paths to other package paths, not absolute paths.
    // This will ensure the source fetcher conintues to use the correct sources for packages.
    // i.e., if some_module/contracts/MyContract.sol imported "./AnotherContract.sol",
    // we're going to resolve it to some_module/contracts/AnotherContract.sol, ensuring
    // that when this path is evaluated this source is used again.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        var dirname = path_1.default.dirname(importPath);
        var resolved_dependency_path = path_1.default.join(dirname, dependencyPath);
        // Note: We use `path.join()` here to take care of path idiosyncrasies
        // like joining "something/" and "./something_else.sol". However, this makes
        // paths OS dependent, and on Windows, makes the separator "\". Solidity
        // needs the separator to be a forward slash. Let's massage that here.
        resolved_dependency_path = resolved_dependency_path.replace(/\\/g, "/");
        return resolved_dependency_path;
    }
}
exports.EthPMv1 = EthPMv1;
//# sourceMappingURL=ethpm-v1.js.map

/***/ }),

/***/ 303224:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FS = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_1 = __importDefault(__webpack_require__(657147));
class FS {
    constructor(workingDirectory, contractsBuildDirectory) {
        this.workingDirectory = workingDirectory;
        this.contractsBuildDirectory = contractsBuildDirectory;
    }
    require(importPath, searchPath = this.contractsBuildDirectory) {
        const normalizedImportPath = path_1.default.normalize(importPath);
        const contractName = this.getContractName(normalizedImportPath, searchPath);
        // If we have an absolute path, only check the file if it's a child of the workingDirectory.
        if (path_1.default.isAbsolute(normalizedImportPath)) {
            if (normalizedImportPath.indexOf(this.workingDirectory) !== 0) {
                return null;
            }
        }
        try {
            const result = fs_1.default.readFileSync(path_1.default.join(searchPath, `${contractName}.json`), "utf8");
            return JSON.parse(result);
        }
        catch (e) {
            return null;
        }
    }
    getContractName(sourcePath, searchPath = this.contractsBuildDirectory) {
        const contractsBuildDirFiles = fs_1.default.readdirSync(searchPath);
        const filteredBuildArtifacts = contractsBuildDirFiles.filter((file) => file.match(".json") != null);
        for (const buildArtifact of filteredBuildArtifacts) {
            const artifact = JSON.parse(fs_1.default.readFileSync(path_1.default.resolve(searchPath, buildArtifact)).toString());
            if (artifact.sourcePath === sourcePath) {
                return artifact.contractName;
            }
        }
        // fallback
        return path_1.default.basename(sourcePath, ".sol");
    }
    resolve(importPath, _importedFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!path_1.default.isAbsolute(importPath)) {
                //the FS resolver should only resolve absolute paths.
                //If things are being done properly, then either:
                //1. this is a top-level path so of course it's absolute; or,
                //2. the import was an explicitly relative path... which has been
                //converted to absolute by the time it's passed here.
                //The bad cases we want to disallow are:
                //3. this is an absolute path in an import (allowed here but disallowed
                //elsewhere)
                //4. this is an implicitly relative path in an import (we have to disallow
                //these, sorry, they cause problems with Solidity's import resolution)
                return { body: undefined, filePath: undefined };
            }
            try {
                const resolvedSource = fs_1.default.readFileSync(importPath, {
                    encoding: "utf8"
                });
                return { body: resolvedSource, filePath: importPath };
            }
            catch (error) {
                return { body: undefined, filePath: undefined };
            }
        });
    }
    // Here we're resolving from local files to local files, all absolute.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        const dirname = path_1.default.dirname(importPath);
        return path_1.default.resolve(path_1.default.join(dirname, dependencyPath));
    }
}
exports.FS = FS;
//# sourceMappingURL=fs.js.map

/***/ }),

/***/ 382776:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalNPM = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_1 = __importDefault(__webpack_require__(657147));
const detectInstalled = __webpack_require__(409790);
const getInstalledPath = __webpack_require__(239975);
class GlobalNPM {
    require(importPath) {
        if (importPath.indexOf(".") === 0 || path_1.default.isAbsolute(importPath)) {
            return null;
        }
        const contractName = path_1.default.basename(importPath, ".sol");
        let [packageName] = importPath.split("/", 1);
        if (detectInstalled.sync(packageName)) {
            const regex = new RegExp(`/${packageName}$`);
            const globalPackagePath = getInstalledPath
                .getInstalledPathSync(packageName)
                .replace(regex, "");
            const result = this.resolveAndParse(globalPackagePath, packageName, contractName);
            // result is null if it fails to resolve
            if (result) {
                return result;
            }
        }
        return null;
    }
    resolveAndParse(basePath, packageName, contractName) {
        const packagePath = path_1.default.join(basePath, packageName);
        const subDirs = [`build${path_1.default.sep}contracts`, "build"];
        for (const subDir of subDirs) {
            const possiblePath = path_1.default.join(packagePath, subDir, `${contractName}.json`);
            try {
                const result = fs_1.default.readFileSync(possiblePath, "utf8");
                return JSON.parse(result);
            }
            catch (e) {
                continue;
            }
        }
        return null;
    }
    resolve(importPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let [packageName] = importPath.split("/", 1);
            let body;
            if (detectInstalled.sync(packageName)) {
                const regex = new RegExp(`/${packageName}$`);
                const globalPackagePath = getInstalledPath
                    .getInstalledPathSync(packageName)
                    .replace(regex, "");
                const expectedPath = path_1.default.join(globalPackagePath, importPath);
                try {
                    body = fs_1.default.readFileSync(expectedPath, { encoding: "utf8" });
                }
                catch (err) { }
            }
            // If nothing's found, body returns `undefined`
            return { body, filePath: importPath };
        });
    }
    // We're resolving package paths to other package paths, not absolute paths.
    // This will ensure the source fetcher conintues to use the correct sources for packages.
    // i.e., if some_module/contracts/MyContract.sol imported "./AnotherContract.sol",
    // we're going to resolve it to some_module/contracts/AnotherContract.sol, ensuring
    // that when this path is evaluated this source is used again.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        var dirname = path_1.default.dirname(importPath);
        return path_1.default.join(dirname, dependencyPath);
    }
}
exports.GlobalNPM = GlobalNPM;
//# sourceMappingURL=globalnpm.js.map

/***/ }),

/***/ 912493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vyper = exports.ABI = exports.Truffle = exports.FS = exports.GlobalNPM = exports.NPM = exports.EthPMv1 = void 0;
var ethpm_v1_1 = __webpack_require__(310680);
Object.defineProperty(exports, "EthPMv1", ({ enumerable: true, get: function () { return ethpm_v1_1.EthPMv1; } }));
var npm_1 = __webpack_require__(48854);
Object.defineProperty(exports, "NPM", ({ enumerable: true, get: function () { return npm_1.NPM; } }));
var globalnpm_1 = __webpack_require__(382776);
Object.defineProperty(exports, "GlobalNPM", ({ enumerable: true, get: function () { return globalnpm_1.GlobalNPM; } }));
var fs_1 = __webpack_require__(303224);
Object.defineProperty(exports, "FS", ({ enumerable: true, get: function () { return fs_1.FS; } }));
var truffle_1 = __webpack_require__(203785);
Object.defineProperty(exports, "Truffle", ({ enumerable: true, get: function () { return truffle_1.Truffle; } }));
var abi_1 = __webpack_require__(769136);
Object.defineProperty(exports, "ABI", ({ enumerable: true, get: function () { return abi_1.ABI; } }));
var vyper_1 = __webpack_require__(404320);
Object.defineProperty(exports, "Vyper", ({ enumerable: true, get: function () { return vyper_1.Vyper; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 48854:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NPM = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_1 = __importDefault(__webpack_require__(657147));
class NPM {
    constructor(workingDirectory) {
        this.workingDirectory = workingDirectory;
    }
    require(importPath, searchPath) {
        if (importPath.indexOf(".") === 0 || importPath.indexOf("/") === 0) {
            return null;
        }
        const contractName = path_1.default.basename(importPath, ".sol");
        const regex = new RegExp(`(.*)/${contractName}`);
        let packageName = "";
        const matched = regex.exec(importPath);
        if (matched) {
            packageName = matched[1];
        }
        // during testing a temp dir is passed as search path - we need to check the
        // working dir in case a built contract was not copied over to it
        for (const basePath of [searchPath, this.workingDirectory]) {
            if (!basePath) {
                continue;
            }
            const result = this.resolveAndParse(basePath, packageName, contractName);
            // result is null if it fails to resolve
            if (result) {
                return result;
            }
            continue;
        }
        return null;
    }
    resolve(import_path, _imported_from) {
        return __awaiter(this, void 0, void 0, function* () {
            // If nothing's found, body returns `undefined`
            var body;
            var modulesDir = this.workingDirectory;
            while (true) {
                var expected_path = path_1.default.join(modulesDir, "node_modules", import_path);
                try {
                    var body = fs_1.default.readFileSync(expected_path, { encoding: "utf8" });
                    break;
                }
                catch (err) { }
                // Recurse outwards until impossible
                var oldModulesDir = modulesDir;
                modulesDir = path_1.default.join(modulesDir, "..");
                if (modulesDir === oldModulesDir) {
                    break;
                }
            }
            return { body, filePath: import_path };
        });
    }
    resolveAndParse(basePath, packageName, contractName) {
        const packagePath = path_1.default.join(basePath, "node_modules", packageName);
        const subDirs = [`build${path_1.default.sep}contracts`, "build"];
        for (const subDir of subDirs) {
            const possiblePath = path_1.default.join(packagePath, subDir, `${contractName}.json`);
            try {
                const result = fs_1.default.readFileSync(possiblePath, "utf8");
                return JSON.parse(result);
            }
            catch (e) {
                continue;
            }
        }
        return null;
    }
    // We're resolving package paths to other package paths, not absolute paths.
    // This will ensure the source fetcher conintues to use the correct sources for packages.
    // i.e., if some_module/contracts/MyContract.sol imported "./AnotherContract.sol",
    // we're going to resolve it to some_module/contracts/AnotherContract.sol, ensuring
    // that when this path is evaluated this source is used again.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        var dirname = path_1.default.dirname(importPath);
        return path_1.default.join(dirname, dependencyPath);
    }
}
exports.NPM = NPM;
//# sourceMappingURL=npm.js.map

/***/ }),

/***/ 50794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deployed = void 0;
const web3Utils = __webpack_require__(118269);
const RangeUtils = __importStar(__webpack_require__(632739));
class Deployed {
    static makeSolidityDeployedAddressesLibrary(mapping, { solc: { version } }) {
        let source = "";
        source +=
            "//SPDX-License-Identifier: MIT\n" +
                "pragma solidity >= 0.4.15 < 0.9.0; \n\n library DeployedAddresses {" +
                "\n";
        for (let [name, address] of Object.entries(mapping)) {
            let body = "revert();";
            if (address) {
                address = Deployed.toChecksumAddress(address);
                body = "return payable(" + address + ");";
            }
            source +=
                "  function " +
                    name +
                    "() public pure returns (address payable) { " +
                    body +
                    " }";
            source += "\n";
        }
        source += "}";
        version = RangeUtils.resolveToRange(version);
        if (!RangeUtils.rangeContainsAtLeast(version, "0.5.0")) {
            //remove "payable"s in types if we're before 0.5.0
            source = source.replace(/address payable/g, "address");
        }
        if (!RangeUtils.rangeContainsAtLeast(version, "0.6.0")) {
            //remove "payable"s in conversions if we're before 0.6.0
            source = source.replace(/payable\((.*)\)/g, "$1");
        }
        return source;
    }
    // Pulled from ethereumjs-util, but I don't want all its dependencies at the moment.
    static toChecksumAddress(address) {
        address = address.toLowerCase().replace("0x", "");
        const hash = web3Utils.sha3(address).replace("0x", "");
        var ret = "0x";
        for (var i = 0; i < address.length; i++) {
            if (parseInt(hash[i], 16) >= 8) {
                ret += address[i].toUpperCase();
            }
            else {
                ret += address[i];
            }
        }
        return ret;
    }
}
exports.Deployed = Deployed;
//# sourceMappingURL=Deployed.js.map

/***/ }),

/***/ 203785:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Truffle = void 0;
const path_1 = __importDefault(__webpack_require__(371017));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const Deployed_1 = __webpack_require__(50794);
const contract_sources_1 = __importDefault(__webpack_require__(123542));
const contract = __webpack_require__(378883);
class Truffle {
    constructor(options) {
        this.options = options;
    }
    resolve(importPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (importPath === `truffle${path_1.default.sep}DeployedAddresses.sol`) {
                const sourceFiles = yield contract_sources_1.default(this.options.contracts_directory);
                const buildDirFiles = fs_extra_1.default.existsSync(this.options.contracts_build_directory)
                    ? fs_extra_1.default.readdirSync(this.options.contracts_build_directory)
                    : [];
                const abstractionFiles = buildDirFiles.filter(file => file.match(/^.*.json$/));
                const mapping = {};
                const blacklist = new Set(["Assert", "DeployedAddresses"]);
                // Ensure we have a mapping for source files and abstraction files
                // to prevent any compile errors in tests.
                sourceFiles.forEach((file) => {
                    // we need to account for .json and .abi.json files
                    const name = path_1.default.basename(path_1.default.basename(path_1.default.basename(file, ".sol"), ".json"), ".abi");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = false;
                });
                abstractionFiles.forEach(file => {
                    const name = path_1.default.basename(file, ".json");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = false;
                });
                const filesData = abstractionFiles.map(file => {
                    return fs_extra_1.default.readFileSync(path_1.default.join(this.options.contracts_build_directory, file), "utf8");
                });
                const addresses = filesData.map(data => {
                    const c = contract(JSON.parse(data));
                    c.setNetwork(this.options.network_id);
                    if (c.isDeployed())
                        return c.address;
                    return null;
                });
                addresses.forEach((address, i) => {
                    const name = path_1.default.basename(abstractionFiles[i], ".json");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = address;
                });
                const addressSource = Deployed_1.Deployed.makeSolidityDeployedAddressesLibrary(mapping, this.options.compilers);
                return { body: addressSource, filePath: importPath };
            }
            const truffleLibraries = [
                "Assert",
                "AssertAddress",
                "AssertAddressArray",
                "AssertBalance",
                "AssertBool",
                "AssertBytes32",
                "AssertBytes32Array",
                "AssertGeneral",
                "AssertInt",
                "AssertIntArray",
                "AssertString",
                "AssertUint",
                "AssertUintArray",
                "SafeSend"
            ];
            for (const lib of truffleLibraries) {
                if (importPath === `truffle${path_1.default.sep}${lib}.sol`) {
                    const actualImportPath = 
                    // @ts-ignore
                     true
                        ? path_1.default.resolve(path_1.default.join(__dirname, `${lib}.sol`))
                        : 0;
                    const body = fs_extra_1.default.readFileSync(actualImportPath, { encoding: "utf8" });
                    return { body, filePath: importPath };
                }
            }
            return { body: undefined, filePath: undefined };
        });
    }
    require() {
        // return null to let another source handle this behavior
        // (will be covered by FS source)
        return null;
    }
    resolveDependencyPath(_importPath, dependencyPath) {
        return dependencyPath;
    }
}
exports.Truffle = Truffle;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 404320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vyper = void 0;
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("resolver:sources:vyper");
const path_1 = __importDefault(__webpack_require__(371017));
class Vyper {
    constructor(wrappedSources, contractsDirectory) {
        this.wrappedSources = wrappedSources;
        this.cache = {};
        this.contractsDirectory = contractsDirectory;
    }
    require() {
        //out of scope for this resolver source
        return null;
    }
    resolve(importModule, importedFrom, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { compiler } = options;
            if (!compiler || compiler.name !== "vyper") {
                //this resolver source for use by Vyper only!
                debug("not Vyper, go away!");
                return { body: undefined, filePath: undefined };
            }
            importedFrom = importedFrom || "";
            debug("importModule: %s", importModule);
            debug("importedFrom: %s", importedFrom);
            //attempt to just resolve as if it's a file path rather than Vyper module
            //(we have to do this rather than just leaving it to the other, unwrapped,
            //resolver sources, because of resolveDependencyPath... yes, that results
            //in checking those sources twice on failure :-/ )
            for (const source of this.wrappedSources) {
                const directlyResolvedSource = yield source.resolve(importModule, importedFrom);
                if (directlyResolvedSource.body !== undefined) {
                    debug("found directly");
                    return directlyResolvedSource;
                }
            }
            //so if we've made it here, it's time for some Vyper module processing...
            debug("running Vyper import processing!");
            //only attempt this if what we have looks like a Vyper module
            if (!importModule.match(/^[\w.]+$/)) {
                debug("clearly not a Vyper module");
                return { body: undefined, filePath: undefined };
            }
            const importPath = moduleToPath(importModule); //note: no file extension yet
            debug("importPath: %s", importPath);
            const explicitlyRelative = importModule[0] === "."; //note we check importModule,
            //not importPath, to make the check simpler (can just check if begins with "."
            //rather than "./" or "../")
            debug("explicitlyRelative: %o", explicitlyRelative);
            const possiblePathsMinusExtension = [];
            //first: check in local directory
            possiblePathsMinusExtension.push(path_1.default.join(path_1.default.dirname(importedFrom), importPath));
            if (!explicitlyRelative) {
                //next: check in contracts dir, if not explicitly relative
                possiblePathsMinusExtension.push(path_1.default.join(this.contractsDirectory, importPath));
                //finally: check wherever the resolver says to check
                possiblePathsMinusExtension.push(importPath);
            }
            const possibleExtensions = [".json", ".vy"]; //Vyper only expects these two
            //note: this puts all JSON before all Vyper, which is how we want it
            //(we do not want to try Vyper from any sources until JSON from all sources
            //has been checked)
            const possiblePaths = [].concat(...possibleExtensions.map(extension => possiblePathsMinusExtension.map(path => path + extension)));
            debug("possiblePaths: %O", possiblePaths);
            for (const possiblePath of possiblePaths) {
                debug("possiblePath: %s", possiblePath);
                let resolvedSource;
                if (possiblePath in this.cache) {
                    resolvedSource = this.cache[possiblePath];
                }
                else {
                    for (const source of this.wrappedSources) {
                        debug("source: %o", source);
                        resolvedSource = yield source.resolve(possiblePath, importedFrom);
                        if (resolvedSource.body !== undefined) {
                            debug("found via this source");
                            break;
                        }
                    }
                    this.cache[possiblePath] = resolvedSource; //yes, even failures are cached!
                }
                if (resolvedSource.body !== undefined) {
                    debug("found");
                    return resolvedSource;
                }
                debug("not found");
            }
            //if not found, return nothing
            return { body: undefined, filePath: undefined };
        });
    }
    resolveDependencyPath(importPath, dependencyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            //unfortunately, for this sort of source to resolve a dependency path,
            //it's going to need to do a resolve :-/
            debug("importPath: %s", importPath);
            const resolved = yield this.resolve(dependencyPath, importPath, { compiler: { name: "vyper" } } //HACK
            );
            if (resolved) {
                return resolved.filePath;
            }
            else {
                return null;
            }
        });
    }
}
exports.Vyper = Vyper;
function moduleToPath(moduleName) {
    //first: get initial dot count by matching against regular expression for
    //initial dots, then taking captured group (note: regular expression
    //will always match so don't have to worry about null here) and taking
    //length
    const initialDotCount = moduleName.match(/^(\.*)/)[1].length;
    //then: change rest of dots to slashes
    const withoutInitialDots = moduleName.slice(initialDotCount);
    const pathWithoutDots = withoutInitialDots.replace(/\./g, path_1.default.sep);
    let initialDotPath;
    //then: interpret initial dots
    switch (initialDotCount) {
        case 0:
            initialDotPath = "";
            break;
        case 1:
            initialDotPath = "./";
            break;
        default:
            initialDotPath = "../".repeat(initialDotCount - 1);
            break;
    }
    //finally: combine
    return initialDotPath + pathWithoutDots;
}
//# sourceMappingURL=vyper.js.map

/***/ }),

/***/ 571103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidNetworkError = exports.removeLibraries = exports.makeTimer = exports.makeFilename = void 0;
//these imports aren't actually necessary, but why not :)
const util_1 = __importDefault(__webpack_require__(473837));
const timers_1 = __webpack_require__(939512);
function makeFilename(name, extension = ".sol") {
    if (!name) {
        return "Contract" + extension;
    }
    if (name.endsWith(extension)) {
        return name;
    }
    else {
        return name + extension;
    }
}
exports.makeFilename = makeFilename;
exports.makeTimer = util_1.default.promisify(timers_1.setTimeout);
function removeLibraries(settings, alsoRemoveCompilationTarget = false) {
    let copySettings = Object.assign({}, settings);
    delete copySettings.libraries;
    if (alsoRemoveCompilationTarget) {
        delete copySettings.compilationTarget;
    }
    return copySettings;
}
exports.removeLibraries = removeLibraries;
class InvalidNetworkError extends Error {
    constructor(networkId, fetcherName) {
        super(`Invalid network ID ${networkId} for fetcher ${fetcherName}`);
        this.networkId = networkId;
        this.fetcherName = fetcherName;
        this.name = "InvalidNetworkError";
    }
}
exports.InvalidNetworkError = InvalidNetworkError;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 574578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("source-fetcher:etherscan");
// untyped import since no @types/web3-utils exists
const Web3Utils = __webpack_require__(118269);
const common_1 = __webpack_require__(571103);
const networks_1 = __webpack_require__(200367);
const axios_1 = __importDefault(__webpack_require__(409669));
const async_retry_1 = __importDefault(__webpack_require__(972047));
const etherscanCommentHeader = `/**
 *Submitted for verification at Etherscan.io on 20XX-XX-XX
*/

`; //note we include that final newline
//this looks awkward but the TS docs actually suggest this :P
const EtherscanFetcher = (_a = class EtherscanFetcher {
        constructor(networkId, apiKey = "") {
            const networkName = networks_1.networkNamesById[networkId];
            if (networkName === undefined ||
                !(networkName in EtherscanFetcher.apiDomainsByNetworkName)) {
                throw new common_1.InvalidNetworkError(networkId, "etherscan");
            }
            this.networkName = networkName;
            debug("apiKey: %s", apiKey);
            this.apiKey = apiKey;
            const baseDelay = this.apiKey ? 200 : 3000; //etherscan permits 5 requests/sec w/a key, 1/3sec w/o
            const safetyFactor = 1; //no safety factor atm
            this.delay = baseDelay * safetyFactor;
            this.ready = common_1.makeTimer(0); //at start, it's ready to go immediately
        }
        static get fetcherName() {
            return "etherscan";
        }
        get fetcherName() {
            return EtherscanFetcher.fetcherName;
        }
        static forNetworkId(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                debug("options: %O", options);
                debug("id:", id);
                return new EtherscanFetcher(id, options ? options.apiKey : "");
            });
        }
        static getSupportedNetworks() {
            return Object.fromEntries(Object.entries(networks_1.networksByName).filter(([name, _]) => name in EtherscanFetcher.apiDomainsByNetworkName));
        }
        fetchSourcesForAddress(address) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.getSuccessfulResponse(address);
                return EtherscanFetcher.processResult(response.result[0]);
            });
        }
        getSuccessfulResponse(address) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialTimeoutFactor = 1.5; //I guess?
                return yield async_retry_1.default(() => __awaiter(this, void 0, void 0, function* () { return yield this.makeRequest(address); }), {
                    retries: 3,
                    minTimeout: this.delay * initialTimeoutFactor
                });
            });
        }
        determineUrl() {
            const domain = EtherscanFetcher.apiDomainsByNetworkName[this.networkName];
            return `https://${domain}/api`;
        }
        makeRequest(address) {
            return __awaiter(this, void 0, void 0, function* () {
                //not putting a try/catch around this; if it throws, we throw
                yield this.ready;
                const responsePromise = axios_1.default.get(this.determineUrl(), {
                    params: {
                        module: "contract",
                        action: "getsourcecode",
                        address,
                        apikey: this.apiKey
                    },
                    responseType: "json",
                    maxRedirects: 50
                });
                this.ready = common_1.makeTimer(this.delay);
                const response = (yield responsePromise).data;
                if (response.status === "0") {
                    throw new Error(response.result);
                }
                return response;
            });
        }
        static processResult(result) {
            //we have 5 cases here.
            //case 1: the address doesn't exist
            if (result.SourceCode === "" &&
                result.ABI === "Contract source code not verified") {
                return null;
            }
            //case 2: it's a Vyper contract
            if (result.CompilerVersion.startsWith("vyper:")) {
                return this.processVyperResult(result);
            }
            let multifileJson;
            try {
                //try to parse the source JSON.  if it succeeds,
                //we're in the multi-file case.
                multifileJson = JSON.parse(result.SourceCode);
            }
            catch (_) {
                //otherwise, we could be single-file or we could be full JSON.
                //for full JSON input, etherscan will stick an extra pair of braces around it
                if (result.SourceCode.startsWith("{") &&
                    result.SourceCode.endsWith("}")) {
                    const trimmedSource = result.SourceCode.slice(1).slice(0, -1); //remove braces
                    let fullJson;
                    try {
                        fullJson = JSON.parse(trimmedSource);
                    }
                    catch (_) {
                        //if it still doesn't parse, it's single-source I guess?
                        //(note: we shouldn't really end up here?)
                        debug("single-file input??");
                        return this.processSingleResult(result);
                    }
                    //case 5: full JSON input
                    debug("json input");
                    return this.processJsonResult(result, fullJson);
                }
                //case 3 (the way it should happen): single source
                debug("single-file input");
                return this.processSingleResult(result);
            }
            //case 4: multiple sources
            debug("multi-file input");
            return this.processMultiResult(result, multifileJson);
        }
        static processSingleResult(result) {
            const filename = common_1.makeFilename(result.ContractName);
            return {
                contractName: result.ContractName,
                sources: {
                    //we prepend this header comment so that line numbers in the debugger
                    //will match up with what's displayed on the website; note that other
                    //cases don't display a similar header on the website
                    [filename]: etherscanCommentHeader + result.SourceCode
                },
                options: {
                    language: "Solidity",
                    version: result.CompilerVersion,
                    settings: this.extractSettings(result),
                    specializations: {
                        libraries: this.processLibraries(result.Library),
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processMultiResult(result, sources) {
            return {
                contractName: result.ContractName,
                sources: this.processSources(sources),
                options: {
                    language: "Solidity",
                    version: result.CompilerVersion,
                    settings: this.extractSettings(result),
                    specializations: {
                        libraries: this.processLibraries(result.Library),
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processJsonResult(result, jsonInput) {
            return {
                contractName: result.ContractName,
                sources: this.processSources(jsonInput.sources),
                options: {
                    language: jsonInput.language,
                    version: result.CompilerVersion,
                    settings: common_1.removeLibraries(jsonInput.settings),
                    specializations: {
                        libraries: jsonInput.settings.libraries,
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processVyperResult(result) {
            const filename = common_1.makeFilename(result.ContractName, ".vy");
            //note: this means filename will always be Vyper_contract.vy
            return {
                sources: {
                    [filename]: result.SourceCode
                },
                options: {
                    language: "Vyper",
                    version: result.CompilerVersion.replace(/^vyper:/, ""),
                    settings: this.extractVyperSettings(result),
                    specializations: {
                        constructorArguments: result.ConstructorArguments
                    }
                }
            };
        }
        static processSources(sources) {
            return Object.assign({}, ...Object.entries(sources).map(([path, { content: source }]) => ({
                [common_1.makeFilename(path)]: source
            })));
        }
        static extractSettings(result) {
            const evmVersion = result.EVMVersion === "Default" ? undefined : result.EVMVersion;
            const optimizer = {
                enabled: result.OptimizationUsed === "1",
                runs: parseInt(result.Runs)
            };
            //old version got libraries here, but we don't actually want that!
            if (evmVersion !== undefined) {
                return {
                    optimizer,
                    evmVersion
                };
            }
            else {
                return {
                    optimizer
                };
            }
        }
        static processLibraries(librariesString) {
            let libraries;
            if (librariesString === "") {
                libraries = {};
            }
            else {
                libraries = Object.assign({}, ...librariesString.split(";").map(pair => {
                    const [name, address] = pair.split(":");
                    return { [name]: Web3Utils.toChecksumAddress(address) };
                }));
            }
            return { "": libraries }; //empty string as key means it applies to all contracts
        }
        static extractVyperSettings(result) {
            const evmVersion = result.EVMVersion === "Default" ? undefined : result.EVMVersion;
            //the optimize flag is not currently supported by etherscan;
            //any Vyper contract currently verified on etherscan necessarily has
            //optimize flag left unspecified (and therefore effectively true).
            //do NOT look at OptimizationUsed for Vyper contracts; it will always
            //be "0" even though in fact optimization *was* used.  just leave
            //the optimize flag unspecified.
            if (evmVersion !== undefined) {
                return { evmVersion };
            }
            else {
                return {};
            }
        }
    },
    //then, afterwards, start a new timer.
    _a.apiDomainsByNetworkName = {
        "mainnet": "api.etherscan.io",
        "ropsten": "api-ropsten.etherscan.io",
        "kovan": "api-kovan.etherscan.io",
        "rinkeby": "api-rinkeby.etherscan.io",
        "goerli": "api-goerli.etherscan.io",
        "optimistic": "api-optimistic.etherscan.io",
        "kovan-optimistic": "api-kovan-optimistic.etherscan.io",
        "arbitrum": "api.arbiscan.io",
        "rinkeby-arbitrum": "api-testnet.arbiscan.io",
        "polygon": "api.polygonscan.com",
        "mumbai-polygon": "api-mumbai.polygonscan.com",
        "binance": "api.bscscan.com",
        "testnet-binance": "api-testnet.bscscan.com",
        "fantom": "api.ftmscan.com",
        "testnet-fantom": "api-testnet.ftmscan.com",
        "avalanche": "api.snowtrace.io",
        "fuji-avalanche": "api-testnet.snowtrace.io",
        "heco": "api.hecoinfo.com",
        "testnet-heco": "api-testnet.hecoinfo.com",
        "moonbeam": "api-moonbeam.moonscan.io",
        "moonriver": "api-moonriver.moonscan.io",
        "moonbase-alpha": "api-moonbase.moonscan.io",
        "hoo": "api.hooscan.com",
        "cronos": "api.cronoscan.com",
        "testnet-cronos": "api-testnet.cronoscan.com",
        "bttc": "api.bttcscan.com",
        "donau-bttc": "api-testnet.bttcscan.com",
        "aurora": "api.aurorascan.dev",
        "testnet-aurora": "api-testnet.aurorascan.dev",
        "celo": "api.celoscan.xyz",
        "alfajores-celo": "api-alfajores.celoscan.xyz",
        "clover": "api.clvscan.com"
    },
    _a);
exports["default"] = EtherscanFetcher;
//# sourceMappingURL=etherscan.js.map

/***/ }),

/***/ 887031:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidNetworkError = void 0;
const common_1 = __webpack_require__(571103);
Object.defineProperty(exports, "InvalidNetworkError", ({ enumerable: true, get: function () { return common_1.InvalidNetworkError; } }));
const etherscan_1 = __importDefault(__webpack_require__(574578));
const sourcify_1 = __importDefault(__webpack_require__(711284));
const Fetchers = [etherscan_1.default, sourcify_1.default];
exports["default"] = Fetchers;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 200367:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.networksByName = exports.networkNamesById = void 0;
exports.networkNamesById = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan",
    11155111: "sepolia",
    10: "optimistic",
    69: "kovan-optimistic",
    42161: "arbitrum",
    421611: "rinkeby-arbitrum",
    137: "polygon",
    80001: "mumbai-polygon",
    100: "xdai",
    99: "poa",
    77: "sokol-poa",
    56: "binance",
    97: "testnet-binance",
    42220: "celo",
    44787: "alfajores-celo",
    62320: "baklava-celo",
    43114: "avalanche",
    43113: "fuji-avalanche",
    11111: "wagmi-avalanche",
    40: "telos",
    41: "testnet-telos",
    8: "ubiq",
    311752642: "oneledger",
    4216137055: "frankenstein-oneledger",
    57: "syscoin",
    5700: "tanenbaum-syscoin",
    288: "boba",
    28: "rinkeby-boba",
    106: "velas",
    82: "meter",
    83: "testnet-meter",
    1313161554: "aurora",
    1313161555: "testnet-aurora",
    250: "fantom",
    4002: "testnet-fantom",
    128: "heco",
    256: "testnet-heco",
    1284: "moonbeam",
    1285: "moonriver",
    1287: "moonbase-alpha",
    122: "fuse",
    11297108109: "palm",
    11297108099: "testnet-palm",
    70: "hoo",
    25: "cronos",
    338: "testnet-cronos",
    199: "bttc",
    1029: "donau-bttc",
    1024: "clover",
    44: "crab-darwinia",
    43: "pangolin-darwinia",
    9001: "evmos",
    9000: "testnet-evmos",
    62621: "multivac"
};
exports.networksByName = Object.fromEntries(Object.entries(exports.networkNamesById).map(([id, name]) => [name, { name, networkId: Number(id), chainId: Number(id) }] //id is a string since it's a key so must use Number()
));
//# sourceMappingURL=networks.js.map

/***/ }),

/***/ 711284:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("source-fetcher:sourcify");
const common_1 = __webpack_require__(571103);
const networks_1 = __webpack_require__(200367);
const axios_1 = __importDefault(__webpack_require__(409669));
const async_retry_1 = __importDefault(__webpack_require__(972047));
//this looks awkward but the TS docs actually suggest this :P
const SourcifyFetcher = (_a = class SourcifyFetcher {
        constructor(networkId) {
            //but may be in the future
            this.domain = "repo.sourcify.dev";
            this.networkId = networkId;
            this.networkName = networks_1.networkNamesById[networkId];
            if (this.networkName === undefined ||
                !SourcifyFetcher.supportedNetworks.has(this.networkName)) {
                throw new common_1.InvalidNetworkError(networkId, "sourcify");
            }
        }
        static get fetcherName() {
            return "sourcify";
        }
        get fetcherName() {
            return SourcifyFetcher.fetcherName;
        }
        static forNetworkId(id, _options) {
            return __awaiter(this, void 0, void 0, function* () {
                //in the future, we may add protocol and node options,
                //but these don't exist yet
                return new SourcifyFetcher(id);
            });
        }
        static getSupportedNetworks() {
            return Object.fromEntries(Object.entries(networks_1.networksByName).filter(([name, _]) => SourcifyFetcher.supportedNetworks.has(name)));
        }
        fetchSourcesForAddress(address) {
            return __awaiter(this, void 0, void 0, function* () {
                let result = yield this.fetchSourcesForAddressAndMatchType(address, "full");
                if (!result) {
                    //if we got nothing when trying a full match, try for a partial match
                    result = yield this.fetchSourcesForAddressAndMatchType(address, "partial");
                }
                //if partial match also fails, just return null
                return result;
            });
        }
        fetchSourcesForAddressAndMatchType(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                const metadata = yield this.getMetadata(address, matchType);
                debug("metadata: %O", metadata);
                if (!metadata) {
                    debug("no metadata");
                    return null;
                }
                let sources;
                sources = Object.assign({}, ...(yield Promise.all(Object.entries(metadata.sources).map(([sourcePath, { content: source }]) => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        [sourcePath]: source !== undefined
                            ? source //sourcify doesn't support this yet but they're planning it
                            : yield this.getSource(address, sourcePath, matchType)
                    });
                })))));
                const constructorArguments = yield this.getConstructorArgs(address, matchType);
                debug("compilationTarget: %O", metadata.settings.compilationTarget);
                return {
                    contractName: Object.values(metadata.settings.compilationTarget)[0],
                    sources,
                    options: {
                        language: metadata.language,
                        version: metadata.compiler.version,
                        //we also pass the flag to remove compilationTarget, as its
                        //presence can cause compile errors
                        settings: common_1.removeLibraries(metadata.settings, true),
                        specializations: {
                            constructorArguments,
                            libraries: metadata.settings.libraries
                        }
                    }
                };
            });
        }
        getMetadata(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.requestWithRetries({
                        url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/metadata.json`,
                        method: "get",
                        responseType: "json",
                        maxRedirects: 50
                    });
                }
                catch (error) {
                    //is this a 404 error? if so just return null
                    debug("error: %O", error);
                    if (error.response && error.response.status === 404) {
                        return null;
                    }
                    //otherwise, we've got a problem; rethrow the error
                    throw error;
                }
            });
        }
        getSource(address, sourcePath, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                //note: sourcify replaces special characters in paths with underscores
                //(special characters here being anything other than ASCII alphanumerics,
                //hyphens, periods, and forward slashes)
                const transformedSourcePath = sourcePath.replace(/[^\w.\/-]/gu, "_");
                return yield this.requestWithRetries({
                    url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/sources/${transformedSourcePath}`,
                    responseType: "text",
                    method: "get",
                    maxRedirects: 50
                });
            });
        }
        getConstructorArgs(address, matchType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const constructorArgs = yield this.requestWithRetries({
                        url: `https://${this.domain}/contracts/${matchType}_match/${this.networkId}/${address}/constructor-args.txt`,
                        method: "get",
                        responseType: "text",
                        maxRedirects: 50
                    });
                    return constructorArgs.slice(2); //remove initial "0x"
                }
                catch (error) {
                    //is this a 404 error? if so just return undefined
                    debug("error: %O", error);
                    if (error.response && error.response.status === 404) {
                        return undefined;
                    }
                    //otherwise, we've got a problem; rethrow the error
                    throw error;
                }
            });
        }
        requestWithRetries(requestObject //sorry, trying to import the type properly ran into problems
        ) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield async_retry_1.default((bail) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        //note: we use axios.request rather than just axios so we can stub it in tests!
                        return (yield axios_1.default.request(requestObject)).data;
                    }
                    catch (error) {
                        //check: is this a 404 error? if so give up
                        if (error.response && error.response.status === 404) {
                            bail(error); //don't retry
                        }
                        else {
                            throw error; //retry
                        }
                    }
                }), { retries: 3 } //leaving minTimeout as default 1000
                );
            });
        }
    },
    _a.supportedNetworks = new Set([
        "mainnet",
        "ropsten",
        "kovan",
        "rinkeby",
        "goerli",
        "kovan",
        "sepolia",
        "optimistic",
        "kovan-optimistic",
        "arbitrum",
        "rinkeby-arbitrum",
        "polygon",
        "mumbai-polygon",
        "xdai",
        //sourcify does *not* support poa core...?
        "sokol-poa",
        "binance",
        "testnet-binance",
        "celo",
        "alfajores-celo",
        "baklava-celo",
        "avalanche",
        "fuji-avalanche",
        "wagmi-avalanche",
        "telos",
        "testnet-telos",
        "ubiq",
        "oneledger",
        "frankenstein-oneledger",
        "syscoin",
        "tanenbaum-syscoin",
        "boba",
        "rinkeby-boba",
        "velas",
        "meter",
        "testnet-meter",
        "aurora",
        "testnet-aurora",
        "fuse",
        "moonbeam",
        "moonriver",
        "moonbase-alpha",
        "palm",
        "testnet-palm",
        "crab-darwinia",
        "pangolin-darwinia",
        "evmos",
        "testnet-evmos",
        "multivac"
    ]),
    _a);
exports["default"] = SourcifyFetcher;
//# sourceMappingURL=sourcify.js.map

/***/ }),

/***/ 832731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("source-map-utils");
const CodeUtils = __webpack_require__(908135);
const Codec = __webpack_require__(20102);
const Web3Utils = __webpack_require__(118269);
const jsonpointer = __webpack_require__(883573);
const IntervalTree = (__webpack_require__(891501)/* ["default"] */ .ZP);

var SourceMapUtils = {
  getCharacterOffsetToLineAndColumnMapping: function (source) {
    var mapping = [];

    source = Array.from(source); //note: this will correctly handle
    //surrogate pairs, but there's still the problem of grapheme
    //clusters!  We should do something about that later.

    var line = 0;
    var column = 0;

    source.forEach(function (character) {
      if (character === "\n") {
        line += 1;
        column = -1;

        mapping.push({
          line: line,
          column: 0
        });
      } else {
        mapping.push({
          line: line,
          column: column
        });
      }

      column += 1;
    });

    return mapping;
  },

  getHumanReadableSourceMap: function (sourceMap) {
    const instructions = sourceMap.split(";");

    let processedInstruction = {
      start: 0,
      length: 0,
      file: 0
    }; //persists across instructions for when info doesn't change
    let processedSourceMap = [];

    //JS doesn't have scan, so we'll do this scan manually
    for (let instruction of instructions) {
      let splitInstruction = instruction.split(":");

      //note: if(splitInstruction[i]) checks both that there are
      //at least that many fields, and that that particular field
      //is nonempty

      if (splitInstruction[0]) {
        processedInstruction.start = parseInt(splitInstruction[0]);
      }

      if (splitInstruction[1]) {
        processedInstruction.length = parseInt(splitInstruction[1]);
      }

      if (splitInstruction[2]) {
        processedInstruction.file = parseInt(splitInstruction[2]);
      }

      if (splitInstruction[3]) {
        processedInstruction.jump = splitInstruction[3];
      }

      if (splitInstruction[4]) {
        processedInstruction.modifierDepth = parseInt(splitInstruction[4]);
      }

      //we need to clone before pushing so that the array won't contain a
      //bunch of copies of the same thing.  unfortunately, we don't have
      //babel here, so we need to clone a bit manually.
      let clonedProcessedInstruction = {
        start: processedInstruction.start,
        length: processedInstruction.length,
        file: processedInstruction.file,
        jump: processedInstruction.jump,
        modifierDepth: processedInstruction.modifierDepth
      };

      processedSourceMap.push(clonedProcessedInstruction);
    }

    return processedSourceMap;
  },

  //sources: array of text sources (must be in order!)
  //binary: raw binary to process.  should not have unresolved links.
  //sourceMap: a processed source map as output by getHumanReadableSourceMap above
  //we... attempt to muddle through.
  getProcessedInstructionsForBinary: function (sources, binary, sourceMap) {
    if (!sources || !binary) {
      return [];
    }
    debug("sourceMap: %O", sourceMap);

    let numInstructions;
    if (sourceMap) {
      numInstructions = sourceMap.length;
    }

    //because we might be dealing with a constructor with arguments, we do
    //*not* remove metadata manually
    let instructions = CodeUtils.parseCode(binary, numInstructions);

    if (!sourceMap) {
      // HACK
      // Let's create a source map to use since none exists. This source
      // map maps just as many ranges as there are instructions (or
      // possibly more), and marks them all as being Solidity-internal and
      // not jumps.
      sourceMap = new Array(instructions.length);
      sourceMap.fill({
        start: 0,
        length: 0,
        file: -1,
        jump: "-",
        modifierDepth: "0"
      });
    }

    const lineAndColumnMappings = sources.map(source =>
      SourceMapUtils.getCharacterOffsetToLineAndColumnMapping(source || "")
    );

    let primaryFile;
    if (sourceMap[0]) {
      primaryFile = sourceMap[0].file;
    }
    debug("primaryFile %o", primaryFile);

    return instructions
      .map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const instructionSourceMap = sourceMap[index] || {};

        instruction.index = index; //should be fine to modify this

        return {
          instruction,
          instructionSourceMap
        };
      })
      .map(({ instruction, instructionSourceMap }) => {
        // add source map information to instruction, or defaults

        //I think it is also OK to modify instruction here
        ({
          jump: instruction.jump,
          start: instruction.start = 0,
          length: instruction.length = 0,
          file: instruction.file = primaryFile,
          modifierDepth: instruction.modifierDepth = 0
        } = instructionSourceMap);
        if (instruction.start === -1 && instruction.length === -1) {
          instruction.start = 0;
          instruction.length = 0;
        }
        const lineAndColumnMapping =
          lineAndColumnMappings[instruction.file] || {};
        instruction.range = {
          start: lineAndColumnMapping[instruction.start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[instruction.start + instruction.length] || {
            line: null,
            column: null
          }
        };

        return instruction;
      });
  },

  //instructions: as output by the function above
  //asts: array of abstract syntax trees for the sources. must be in order!
  //overlapFunctions: an array of functions -- each one corresponding to the AST of the same index --
  //that, given a start index and a length, will search for all nodes in that AST overlapping the
  //given range, and will return an array of objects with fields node and pointer; node should
  //be the corresponding node, and pointer a jsonpointer to it (from the AST root)
  //compilationId: what it says.  the function will work fine without it.
  getFunctionsByProgramCounter: function (
    instructions,
    asts,
    overlapFunctions,
    compilationId
  ) {
    return Object.assign(
      {},
      ...instructions
        .filter(instruction => instruction.name === "JUMPDEST")
        .map(instruction => {
          debug("instruction %O", instruction);
          const sourceIndex = instruction.file;
          //first off, a special case: if the file is -1, check for designated
          //invalid and if it's not that give up
          //(designated invalid gets file -1 in some Solidity versions)
          if (sourceIndex === -1) {
            if (
              SourceMapUtils.isDesignatedInvalid(
                instructions,
                instruction.index,
                overlapFunctions
              )
            ) {
              //designated invalid, include it
              return {
                [instruction.pc]: {
                  isDesignatedInvalid: true
                }
              };
            } else {
              //not designated invalid, filter it out
              return {};
            }
          }
          //now we proceed with the normal case
          const findOverlappingRange = overlapFunctions[sourceIndex];
          const ast = asts[sourceIndex];
          if (!ast) {
            //if we can't get the ast... filter it out I guess
            return {};
          }
          const range = SourceMapUtils.getSourceRange(instruction);
          let { node, pointer } = SourceMapUtils.findRange(
            findOverlappingRange,
            range.start,
            range.length
          );
          if (!pointer) {
            node = ast;
          }
          if (!node || node.nodeType !== "FunctionDefinition") {
            //filter out JUMPDESTs that aren't function definitions...
            //except for the designated invalid function
            if (
              SourceMapUtils.isDesignatedInvalid(
                instructions,
                instruction.index,
                overlapFunctions,
                node
              )
            ) {
              //designated invalid, include it
              return {
                [instruction.pc]: {
                  isDesignatedInvalid: true
                }
              };
            } else {
              //not designated invalid, filter it out
              return {};
            }
          }
          //otherwise, we're good to go, so let's find the contract node and
          //put it all together
          //to get the contract node, we go up twice from the function node;
          //the path from one to the other should have a very specific form,
          //so this is easy
          let contractPointer = pointer.replace(/\/nodes\/\d+$/, "");
          let contractNode = jsonpointer.get(ast, contractPointer);
          if (contractNode.nodeType !== "ContractDefinition") {
            //if it's a free function, there is no contract pointer or contract node
            contractPointer = null;
            contractNode = null;
          }
          return {
            [instruction.pc]: {
              sourceIndex,
              compilationId,
              //note: we're assuming that functions in generated sources are never pointed to
              pointer,
              node,
              name: node.name,
              id: node.id,
              mutability: Codec.Ast.Utils.mutability(node),
              contractPointer,
              contractNode,
              contractName: contractNode ? contractNode.name : null,
              contractId: contractNode ? contractNode.id : null,
              contractKind: contractNode ? contractNode.contractKind : null,
              contractPayable: contractNode
                ? Codec.Ast.Utils.isContractPayable(contractNode)
                : null,
              isDesignatedInvalid: false
            }
          };
        })
    );
  },

  getSourceRange: function (instruction = {}) {
    return {
      start: instruction.start || 0,
      length: instruction.length || 0,
      lines: instruction.range || {
        start: {
          line: 0,
          column: 0
        },
        end: {
          line: 0,
          column: 0
        }
      }
    };
  },

  //findOverlappingRange should be as described above
  findRange: function (findOverlappingRange, sourceStart, sourceLength) {
    // find nodes that fully contain requested range,
    // return one with longest pointer
    // (note: returns { range, node, pointer }
    let sourceEnd = sourceStart + sourceLength;
    let pointerLength = pointer => (pointer.match(/\//g) || []).length; //counts number of slashes in ptr
    return findOverlappingRange(sourceStart, sourceLength)
      .filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1])
      .reduce(
        (acc, cur) =>
          pointerLength(cur.pointer) >= pointerLength(acc.pointer) ? cur : acc,
        { pointer: "" }
      );
    //note we make sure to bias towards cur (the new value being compared) rather than acc (the old value)
    //so that we don't actually get {pointer: ""} as our result
  },

  //makes the overlap function for an AST
  makeOverlapFunction: function (ast) {
    let tree = new IntervalTree();
    let ranges = SourceMapUtils.rangeNodes(ast);
    for (let { range, node, pointer } of ranges) {
      let [start, end] = range;
      tree.insert(start, end, { range, node, pointer });
    }
    return (sourceStart, sourceLength) =>
      tree.search(sourceStart, sourceStart + sourceLength);
  },

  //for use by makeOverlapFunction
  rangeNodes: function (node, pointer = "") {
    if (node instanceof Array) {
      return [].concat(
        ...node.map((sub, i) =>
          SourceMapUtils.rangeNodes(sub, `${pointer}/${i}`)
        )
      );
    } else if (node instanceof Object) {
      let results = [];

      if (node.src !== undefined && node.nodeType !== undefined) {
        //don't add "pseudo-nodes" (i.e.: outside variable references
        //in assembly) with no nodeType
        results.push({ pointer, node, range: SourceMapUtils.getRange(node) });
      }

      return results.concat(
        ...Object.keys(node).map(key =>
          SourceMapUtils.rangeNodes(node[key], `${pointer}/${key}`)
        )
      );
    } else {
      return [];
    }
  },

  getRange: function (node) {
    // src: "<start>:<length>:<_>"
    // returns [start, end]
    let [start, length] = node.src
      .split(":")
      .slice(0, 2)
      .map(i => parseInt(i));

    return [start, start + length];
  },

  //takes an array of instructions & an index into it
  //and asks: is this index the start of this instruction array the
  //start of a Solidity designated invalid function?
  //i.e. what an uninitialized internal function pointer jumps to?
  isDesignatedInvalid: function (
    instructions,
    index,
    overlapFunctions,
    node = undefined
  ) {
    const oldSequence = [{ name: "JUMPDEST" }, { name: "INVALID" }];
    const panicSelector = Web3Utils.soliditySha3({
      type: "string",
      value: "Panic(uint256)"
    }).slice(0, 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE);
    const paddedSelector = panicSelector.padEnd(
      2 + 2 * Codec.Evm.Utils.WORD_SIZE,
      "00"
    );
    //we double and add 2 because we're using hex strings...
    const newSequence = [
      { name: "JUMPDEST" },
      { name: "PUSH32", pushData: paddedSelector },
      { name: "PUSH1", pushData: "0x00" },
      { name: "MSTORE" },
      { name: "PUSH1", pushData: "0x51" },
      { name: "PUSH1", pushData: "0x04" },
      { name: "MSTORE" },
      { name: "PUSH1", pushData: "0x24" },
      { name: "PUSH1", pushData: "0x00" },
      { name: "REVERT" }
    ];

    const checkAgainstTemplate = (instructions, index, template) => {
      for (let offset = 0; offset < template.length; offset++) {
        const instruction = instructions[index + offset];
        const comparison = template[offset];
        if (!instruction || instruction.name !== comparison.name) {
          return false;
        }
        if (
          comparison.pushData &&
          instruction.pushData !== comparison.pushData
        ) {
          return false;
        }
      }
      return true;
    };

    //gets the final pushdata in a JUMPDEST, PUSH, [PUSH,] JUMP sequence;
    //returns null if the code is not of that form
    const getIndirectAddress = (instructions, startingIndex) => {
      let index = startingIndex;
      if (instructions[index].name !== "JUMPDEST") {
        return null;
      }
      index++;
      while (instructions[index].name.match(/^PUSH\d*/)) {
        index++;
        if (index > startingIndex + 3) {
          //check: are there more than 2 PUSHes?
          return null;
        }
      }
      if (instructions[index].name === "JUMP") {
        if (index === startingIndex + 1) {
          //check: was there at least one push?
          return null;
        }
        index--;
        return parseInt(instructions[index].pushData);
      } else {
        return null;
      }
    };

    //if it matches either direct template, return true
    if (
      checkAgainstTemplate(instructions, index, oldSequence) ||
      checkAgainstTemplate(instructions, index, newSequence)
    ) {
      return true;
    }

    //if it's panic_error_0x51, return true
    if (
      node &&
      node.nodeType === "YulFunctionDefinition" &&
      node.name === "panic_error_0x51"
    ) {
      return true;
    }

    //otherwise, check if it's indirect for the new template
    //(or for panic_error_0x51)
    const jumpAddress = getIndirectAddress(instructions, index);
    if (jumpAddress !== null) {
      const jumpIndex = instructions.findIndex(
        instruction => instruction.pc === jumpAddress
      );
      if (checkAgainstTemplate(instructions, jumpIndex, newSequence)) {
        return true;
      }
      debug("indirect: %O", instructions.slice(index, index + 4));
      debug("jumpAddress: %d", jumpAddress);
      debug("jumpIndex: %d", jumpIndex);
      debug("instr count: %d", instructions.length);
      const jumpInstruction = instructions[jumpIndex];
      const jumpFile = jumpInstruction.file;
      if (jumpFile !== -1) {
        const findOverlappingRange = overlapFunctions[jumpFile];
        const range = SourceMapUtils.getSourceRange(jumpInstruction);
        const { node: jumpNode } = SourceMapUtils.findRange(
          findOverlappingRange,
          range.start,
          range.length
        );
        if (
          jumpNode &&
          jumpNode.nodeType === "YulFunctionDefinition" &&
          jumpNode.name === "panic_error_0x51"
        ) {
          return true;
        }
      }
    }

    //otherwise, return false
    return false;
  }
};

module.exports = SourceMapUtils;


/***/ }),

/***/ 577135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(615158)("workflow-compile");
const fse = __webpack_require__(655674);
const { prepareConfig } = __webpack_require__(991671);
const { Shims } = __webpack_require__(529833);
const { getTruffleDb } = __webpack_require__(570972);

const SUPPORTED_COMPILERS = {
  solc: (__webpack_require__(4273).Compile),
  vyper: (__webpack_require__(874269).Compile),
  external: (__webpack_require__(296412).Compile)
};

async function compile(config) {
  // determine compiler(s) to use
  //
  const compilers = config.compiler
    ? config.compiler === "none"
      ? []
      : [config.compiler]
    : Object.keys(config.compilers);

  // invoke compilers
  //
  const rawCompilations = await Promise.all(
    compilers.map(async name => {
      const Compile = SUPPORTED_COMPILERS[name];
      if (!Compile) throw new Error("Unsupported compiler: " + name);

      if (config.all === true || config.compileAll === true) {
        return await Compile.all(config);
      } else if (Array.isArray(config.paths) && config.paths.length > 0) {
        // compile only user specified sources
        return await Compile.sourcesWithDependencies({
          options: config,
          paths: config.paths
        });
      } else {
        return await Compile.necessary(config);
      }
    })
  );

  // collect results - rawCompilations is CompilerResult[]
  // flatten the array and remove compilations without results
  const compilations = rawCompilations.reduce((a, compilerResult) => {
    compilerResult.compilations.forEach(compilation => {
      if (compilation.contracts.length > 0) {
        a = a.concat(compilation);
      }
    });
    return a;
  }, []);

  // collect together contracts as well as compilations
  const contracts = rawCompilations.flatMap(
    compilerResult => compilerResult.contracts
  );

  // return WorkflowCompileResult
  return { contracts, compilations };
}

const WorkflowCompile = {
  async compile(options) {
    const config = prepareConfig(options);

    if (config.events) config.events.emit("compile:start");

    const { contracts, compilations } = await compile(config);

    const compilers = compilations
      .reduce((a, compilation) => {
        return a.concat(compilation.compiler);
      }, [])
      .filter(compiler => compiler);

    if (contracts.length === 0 && config.events) {
      if (config.compileNone || config["compile-none"]) {
        config.events.emit("compile:skipped");
      } else {
        config.events.emit("compile:nothingToCompile");
      }
    }

    if (config.events) {
      config.events.emit("compile:succeed", {
        contractsBuildDirectory: config.contracts_build_directory,
        compilers
      });
    }

    return {
      contracts,
      compilations
    };
  },

  async compileAndSave(options) {
    const { contracts, compilations } = await this.compile(options);

    return await this.save(options, { contracts, compilations });
  },

  async save(options, { contracts, compilations }) {
    const config = prepareConfig(options);

    await fse.ensureDir(config.contracts_build_directory);

    if (options.db && options.db.enabled === true && contracts.length > 0) {
      // currently if Truffle Db fails to load, getTruffleDb returns `null`
      const Db = getTruffleDb();

      if (Db) {
        debug("saving to @truffle/db");
        const db = Db.connect(config.db);
        const project = await Db.Project.initialize({
          db,
          project: {
            directory: config.working_directory
          }
        });
        ({ contracts, compilations } = await project.loadCompile({
          result: { contracts, compilations }
        }));
      }
    }

    const artifacts = contracts.map(Shims.NewToLegacy.forContract);
    await config.artifactor.saveAll(artifacts);

    return { contracts, compilations };
  },

  async assignNames(options, { contracts }) {
    // currently if Truffle Db fails to load, getTruffleDb returns `null`
    const Db = getTruffleDb();

    const config = prepareConfig(options);

    if (!Db || !config.db || !config.db.enabled || contracts.length === 0) {
      return;
    }

    const db = Db.connect(config.db);
    const project = await Db.Project.initialize({
      db,
      project: {
        directory: config.working_directory
      }
    });

    await project.assignNames({
      assignments: {
        contracts: contracts.map(({ db: { contract } }) => contract)
      }
    });
  }
};

module.exports = WorkflowCompile;


/***/ }),

/***/ 991671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(120553);
const expect = __webpack_require__(414096);
const { Resolver } = __webpack_require__(648511);
const Artifactor = __webpack_require__(529463);

function prepareConfig(options) {
  expect.options(options, ["contracts_build_directory"]);

  expect.one(options, ["contracts_directory", "files"]);

  // Use a config object to ensure we get the default sources.
  const config = Config.default().merge(options);

  config.compilersInfo = {};

  if (!config.resolver) config.resolver = new Resolver(config);

  if (!config.artifactor) {
    config.artifactor = new Artifactor(config.contracts_build_directory);
  }

  return config;
}

function multiPromisify(func) {
  return (...args) =>
    new Promise((accept, reject) => {
      const callback = (err, ...results) => {
        if (err) reject(err);

        accept(results);
      };

      func(...args, callback);
    });
}

module.exports = {
  prepareConfig,
  multiPromisify
};


/***/ }),

/***/ 723373:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"3.4.7"};

/***/ }),

/***/ 900:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"abi.spec.json","$schema":"http://json-schema.org/schema#","title":"ABI","type":"array","items":{"oneOf":[{"$ref":"#/definitions/Event"},{"$ref":"#/definitions/Error"},{"$ref":"#/definitions/ConstructorFunction"},{"$ref":"#/definitions/FallbackFunction"},{"$ref":"#/definitions/ReceiveFunction"},{"$ref":"#/definitions/NormalFunction"}]},"definitions":{"Name":{"type":"string","pattern":"^$|^[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*$"},"Type":{"oneOf":[{"type":"string","pattern":"^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^address(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bool(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^u?fixed(8x1|8x2|8x3|8x4|8x5|8x6|8x7|8x8|8x9|8x10|8x11|8x12|8x13|8x14|8x15|8x16|8x17|8x18|8x19|8x20|8x21|8x22|8x23|8x24|8x25|8x26|8x27|8x28|8x29|8x30|8x31|8x32|8x33|8x34|8x35|8x36|8x37|8x38|8x39|8x40|8x41|8x42|8x43|8x44|8x45|8x46|8x47|8x48|8x49|8x50|8x51|8x52|8x53|8x54|8x55|8x56|8x57|8x58|8x59|8x60|8x61|8x62|8x63|8x64|8x65|8x66|8x67|8x68|8x69|8x70|8x71|8x72|8x73|8x74|8x75|8x76|8x77|8x78|8x79|8x80|16x1|16x2|16x3|16x4|16x5|16x6|16x7|16x8|16x9|16x10|16x11|16x12|16x13|16x14|16x15|16x16|16x17|16x18|16x19|16x20|16x21|16x22|16x23|16x24|16x25|16x26|16x27|16x28|16x29|16x30|16x31|16x32|16x33|16x34|16x35|16x36|16x37|16x38|16x39|16x40|16x41|16x42|16x43|16x44|16x45|16x46|16x47|16x48|16x49|16x50|16x51|16x52|16x53|16x54|16x55|16x56|16x57|16x58|16x59|16x60|16x61|16x62|16x63|16x64|16x65|16x66|16x67|16x68|16x69|16x70|16x71|16x72|16x73|16x74|16x75|16x76|16x77|16x78|16x79|16x80|24x1|24x2|24x3|24x4|24x5|24x6|24x7|24x8|24x9|24x10|24x11|24x12|24x13|24x14|24x15|24x16|24x17|24x18|24x19|24x20|24x21|24x22|24x23|24x24|24x25|24x26|24x27|24x28|24x29|24x30|24x31|24x32|24x33|24x34|24x35|24x36|24x37|24x38|24x39|24x40|24x41|24x42|24x43|24x44|24x45|24x46|24x47|24x48|24x49|24x50|24x51|24x52|24x53|24x54|24x55|24x56|24x57|24x58|24x59|24x60|24x61|24x62|24x63|24x64|24x65|24x66|24x67|24x68|24x69|24x70|24x71|24x72|24x73|24x74|24x75|24x76|24x77|24x78|24x79|24x80|32x1|32x2|32x3|32x4|32x5|32x6|32x7|32x8|32x9|32x10|32x11|32x12|32x13|32x14|32x15|32x16|32x17|32x18|32x19|32x20|32x21|32x22|32x23|32x24|32x25|32x26|32x27|32x28|32x29|32x30|32x31|32x32|32x33|32x34|32x35|32x36|32x37|32x38|32x39|32x40|32x41|32x42|32x43|32x44|32x45|32x46|32x47|32x48|32x49|32x50|32x51|32x52|32x53|32x54|32x55|32x56|32x57|32x58|32x59|32x60|32x61|32x62|32x63|32x64|32x65|32x66|32x67|32x68|32x69|32x70|32x71|32x72|32x73|32x74|32x75|32x76|32x77|32x78|32x79|32x80|40x1|40x2|40x3|40x4|40x5|40x6|40x7|40x8|40x9|40x10|40x11|40x12|40x13|40x14|40x15|40x16|40x17|40x18|40x19|40x20|40x21|40x22|40x23|40x24|40x25|40x26|40x27|40x28|40x29|40x30|40x31|40x32|40x33|40x34|40x35|40x36|40x37|40x38|40x39|40x40|40x41|40x42|40x43|40x44|40x45|40x46|40x47|40x48|40x49|40x50|40x51|40x52|40x53|40x54|40x55|40x56|40x57|40x58|40x59|40x60|40x61|40x62|40x63|40x64|40x65|40x66|40x67|40x68|40x69|40x70|40x71|40x72|40x73|40x74|40x75|40x76|40x77|40x78|40x79|40x80|48x1|48x2|48x3|48x4|48x5|48x6|48x7|48x8|48x9|48x10|48x11|48x12|48x13|48x14|48x15|48x16|48x17|48x18|48x19|48x20|48x21|48x22|48x23|48x24|48x25|48x26|48x27|48x28|48x29|48x30|48x31|48x32|48x33|48x34|48x35|48x36|48x37|48x38|48x39|48x40|48x41|48x42|48x43|48x44|48x45|48x46|48x47|48x48|48x49|48x50|48x51|48x52|48x53|48x54|48x55|48x56|48x57|48x58|48x59|48x60|48x61|48x62|48x63|48x64|48x65|48x66|48x67|48x68|48x69|48x70|48x71|48x72|48x73|48x74|48x75|48x76|48x77|48x78|48x79|48x80|56x1|56x2|56x3|56x4|56x5|56x6|56x7|56x8|56x9|56x10|56x11|56x12|56x13|56x14|56x15|56x16|56x17|56x18|56x19|56x20|56x21|56x22|56x23|56x24|56x25|56x26|56x27|56x28|56x29|56x30|56x31|56x32|56x33|56x34|56x35|56x36|56x37|56x38|56x39|56x40|56x41|56x42|56x43|56x44|56x45|56x46|56x47|56x48|56x49|56x50|56x51|56x52|56x53|56x54|56x55|56x56|56x57|56x58|56x59|56x60|56x61|56x62|56x63|56x64|56x65|56x66|56x67|56x68|56x69|56x70|56x71|56x72|56x73|56x74|56x75|56x76|56x77|56x78|56x79|56x80|64x1|64x2|64x3|64x4|64x5|64x6|64x7|64x8|64x9|64x10|64x11|64x12|64x13|64x14|64x15|64x16|64x17|64x18|64x19|64x20|64x21|64x22|64x23|64x24|64x25|64x26|64x27|64x28|64x29|64x30|64x31|64x32|64x33|64x34|64x35|64x36|64x37|64x38|64x39|64x40|64x41|64x42|64x43|64x44|64x45|64x46|64x47|64x48|64x49|64x50|64x51|64x52|64x53|64x54|64x55|64x56|64x57|64x58|64x59|64x60|64x61|64x62|64x63|64x64|64x65|64x66|64x67|64x68|64x69|64x70|64x71|64x72|64x73|64x74|64x75|64x76|64x77|64x78|64x79|64x80|72x1|72x2|72x3|72x4|72x5|72x6|72x7|72x8|72x9|72x10|72x11|72x12|72x13|72x14|72x15|72x16|72x17|72x18|72x19|72x20|72x21|72x22|72x23|72x24|72x25|72x26|72x27|72x28|72x29|72x30|72x31|72x32|72x33|72x34|72x35|72x36|72x37|72x38|72x39|72x40|72x41|72x42|72x43|72x44|72x45|72x46|72x47|72x48|72x49|72x50|72x51|72x52|72x53|72x54|72x55|72x56|72x57|72x58|72x59|72x60|72x61|72x62|72x63|72x64|72x65|72x66|72x67|72x68|72x69|72x70|72x71|72x72|72x73|72x74|72x75|72x76|72x77|72x78|72x79|72x80|80x1|80x2|80x3|80x4|80x5|80x6|80x7|80x8|80x9|80x10|80x11|80x12|80x13|80x14|80x15|80x16|80x17|80x18|80x19|80x20|80x21|80x22|80x23|80x24|80x25|80x26|80x27|80x28|80x29|80x30|80x31|80x32|80x33|80x34|80x35|80x36|80x37|80x38|80x39|80x40|80x41|80x42|80x43|80x44|80x45|80x46|80x47|80x48|80x49|80x50|80x51|80x52|80x53|80x54|80x55|80x56|80x57|80x58|80x59|80x60|80x61|80x62|80x63|80x64|80x65|80x66|80x67|80x68|80x69|80x70|80x71|80x72|80x73|80x74|80x75|80x76|80x77|80x78|80x79|80x80|88x1|88x2|88x3|88x4|88x5|88x6|88x7|88x8|88x9|88x10|88x11|88x12|88x13|88x14|88x15|88x16|88x17|88x18|88x19|88x20|88x21|88x22|88x23|88x24|88x25|88x26|88x27|88x28|88x29|88x30|88x31|88x32|88x33|88x34|88x35|88x36|88x37|88x38|88x39|88x40|88x41|88x42|88x43|88x44|88x45|88x46|88x47|88x48|88x49|88x50|88x51|88x52|88x53|88x54|88x55|88x56|88x57|88x58|88x59|88x60|88x61|88x62|88x63|88x64|88x65|88x66|88x67|88x68|88x69|88x70|88x71|88x72|88x73|88x74|88x75|88x76|88x77|88x78|88x79|88x80|96x1|96x2|96x3|96x4|96x5|96x6|96x7|96x8|96x9|96x10|96x11|96x12|96x13|96x14|96x15|96x16|96x17|96x18|96x19|96x20|96x21|96x22|96x23|96x24|96x25|96x26|96x27|96x28|96x29|96x30|96x31|96x32|96x33|96x34|96x35|96x36|96x37|96x38|96x39|96x40|96x41|96x42|96x43|96x44|96x45|96x46|96x47|96x48|96x49|96x50|96x51|96x52|96x53|96x54|96x55|96x56|96x57|96x58|96x59|96x60|96x61|96x62|96x63|96x64|96x65|96x66|96x67|96x68|96x69|96x70|96x71|96x72|96x73|96x74|96x75|96x76|96x77|96x78|96x79|96x80|104x1|104x2|104x3|104x4|104x5|104x6|104x7|104x8|104x9|104x10|104x11|104x12|104x13|104x14|104x15|104x16|104x17|104x18|104x19|104x20|104x21|104x22|104x23|104x24|104x25|104x26|104x27|104x28|104x29|104x30|104x31|104x32|104x33|104x34|104x35|104x36|104x37|104x38|104x39|104x40|104x41|104x42|104x43|104x44|104x45|104x46|104x47|104x48|104x49|104x50|104x51|104x52|104x53|104x54|104x55|104x56|104x57|104x58|104x59|104x60|104x61|104x62|104x63|104x64|104x65|104x66|104x67|104x68|104x69|104x70|104x71|104x72|104x73|104x74|104x75|104x76|104x77|104x78|104x79|104x80|112x1|112x2|112x3|112x4|112x5|112x6|112x7|112x8|112x9|112x10|112x11|112x12|112x13|112x14|112x15|112x16|112x17|112x18|112x19|112x20|112x21|112x22|112x23|112x24|112x25|112x26|112x27|112x28|112x29|112x30|112x31|112x32|112x33|112x34|112x35|112x36|112x37|112x38|112x39|112x40|112x41|112x42|112x43|112x44|112x45|112x46|112x47|112x48|112x49|112x50|112x51|112x52|112x53|112x54|112x55|112x56|112x57|112x58|112x59|112x60|112x61|112x62|112x63|112x64|112x65|112x66|112x67|112x68|112x69|112x70|112x71|112x72|112x73|112x74|112x75|112x76|112x77|112x78|112x79|112x80|120x1|120x2|120x3|120x4|120x5|120x6|120x7|120x8|120x9|120x10|120x11|120x12|120x13|120x14|120x15|120x16|120x17|120x18|120x19|120x20|120x21|120x22|120x23|120x24|120x25|120x26|120x27|120x28|120x29|120x30|120x31|120x32|120x33|120x34|120x35|120x36|120x37|120x38|120x39|120x40|120x41|120x42|120x43|120x44|120x45|120x46|120x47|120x48|120x49|120x50|120x51|120x52|120x53|120x54|120x55|120x56|120x57|120x58|120x59|120x60|120x61|120x62|120x63|120x64|120x65|120x66|120x67|120x68|120x69|120x70|120x71|120x72|120x73|120x74|120x75|120x76|120x77|120x78|120x79|120x80|128x1|128x2|128x3|128x4|128x5|128x6|128x7|128x8|128x9|128x10|128x11|128x12|128x13|128x14|128x15|128x16|128x17|128x18|128x19|128x20|128x21|128x22|128x23|128x24|128x25|128x26|128x27|128x28|128x29|128x30|128x31|128x32|128x33|128x34|128x35|128x36|128x37|128x38|128x39|128x40|128x41|128x42|128x43|128x44|128x45|128x46|128x47|128x48|128x49|128x50|128x51|128x52|128x53|128x54|128x55|128x56|128x57|128x58|128x59|128x60|128x61|128x62|128x63|128x64|128x65|128x66|128x67|128x68|128x69|128x70|128x71|128x72|128x73|128x74|128x75|128x76|128x77|128x78|128x79|128x80|136x1|136x2|136x3|136x4|136x5|136x6|136x7|136x8|136x9|136x10|136x11|136x12|136x13|136x14|136x15|136x16|136x17|136x18|136x19|136x20|136x21|136x22|136x23|136x24|136x25|136x26|136x27|136x28|136x29|136x30|136x31|136x32|136x33|136x34|136x35|136x36|136x37|136x38|136x39|136x40|136x41|136x42|136x43|136x44|136x45|136x46|136x47|136x48|136x49|136x50|136x51|136x52|136x53|136x54|136x55|136x56|136x57|136x58|136x59|136x60|136x61|136x62|136x63|136x64|136x65|136x66|136x67|136x68|136x69|136x70|136x71|136x72|136x73|136x74|136x75|136x76|136x77|136x78|136x79|136x80|144x1|144x2|144x3|144x4|144x5|144x6|144x7|144x8|144x9|144x10|144x11|144x12|144x13|144x14|144x15|144x16|144x17|144x18|144x19|144x20|144x21|144x22|144x23|144x24|144x25|144x26|144x27|144x28|144x29|144x30|144x31|144x32|144x33|144x34|144x35|144x36|144x37|144x38|144x39|144x40|144x41|144x42|144x43|144x44|144x45|144x46|144x47|144x48|144x49|144x50|144x51|144x52|144x53|144x54|144x55|144x56|144x57|144x58|144x59|144x60|144x61|144x62|144x63|144x64|144x65|144x66|144x67|144x68|144x69|144x70|144x71|144x72|144x73|144x74|144x75|144x76|144x77|144x78|144x79|144x80|152x1|152x2|152x3|152x4|152x5|152x6|152x7|152x8|152x9|152x10|152x11|152x12|152x13|152x14|152x15|152x16|152x17|152x18|152x19|152x20|152x21|152x22|152x23|152x24|152x25|152x26|152x27|152x28|152x29|152x30|152x31|152x32|152x33|152x34|152x35|152x36|152x37|152x38|152x39|152x40|152x41|152x42|152x43|152x44|152x45|152x46|152x47|152x48|152x49|152x50|152x51|152x52|152x53|152x54|152x55|152x56|152x57|152x58|152x59|152x60|152x61|152x62|152x63|152x64|152x65|152x66|152x67|152x68|152x69|152x70|152x71|152x72|152x73|152x74|152x75|152x76|152x77|152x78|152x79|152x80|160x1|160x2|160x3|160x4|160x5|160x6|160x7|160x8|160x9|160x10|160x11|160x12|160x13|160x14|160x15|160x16|160x17|160x18|160x19|160x20|160x21|160x22|160x23|160x24|160x25|160x26|160x27|160x28|160x29|160x30|160x31|160x32|160x33|160x34|160x35|160x36|160x37|160x38|160x39|160x40|160x41|160x42|160x43|160x44|160x45|160x46|160x47|160x48|160x49|160x50|160x51|160x52|160x53|160x54|160x55|160x56|160x57|160x58|160x59|160x60|160x61|160x62|160x63|160x64|160x65|160x66|160x67|160x68|160x69|160x70|160x71|160x72|160x73|160x74|160x75|160x76|160x77|160x78|160x79|160x80|168x1|168x2|168x3|168x4|168x5|168x6|168x7|168x8|168x9|168x10|168x11|168x12|168x13|168x14|168x15|168x16|168x17|168x18|168x19|168x20|168x21|168x22|168x23|168x24|168x25|168x26|168x27|168x28|168x29|168x30|168x31|168x32|168x33|168x34|168x35|168x36|168x37|168x38|168x39|168x40|168x41|168x42|168x43|168x44|168x45|168x46|168x47|168x48|168x49|168x50|168x51|168x52|168x53|168x54|168x55|168x56|168x57|168x58|168x59|168x60|168x61|168x62|168x63|168x64|168x65|168x66|168x67|168x68|168x69|168x70|168x71|168x72|168x73|168x74|168x75|168x76|168x77|168x78|168x79|168x80|176x1|176x2|176x3|176x4|176x5|176x6|176x7|176x8|176x9|176x10|176x11|176x12|176x13|176x14|176x15|176x16|176x17|176x18|176x19|176x20|176x21|176x22|176x23|176x24|176x25|176x26|176x27|176x28|176x29|176x30|176x31|176x32|176x33|176x34|176x35|176x36|176x37|176x38|176x39|176x40|176x41|176x42|176x43|176x44|176x45|176x46|176x47|176x48|176x49|176x50|176x51|176x52|176x53|176x54|176x55|176x56|176x57|176x58|176x59|176x60|176x61|176x62|176x63|176x64|176x65|176x66|176x67|176x68|176x69|176x70|176x71|176x72|176x73|176x74|176x75|176x76|176x77|176x78|176x79|176x80|184x1|184x2|184x3|184x4|184x5|184x6|184x7|184x8|184x9|184x10|184x11|184x12|184x13|184x14|184x15|184x16|184x17|184x18|184x19|184x20|184x21|184x22|184x23|184x24|184x25|184x26|184x27|184x28|184x29|184x30|184x31|184x32|184x33|184x34|184x35|184x36|184x37|184x38|184x39|184x40|184x41|184x42|184x43|184x44|184x45|184x46|184x47|184x48|184x49|184x50|184x51|184x52|184x53|184x54|184x55|184x56|184x57|184x58|184x59|184x60|184x61|184x62|184x63|184x64|184x65|184x66|184x67|184x68|184x69|184x70|184x71|184x72|184x73|184x74|184x75|184x76|184x77|184x78|184x79|184x80|192x1|192x2|192x3|192x4|192x5|192x6|192x7|192x8|192x9|192x10|192x11|192x12|192x13|192x14|192x15|192x16|192x17|192x18|192x19|192x20|192x21|192x22|192x23|192x24|192x25|192x26|192x27|192x28|192x29|192x30|192x31|192x32|192x33|192x34|192x35|192x36|192x37|192x38|192x39|192x40|192x41|192x42|192x43|192x44|192x45|192x46|192x47|192x48|192x49|192x50|192x51|192x52|192x53|192x54|192x55|192x56|192x57|192x58|192x59|192x60|192x61|192x62|192x63|192x64|192x65|192x66|192x67|192x68|192x69|192x70|192x71|192x72|192x73|192x74|192x75|192x76|192x77|192x78|192x79|192x80|200x1|200x2|200x3|200x4|200x5|200x6|200x7|200x8|200x9|200x10|200x11|200x12|200x13|200x14|200x15|200x16|200x17|200x18|200x19|200x20|200x21|200x22|200x23|200x24|200x25|200x26|200x27|200x28|200x29|200x30|200x31|200x32|200x33|200x34|200x35|200x36|200x37|200x38|200x39|200x40|200x41|200x42|200x43|200x44|200x45|200x46|200x47|200x48|200x49|200x50|200x51|200x52|200x53|200x54|200x55|200x56|200x57|200x58|200x59|200x60|200x61|200x62|200x63|200x64|200x65|200x66|200x67|200x68|200x69|200x70|200x71|200x72|200x73|200x74|200x75|200x76|200x77|200x78|200x79|200x80|208x1|208x2|208x3|208x4|208x5|208x6|208x7|208x8|208x9|208x10|208x11|208x12|208x13|208x14|208x15|208x16|208x17|208x18|208x19|208x20|208x21|208x22|208x23|208x24|208x25|208x26|208x27|208x28|208x29|208x30|208x31|208x32|208x33|208x34|208x35|208x36|208x37|208x38|208x39|208x40|208x41|208x42|208x43|208x44|208x45|208x46|208x47|208x48|208x49|208x50|208x51|208x52|208x53|208x54|208x55|208x56|208x57|208x58|208x59|208x60|208x61|208x62|208x63|208x64|208x65|208x66|208x67|208x68|208x69|208x70|208x71|208x72|208x73|208x74|208x75|208x76|208x77|208x78|208x79|208x80|216x1|216x2|216x3|216x4|216x5|216x6|216x7|216x8|216x9|216x10|216x11|216x12|216x13|216x14|216x15|216x16|216x17|216x18|216x19|216x20|216x21|216x22|216x23|216x24|216x25|216x26|216x27|216x28|216x29|216x30|216x31|216x32|216x33|216x34|216x35|216x36|216x37|216x38|216x39|216x40|216x41|216x42|216x43|216x44|216x45|216x46|216x47|216x48|216x49|216x50|216x51|216x52|216x53|216x54|216x55|216x56|216x57|216x58|216x59|216x60|216x61|216x62|216x63|216x64|216x65|216x66|216x67|216x68|216x69|216x70|216x71|216x72|216x73|216x74|216x75|216x76|216x77|216x78|216x79|216x80|224x1|224x2|224x3|224x4|224x5|224x6|224x7|224x8|224x9|224x10|224x11|224x12|224x13|224x14|224x15|224x16|224x17|224x18|224x19|224x20|224x21|224x22|224x23|224x24|224x25|224x26|224x27|224x28|224x29|224x30|224x31|224x32|224x33|224x34|224x35|224x36|224x37|224x38|224x39|224x40|224x41|224x42|224x43|224x44|224x45|224x46|224x47|224x48|224x49|224x50|224x51|224x52|224x53|224x54|224x55|224x56|224x57|224x58|224x59|224x60|224x61|224x62|224x63|224x64|224x65|224x66|224x67|224x68|224x69|224x70|224x71|224x72|224x73|224x74|224x75|224x76|224x77|224x78|224x79|224x80|232x1|232x2|232x3|232x4|232x5|232x6|232x7|232x8|232x9|232x10|232x11|232x12|232x13|232x14|232x15|232x16|232x17|232x18|232x19|232x20|232x21|232x22|232x23|232x24|232x25|232x26|232x27|232x28|232x29|232x30|232x31|232x32|232x33|232x34|232x35|232x36|232x37|232x38|232x39|232x40|232x41|232x42|232x43|232x44|232x45|232x46|232x47|232x48|232x49|232x50|232x51|232x52|232x53|232x54|232x55|232x56|232x57|232x58|232x59|232x60|232x61|232x62|232x63|232x64|232x65|232x66|232x67|232x68|232x69|232x70|232x71|232x72|232x73|232x74|232x75|232x76|232x77|232x78|232x79|232x80|240x1|240x2|240x3|240x4|240x5|240x6|240x7|240x8|240x9|240x10|240x11|240x12|240x13|240x14|240x15|240x16|240x17|240x18|240x19|240x20|240x21|240x22|240x23|240x24|240x25|240x26|240x27|240x28|240x29|240x30|240x31|240x32|240x33|240x34|240x35|240x36|240x37|240x38|240x39|240x40|240x41|240x42|240x43|240x44|240x45|240x46|240x47|240x48|240x49|240x50|240x51|240x52|240x53|240x54|240x55|240x56|240x57|240x58|240x59|240x60|240x61|240x62|240x63|240x64|240x65|240x66|240x67|240x68|240x69|240x70|240x71|240x72|240x73|240x74|240x75|240x76|240x77|240x78|240x79|240x80|248x1|248x2|248x3|248x4|248x5|248x6|248x7|248x8|248x9|248x10|248x11|248x12|248x13|248x14|248x15|248x16|248x17|248x18|248x19|248x20|248x21|248x22|248x23|248x24|248x25|248x26|248x27|248x28|248x29|248x30|248x31|248x32|248x33|248x34|248x35|248x36|248x37|248x38|248x39|248x40|248x41|248x42|248x43|248x44|248x45|248x46|248x47|248x48|248x49|248x50|248x51|248x52|248x53|248x54|248x55|248x56|248x57|248x58|248x59|248x60|248x61|248x62|248x63|248x64|248x65|248x66|248x67|248x68|248x69|248x70|248x71|248x72|248x73|248x74|248x75|248x76|248x77|248x78|248x79|248x80|256x1|256x2|256x3|256x4|256x5|256x6|256x7|256x8|256x9|256x10|256x11|256x12|256x13|256x14|256x15|256x16|256x17|256x18|256x19|256x20|256x21|256x22|256x23|256x24|256x25|256x26|256x27|256x28|256x29|256x30|256x31|256x32|256x33|256x34|256x35|256x36|256x37|256x38|256x39|256x40|256x41|256x42|256x43|256x44|256x45|256x46|256x47|256x48|256x49|256x50|256x51|256x52|256x53|256x54|256x55|256x56|256x57|256x58|256x59|256x60|256x61|256x62|256x63|256x64|256x65|256x66|256x67|256x68|256x69|256x70|256x71|256x72|256x73|256x74|256x75|256x76|256x77|256x78|256x79|256x80)?(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bytes(1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bytes(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^function(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^string(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^tuple(\\\\[[0-9]*\\\\])*$"}]},"StateMutability":{"type":"string","enum":["pure","view","nonpayable","payable"]},"NormalFunction":{"type":"object","properties":{"type":{"type":"string","enum":["function"],"default":"function"},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"outputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"},"default":[]},"stateMutability":{"$ref":"#/definitions/StateMutability"},"constant":{"type":"boolean"},"payable":{"type":"boolean"}},"anyOf":[{"required":["name","inputs","stateMutability"]},{"required":["name","inputs","constant","payable"]}],"additionalProperties":false},"ConstructorFunction":{"type":"object","properties":{"type":{"type":"string","enum":["constructor"]},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"stateMutability":{"$ref":"#/definitions/StateMutability"},"constant":{"type":"boolean"},"payable":{"type":"boolean"}},"anyOf":[{"required":["type","inputs","stateMutability"]},{"required":["type","inputs","payable"]}],"additionalProperties":false},"FallbackFunction":{"type":"object","properties":{"type":{"type":"string","enum":["fallback"]},"stateMutability":{"$ref":"#/definitions/StateMutability"},"payable":{"type":"boolean"}},"anyOf":[{"required":["type","stateMutability"]},{"required":["type","payable"]}],"additionalProperties":false},"ReceiveFunction":{"type":"object","properties":{"type":{"type":"string","enum":["receive"]},"stateMutability":{"type":"string","enum":["payable"]}},"required":["type","stateMutability"],"additionalProperties":false},"Event":{"type":"object","properties":{"type":{"type":"string","enum":["event"]},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/EventParameter"}},"anonymous":{"type":"boolean"}},"required":["type","name","inputs","anonymous"],"additionalProperties":false},"Error":{"type":"object","properties":{"type":{"type":"string","enum":["error"]},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}}},"required":["type","name","inputs"],"additionalProperties":false},"Parameter":{"type":"object","if":{"properties":{"type":{"oneOf":[{"pattern":"^tuple"}]}}},"then":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"components":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"internalType":{"type":"string"}},"required":["name","type","components"],"additionalProperties":false},"else":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"internalType":{"type":"string"}},"required":["name","type"],"additionalProperties":false}},"EventParameter":{"type":"object","if":{"properties":{"type":{"oneOf":[{"pattern":"^tuple"}]}}},"then":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"components":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"indexed":{"type":"boolean"},"internalType":{"type":"string"}},"required":["name","type","components","indexed"],"additionalProperties":false},"else":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"indexed":{"type":"boolean"},"internalType":{"type":"string"}},"required":["name","type","indexed"],"additionalProperties":false}}}}');

/***/ }),

/***/ 885351:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"contract-object.spec.json","$schema":"http://json-schema.org/schema#","title":"Contract Object","description":"Describes a contract consumable by Truffle, possibly including deployed instances on networks","type":"object","properties":{"contractName":{"$ref":"#/definitions/ContractName","description":"Name used to identify the contract","default":"Contract"},"abi":{"$ref":"abi.spec.json#","description":"Interface description returned by compiler for source"},"metadata":{"$ref":"#/definitions/Metadata"},"bytecode":{"$ref":"#/definitions/Bytecode","description":"Bytecode sent as contract-creation transaction data, with unresolved link references"},"deployedBytecode":{"$ref":"#/definitions/Bytecode","description":"On-chain deployed contract bytecode, with unresolved link references"},"sourceMap":{"$ref":"#/definitions/SourceMap","description":"Source mapping for contract-creation transaction data bytecode"},"deployedSourceMap":{"$ref":"#/definitions/SourceMap","description":"Source mapping for contract bytecode"},"source":{"$ref":"#/definitions/Source"},"sourcePath":{"$ref":"#/definitions/SourcePath"},"ast":{"$ref":"#/definitions/AST"},"legacyAST":{"$ref":"#/definitions/LegacyAST"},"compiler":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"}}},"networks":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"$ref":"network-object.spec.json#"}},"additionalProperties":false},"schemaVersion":{"$ref":"#/definitions/SchemaVersion"},"updatedAt":{"type":"string","format":"date-time"},"networkType":{"$ref":"#/definitions/NetworkType","default":"ethereum"},"devdoc":{"$ref":"#/definitions/NatSpec"},"userdoc":{"$ref":"#/definitions/NatSpec"},"immutableReferences":{"$ref":"#/definitions/ImmutableReferences"},"generatedSources":{"$ref":"#/definitions/GeneratedSources"},"deployedGeneratedSources":{"$ref":"#/definitions/GeneratedSources"},"db":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"type":"object","description":"Reference to @truffle/db canonical ID object for correlation purposes","properties":{"id":{"type":"string"}}}}}},"required":["abi"],"patternProperties":{"^x-":{"anyOf":[{"type":"string"},{"type":"boolean"},{"type":"number"},{"type":"object"},{"type":"array"}]}},"additionalProperties":false,"definitions":{"ContractName":{"type":"string","pattern":"^[a-zA-Z_][a-zA-Z0-9_]*$"},"NatSpec":{"type":"object"},"Metadata":{"type":"string"},"NetworkType":{"type":"string"},"Bytecode":{"type":"string","pattern":"^0x0?$|^0x([a-fA-F0-9]{2}|__.{38})+$"},"ImmutableReferences":{"type":"object","additionalProperties":{"type":"array","items":{"type":"object","properties":{"start":{"type":"integer","minimum":0},"length":{"type":"integer","minimum":0}},"additionalProperties":false}}},"GeneratedSources":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer","minimum":0},"language":{"type":"string"},"name":{"type":"string"},"contents":{"type":"string"},"ast":{"type":"object"}},"additionalProperties":false}},"Source":{"type":"string"},"SourceMap":{"type":"string","examples":["315:637:1:-;;;452:55;;;;;;;-1:-1:-1;;;;;485:9:1;476:19;:8;:19;;;;;;;;;;498:5;476:27;;452:55;315:637;;;;;;;"]},"SourcePath":{"type":"string"},"AST":{"type":"object"},"LegacyAST":{"type":"object"},"SchemaVersion":{"type":"string","pattern":"[0-9]+\\\\.[0-9]+\\\\.[0-9]+"}}}');

/***/ }),

/***/ 453245:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"network-object.spec.json","$schema":"http://json-schema.org/schema#","title":"Network Object","type":"object","properties":{"address":{"$ref":"#/definitions/Address"},"transactionHash":{"$ref":"#/definitions/TransactionHash"},"events":{"type":"object","patternProperties":{"^0x[a-fA-F0-9]{64}$":{"$ref":"abi.spec.json#/definitions/Event"}},"additionalProperties":false},"links":{"type":"object","patternProperties":{"^[a-zA-Z_][a-zA-Z0-9_]*$":{"$ref":"#/definitions/Address"}},"additionalProperties":false},"db":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"type":"object","description":"Reference to @truffle/db canonical ID object for correlation purposes","properties":{"id":{"type":"string"}}}}}},"additionalProperties":false,"definitions":{"Address":{"type":"string","pattern":"^0x[a-fA-F0-9]{40}$"},"TransactionHash":{"type":"string","pattern":"^0x[a-fA-F0-9]{64}$"}}}');

/***/ }),

/***/ 354720:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"4.5.11"};

/***/ }),

/***/ 756442:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"contractName":"ENSRegistry","abi":[{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"label","type":"bytes32"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"NewOwner","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"resolver","type":"address"}],"name":"NewResolver","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"NewTTL","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"Transfer","type":"event"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setRecord","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"label","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setSubnodeRecord","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"}],"name":"setOwner","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"label","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"}],"name":"setSubnodeOwner","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"resolver","type":"address"}],"name":"setResolver","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setTTL","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolver","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"ttl","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"recordExists","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"}],"metadata":"{\\"compiler\\":{\\"version\\":\\"0.5.16+commit.9c3226ce\\"},\\"language\\":\\"Solidity\\",\\"output\\":{\\"abi\\":[{\\"inputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"constructor\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"ApprovalForAll\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"label\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"NewOwner\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"}],\\"name\\":\\"NewResolver\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"NewTTL\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"Transfer\\",\\"type\\":\\"event\\"},{\\"constant\\":true,\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"}],\\"name\\":\\"isApprovedForAll\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"owner\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"recordExists\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"resolver\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"setApprovalForAll\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setOwner\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setRecord\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setResolver\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"label\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setSubnodeOwner\\",\\"outputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"label\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setSubnodeRecord\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setTTL\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"ttl\\",\\"outputs\\":[{\\"internalType\\":\\"uint64\\",\\"name\\":\\"\\",\\"type\\":\\"uint64\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"}],\\"devdoc\\":{\\"methods\\":{\\"constructor\\":{\\"details\\":\\"Constructs a new ENS registrar.\\"},\\"isApprovedForAll(address,address)\\":{\\"details\\":\\"Query if an address is an authorized operator for another address.\\",\\"params\\":{\\"operator\\":\\"The address that acts on behalf of the owner.\\",\\"owner\\":\\"The address that owns the records.\\"},\\"return\\":\\"True if `operator` is an approved operator for `owner`, false otherwise.\\"},\\"owner(bytes32)\\":{\\"details\\":\\"Returns the address that owns the specified node.\\",\\"params\\":{\\"node\\":\\"The specified node.\\"},\\"return\\":\\"address of the owner.\\"},\\"recordExists(bytes32)\\":{\\"details\\":\\"Returns whether a record has been imported to the registry.\\",\\"params\\":{\\"node\\":\\"The specified node.\\"},\\"return\\":\\"Bool if record exists\\"},\\"resolver(bytes32)\\":{\\"details\\":\\"Returns the address of the resolver for the specified node.\\",\\"params\\":{\\"node\\":\\"The specified node.\\"},\\"return\\":\\"address of the resolver.\\"},\\"setApprovalForAll(address,bool)\\":{\\"details\\":\\"Enable or disable approval for a third party (\\\\\\"operator\\\\\\") to manage all of `msg.sender`\'s ENS records. Emits the ApprovalForAll event.\\",\\"params\\":{\\"approved\\":\\"True if the operator is approved, false to revoke approval.\\",\\"operator\\":\\"Address to add to the set of authorized operators.\\"}},\\"setOwner(bytes32,address)\\":{\\"details\\":\\"Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\",\\"params\\":{\\"node\\":\\"The node to transfer ownership of.\\",\\"owner\\":\\"The address of the new owner.\\"}},\\"setRecord(bytes32,address,address,uint64)\\":{\\"details\\":\\"Sets the record for a node.\\",\\"params\\":{\\"node\\":\\"The node to update.\\",\\"owner\\":\\"The address of the new owner.\\",\\"resolver\\":\\"The address of the resolver.\\",\\"ttl\\":\\"The TTL in seconds.\\"}},\\"setResolver(bytes32,address)\\":{\\"details\\":\\"Sets the resolver address for the specified node.\\",\\"params\\":{\\"node\\":\\"The node to update.\\",\\"resolver\\":\\"The address of the resolver.\\"}},\\"setSubnodeOwner(bytes32,bytes32,address)\\":{\\"details\\":\\"Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\",\\"params\\":{\\"label\\":\\"The hash of the label specifying the subnode.\\",\\"node\\":\\"The parent node.\\",\\"owner\\":\\"The address of the new owner.\\"}},\\"setSubnodeRecord(bytes32,bytes32,address,address,uint64)\\":{\\"details\\":\\"Sets the record for a subnode.\\",\\"params\\":{\\"label\\":\\"The hash of the label specifying the subnode.\\",\\"node\\":\\"The parent node.\\",\\"owner\\":\\"The address of the new owner.\\",\\"resolver\\":\\"The address of the resolver.\\",\\"ttl\\":\\"The TTL in seconds.\\"}},\\"setTTL(bytes32,uint64)\\":{\\"details\\":\\"Sets the TTL for the specified node.\\",\\"params\\":{\\"node\\":\\"The node to update.\\",\\"ttl\\":\\"The TTL in seconds.\\"}},\\"ttl(bytes32)\\":{\\"details\\":\\"Returns the TTL of a node, and any records associated with it.\\",\\"params\\":{\\"node\\":\\"The specified node.\\"},\\"return\\":\\"ttl of the node.\\"}}},\\"userdoc\\":{\\"methods\\":{},\\"notice\\":\\"The ENS registry contract.\\"}},\\"settings\\":{\\"compilationTarget\\":{\\"ENSRegistryWithFallback.sol\\":\\"ENSRegistry\\"},\\"evmVersion\\":\\"istanbul\\",\\"libraries\\":{},\\"optimizer\\":{\\"enabled\\":false,\\"runs\\":200},\\"remappings\\":[]},\\"sources\\":{\\"ENSRegistryWithFallback.sol\\":{\\"keccak256\\":\\"0x525b56f56a57f47c66b35c599a8b08ba67d117d6065a4d6c5f01d56537632a4b\\",\\"urls\\":[\\"bzz-raw://1af612a5bf81ec7cd7e255dbdf15432f63071c9d336585421d44a6637b4bc966\\",\\"dweb:/ipfs/QmY1mGAosxzcn6wRA3rxktVMToqjNVnpVG7NwfNEuK91HE\\"]}},\\"version\\":1}","bytecode":"0x608060405234801561001057600080fd5b50336000808060001b815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555061118b806100776000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80635b0fc9c3116100715780635b0fc9c3146102e75780635ef2c7f014610335578063a22cb465146103c1578063cf40882314610411578063e985e9c514610493578063f79fe5381461050f576100b4565b80630178b8bf146100b957806302571be31461012757806306ab59231461019557806314ab90381461020157806316a25cbd146102435780631896f70a14610299575b600080fd5b6100e5600480360360208110156100cf57600080fd5b8101908080359060200190929190505050610555565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101536004803603602081101561013d57600080fd5b8101908080359060200190929190505050610594565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101eb600480360360608110156101ab57600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610617565b6040518082815260200191505060405180910390f35b6102416004803603604081101561021757600080fd5b8101908080359060200190929190803567ffffffffffffffff1690602001909291905050506107cc565b005b61026f6004803603602081101561025957600080fd5b810190808035906020019092919050505061095e565b604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390f35b6102e5600480360360408110156102af57600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610991565b005b610333600480360360408110156102fd57600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b53565b005b6103bf600480360360a081101561034b57600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803567ffffffffffffffff169060200190929190505050610ccb565b005b61040f600480360360408110156103d757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803515159060200190929190505050610ced565b005b6104916004803603608081101561042757600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803567ffffffffffffffff169060200190929190505050610dee565b005b6104f5600480360360408110156104a957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610e09565b604051808215151515815260200191505060405180910390f35b61053b6004803603602081101561052557600080fd5b8101908080359060200190929190505050610e9d565b604051808215151515815260200191505060405180910390f35b600080600083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60008060008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561060d576000915050610612565b809150505b919050565b600083600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806107145750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61071d57600080fd5b60008686604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120905061075a8186610f0b565b85877fce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e8287604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a38093505050509392505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806108c75750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6108d057600080fd5b837f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6884604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390a28260008086815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050565b600080600083815260200190815260200160002060010160149054906101000a900467ffffffffffffffff169050919050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610a8c5750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610a9557600080fd5b837f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a084604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a28260008086815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610c4e5750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610c5757600080fd5b610c618484610f0b565b837fd4735d920b0f87494915f556dd9b54c8f309026070caea5c737245152564d26684604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a250505050565b6000610cd8868686610617565b9050610ce5818484610f63565b505050505050565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3183604051808215151515815260200191505060405180910390a35050565b610df88484610b53565b610e03848383610f63565b50505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b8060008084815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008084815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614611084578160008085815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a083604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a25b60008084815260200190815260200160002060010160149054906101000a900467ffffffffffffffff1667ffffffffffffffff168167ffffffffffffffff1614611151578060008085815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550827f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6882604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390a25b50505056fea265627a7a723158206b59397be10f5470e142c4bc96b9587af86760ff5a4854b84afda7f61d81c26e64736f6c63430005100032","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106100b45760003560e01c80635b0fc9c3116100715780635b0fc9c3146102e75780635ef2c7f014610335578063a22cb465146103c1578063cf40882314610411578063e985e9c514610493578063f79fe5381461050f576100b4565b80630178b8bf146100b957806302571be31461012757806306ab59231461019557806314ab90381461020157806316a25cbd146102435780631896f70a14610299575b600080fd5b6100e5600480360360208110156100cf57600080fd5b8101908080359060200190929190505050610555565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101536004803603602081101561013d57600080fd5b8101908080359060200190929190505050610594565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101eb600480360360608110156101ab57600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610617565b6040518082815260200191505060405180910390f35b6102416004803603604081101561021757600080fd5b8101908080359060200190929190803567ffffffffffffffff1690602001909291905050506107cc565b005b61026f6004803603602081101561025957600080fd5b810190808035906020019092919050505061095e565b604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390f35b6102e5600480360360408110156102af57600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610991565b005b610333600480360360408110156102fd57600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b53565b005b6103bf600480360360a081101561034b57600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803567ffffffffffffffff169060200190929190505050610ccb565b005b61040f600480360360408110156103d757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803515159060200190929190505050610ced565b005b6104916004803603608081101561042757600080fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803567ffffffffffffffff169060200190929190505050610dee565b005b6104f5600480360360408110156104a957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610e09565b604051808215151515815260200191505060405180910390f35b61053b6004803603602081101561052557600080fd5b8101908080359060200190929190505050610e9d565b604051808215151515815260200191505060405180910390f35b600080600083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60008060008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561060d576000915050610612565b809150505b919050565b600083600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806107145750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b61071d57600080fd5b60008686604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120905061075a8186610f0b565b85877fce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e8287604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a38093505050509392505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614806108c75750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b6108d057600080fd5b837f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6884604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390a28260008086815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050565b600080600083815260200190815260200160002060010160149054906101000a900467ffffffffffffffff169050919050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610a8c5750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610a9557600080fd5b837f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a084604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a28260008086815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610c4e5750600160008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b610c5757600080fd5b610c618484610f0b565b837fd4735d920b0f87494915f556dd9b54c8f309026070caea5c737245152564d26684604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a250505050565b6000610cd8868686610617565b9050610ce5818484610f63565b505050505050565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3183604051808215151515815260200191505060405180910390a35050565b610df88484610b53565b610e03848383610f63565b50505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b8060008084815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008084815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614611084578160008085815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a083604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a25b60008084815260200190815260200160002060010160149054906101000a900467ffffffffffffffff1667ffffffffffffffff168167ffffffffffffffff1614611151578060008085815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550827f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6882604051808267ffffffffffffffff1667ffffffffffffffff16815260200191505060405180910390a25b50505056fea265627a7a723158206b59397be10f5470e142c4bc96b9587af86760ff5a4854b84afda7f61d81c26e64736f6c63430005100032","sourceMap":"1888:6005:0:-;;;2446:71;8:9:-1;5:2;;;30:1;27;20:12;5:2;2446:71:0;2499:10;2478:7;:12;2486:3;2478:12;;;;;;;;;;;;;:18;;;:31;;;;;;;;;;;;;;;;;;1888:6005;;;;;;","deployedSourceMap":"1888:6005:0:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1888:6005:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6252:110;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;6252:110:0;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;5853:219;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;5853:219:0;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;4210:292;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;4210:292:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5011:141;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;5011:141:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;6537:99;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;6537:99:0;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;4684:172;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;4684:172:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;3741:149;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;3741:149:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;3261:234;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;3261:234:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;5494:192;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;5494:192:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;2767:177;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;2767:177:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;7258:140;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;7258:140:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;6813:124;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;6813:124:0;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;6252:110;6305:7;6332;:13;6340:4;6332:13;;;;;;;;;;;:22;;;;;;;;;;;;6325:29;;6252:110;;;:::o;5853:219::-;5903:7;5923:12;5938:7;:13;5946:4;5938:13;;;;;;;;;;;:19;;;;;;;;;;;;5923:34;;5988:4;5972:21;;:4;:21;;;5968:73;;;6025:3;6010:19;;;;;5968:73;6060:4;6053:11;;;5853:219;;;;:::o;4210:292::-;4311:7;4297:4;2249:13;2265:7;:13;2273:4;2265:13;;;;;;;;;;;:19;;;;;;;;;;;;2249:35;;2312:10;2303:19;;:5;:19;;;:51;;;;2326:9;:16;2336:5;2326:16;;;;;;;;;;;;;;;:28;2343:10;2326:28;;;;;;;;;;;;;;;;;;;;;;;;;2303:51;2295:60;;;;;;4331:15;4376:4;4382:5;4359:29;;;;;;;;;;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;4359:29:0;;;4349:40;;;;;;4331:58;;4400:25;4410:7;4419:5;4400:9;:25::i;:::-;4456:5;4450:4;4441:28;4463:5;4441:28;;;;;;;;;;;;;;;;;;;;;;4487:7;4480:14;;;4210:292;;;;;;;:::o;5011:141::-;5071:4;2249:13;2265:7;:13;2273:4;2265:13;;;;;;;;;;;:19;;;;;;;;;;;;2249:35;;2312:10;2303:19;;:5;:19;;;:51;;;;2326:9;:16;2336:5;2326:16;;;;;;;;;;;;;;;:28;2343:10;2326:28;;;;;;;;;;;;;;;;;;;;;;;;;2303:51;2295:60;;;;;;5100:4;5093:17;5106:3;5093:17;;;;;;;;;;;;;;;;;;;;;;5141:3;5121:7;:13;5129:4;5121:13;;;;;;;;;;;:17;;;:23;;;;;;;;;;;;;;;;;;5011:141;;;;:::o;6537:99::-;6585:6;6611:7;:13;6619:4;6611:13;;;;;;;;;;;:17;;;;;;;;;;;;6604:24;;6537:99;;;:::o;4684:172::-;4755:4;2249:13;2265:7;:13;2273:4;2265:13;;;;;;;;;;;:19;;;;;;;;;;;;2249:35;;2312:10;2303:19;;:5;:19;;;:51;;;;2326:9;:16;2336:5;2326:16;;;;;;;;;;;;;;;:28;2343:10;2326:28;;;;;;;;;;;;;;;;;;;;;;;;;2303:51;2295:60;;;;;;4789:4;4777:27;4795:8;4777:27;;;;;;;;;;;;;;;;;;;;;;4840:8;4815:7;:13;4823:4;4815:13;;;;;;;;;;;:22;;;:33;;;;;;;;;;;;;;;;;;4684:172;;;;:::o;3741:149::-;3806:4;2249:13;2265:7;:13;2273:4;2265:13;;;;;;;;;;;:19;;;;;;;;;;;;2249:35;;2312:10;2303:19;;:5;:19;;;:51;;;;2326:9;:16;2336:5;2326:16;;;;;;;;;;;;;;;:28;2343:10;2326:28;;;;;;;;;;;;;;;;;;;;;;;;;2303:51;2295:60;;;;;;3823:22;3833:4;3839:5;3823:9;:22::i;:::-;3870:4;3861:21;3876:5;3861:21;;;;;;;;;;;;;;;;;;;;;;3741:149;;;;:::o;3261:234::-;3381:15;3399:35;3415:4;3421:5;3428;3399:15;:35::i;:::-;3381:53;;3445:42;3464:7;3473:8;3483:3;3445:18;:42::i;:::-;3261:234;;;;;;:::o;5494:192::-;5608:8;5574:9;:21;5584:10;5574:21;;;;;;;;;;;;;;;:31;5596:8;5574:31;;;;;;;;;;;;;;;;:42;;;;;;;;;;;;;;;;;;5659:8;5632:46;;5647:10;5632:46;;;5669:8;5632:46;;;;;;;;;;;;;;;;;;;;;;5494:192;;:::o;2767:177::-;2865:21;2874:4;2880:5;2865:8;:21::i;:::-;2897:39;2916:4;2922:8;2932:3;2897:18;:39::i;:::-;2767:177;;;;:::o;7258:140::-;7340:4;7364:9;:16;7374:5;7364:16;;;;;;;;;;;;;;;:26;7381:8;7364:26;;;;;;;;;;;;;;;;;;;;;;;;;7357:33;;7258:140;;;;:::o;6813:124::-;6870:4;6925:3;6894:35;;:7;:13;6902:4;6894:13;;;;;;;;;;;:19;;;;;;;;;;;;:35;;;;6887:42;;6813:124;;;:::o;7406:103::-;7496:5;7474:7;:13;7482:4;7474:13;;;;;;;;;;;:19;;;:27;;;;;;;;;;;;;;;;;;7406:103;;:::o;7517:373::-;7624:7;:13;7632:4;7624:13;;;;;;;;;;;:22;;;;;;;;;;;;7612:34;;:8;:34;;;7609:146;;7688:8;7663:7;:13;7671:4;7663:13;;;;;;;;;;;:22;;;:33;;;;;;;;;;;;;;;;;;7728:4;7716:27;7734:8;7716:27;;;;;;;;;;;;;;;;;;;;;;7609:146;7777:7;:13;7785:4;7777:13;;;;;;;;;;;:17;;;;;;;;;;;;7770:24;;:3;:24;;;7767:116;;7831:3;7811:7;:13;7819:4;7811:13;;;;;;;;;;;:17;;;:23;;;;;;;;;;;;;;;;;;7861:4;7854:17;7867:3;7854:17;;;;;;;;;;;;;;;;;;;;;;7767:116;7517:373;;;:::o","source":"/**\\n *Submitted for verification at Etherscan.io on 20XX-XX-XX\\n*/\\n\\n// File: @ensdomains/ens/contracts/ENS.sol\\r\\n\\r\\npragma solidity >=0.4.24;\\r\\n\\r\\ninterface ENS {\\r\\n\\r\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\r\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\r\\n\\r\\n    // Logged when the owner of a node transfers ownership to a new account.\\r\\n    event Transfer(bytes32 indexed node, address owner);\\r\\n\\r\\n    // Logged when the resolver for a node changes.\\r\\n    event NewResolver(bytes32 indexed node, address resolver);\\r\\n\\r\\n    // Logged when the TTL of a node changes\\r\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\r\\n\\r\\n    // Logged when an operator is added or removed.\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\r\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\r\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\\r\\n    function setResolver(bytes32 node, address resolver) external;\\r\\n    function setOwner(bytes32 node, address owner) external;\\r\\n    function setTTL(bytes32 node, uint64 ttl) external;\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n    function owner(bytes32 node) external view returns (address);\\r\\n    function resolver(bytes32 node) external view returns (address);\\r\\n    function ttl(bytes32 node) external view returns (uint64);\\r\\n    function recordExists(bytes32 node) external view returns (bool);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n}\\r\\n\\r\\n// File: @ensdomains/ens/contracts/ENSRegistry.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * The ENS registry contract.\\r\\n */\\r\\ncontract ENSRegistry is ENS {\\r\\n\\r\\n    struct Record {\\r\\n        address owner;\\r\\n        address resolver;\\r\\n        uint64 ttl;\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 => Record) records;\\r\\n    mapping (address => mapping(address => bool)) operators;\\r\\n\\r\\n    // Permits modifications only by the owner of the specified node.\\r\\n    modifier authorised(bytes32 node) {\\r\\n        address owner = records[node].owner;\\r\\n        require(owner == msg.sender || operators[owner][msg.sender]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Constructs a new ENS registrar.\\r\\n     */\\r\\n    constructor() public {\\r\\n        records[0x0].owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the record for a node.\\r\\n     * @param node The node to update.\\r\\n     * @param owner The address of the new owner.\\r\\n     * @param resolver The address of the resolver.\\r\\n     * @param ttl The TTL in seconds.\\r\\n     */\\r\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external {\\r\\n        setOwner(node, owner);\\r\\n        _setResolverAndTTL(node, resolver, ttl);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the record for a subnode.\\r\\n     * @param node The parent node.\\r\\n     * @param label The hash of the label specifying the subnode.\\r\\n     * @param owner The address of the new owner.\\r\\n     * @param resolver The address of the resolver.\\r\\n     * @param ttl The TTL in seconds.\\r\\n     */\\r\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external {\\r\\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\\r\\n        _setResolverAndTTL(subnode, resolver, ttl);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\r\\n     * @param node The node to transfer ownership of.\\r\\n     * @param owner The address of the new owner.\\r\\n     */\\r\\n    function setOwner(bytes32 node, address owner) public authorised(node) {\\r\\n        _setOwner(node, owner);\\r\\n        emit Transfer(node, owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\r\\n     * @param node The parent node.\\r\\n     * @param label The hash of the label specifying the subnode.\\r\\n     * @param owner The address of the new owner.\\r\\n     */\\r\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public authorised(node) returns(bytes32) {\\r\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\r\\n        _setOwner(subnode, owner);\\r\\n        emit NewOwner(node, label, owner);\\r\\n        return subnode;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the resolver address for the specified node.\\r\\n     * @param node The node to update.\\r\\n     * @param resolver The address of the resolver.\\r\\n     */\\r\\n    function setResolver(bytes32 node, address resolver) public authorised(node) {\\r\\n        emit NewResolver(node, resolver);\\r\\n        records[node].resolver = resolver;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the TTL for the specified node.\\r\\n     * @param node The node to update.\\r\\n     * @param ttl The TTL in seconds.\\r\\n     */\\r\\n    function setTTL(bytes32 node, uint64 ttl) public authorised(node) {\\r\\n        emit NewTTL(node, ttl);\\r\\n        records[node].ttl = ttl;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Enable or disable approval for a third party (\\"operator\\") to manage\\r\\n     *  all of `msg.sender`\'s ENS records. Emits the ApprovalForAll event.\\r\\n     * @param operator Address to add to the set of authorized operators.\\r\\n     * @param approved True if the operator is approved, false to revoke approval.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external {\\r\\n        operators[msg.sender][operator] = approved;\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that owns the specified node.\\r\\n     * @param node The specified node.\\r\\n     * @return address of the owner.\\r\\n     */\\r\\n    function owner(bytes32 node) public view returns (address) {\\r\\n        address addr = records[node].owner;\\r\\n        if (addr == address(this)) {\\r\\n            return address(0x0);\\r\\n        }\\r\\n\\r\\n        return addr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the resolver for the specified node.\\r\\n     * @param node The specified node.\\r\\n     * @return address of the resolver.\\r\\n     */\\r\\n    function resolver(bytes32 node) public view returns (address) {\\r\\n        return records[node].resolver;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the TTL of a node, and any records associated with it.\\r\\n     * @param node The specified node.\\r\\n     * @return ttl of the node.\\r\\n     */\\r\\n    function ttl(bytes32 node) public view returns (uint64) {\\r\\n        return records[node].ttl;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a record has been imported to the registry.\\r\\n     * @param node The specified node.\\r\\n     * @return Bool if record exists\\r\\n     */\\r\\n    function recordExists(bytes32 node) public view returns (bool) {\\r\\n        return records[node].owner != address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Query if an address is an authorized operator for another address.\\r\\n     * @param owner The address that owns the records.\\r\\n     * @param operator The address that acts on behalf of the owner.\\r\\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\r\\n        return operators[owner][operator];\\r\\n    }\\r\\n\\r\\n    function _setOwner(bytes32 node, address owner) internal {\\r\\n        records[node].owner = owner;\\r\\n    }\\r\\n\\r\\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\\r\\n        if(resolver != records[node].resolver) {\\r\\n            records[node].resolver = resolver;\\r\\n            emit NewResolver(node, resolver);\\r\\n        }\\r\\n\\r\\n        if(ttl != records[node].ttl) {\\r\\n            records[node].ttl = ttl;\\r\\n            emit NewTTL(node, ttl);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File: @ensdomains/ens/contracts/ENSRegistryWithFallback.sol\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * The ENS registry contract.\\r\\n */\\r\\ncontract ENSRegistryWithFallback is ENSRegistry {\\r\\n\\r\\n    ENS public old;\\r\\n\\r\\n    /**\\r\\n     * @dev Constructs a new ENS registrar.\\r\\n     */\\r\\n    constructor(ENS _old) public ENSRegistry() {\\r\\n        old = _old;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the resolver for the specified node.\\r\\n     * @param node The specified node.\\r\\n     * @return address of the resolver.\\r\\n     */\\r\\n    function resolver(bytes32 node) public view returns (address) {\\r\\n        if (!recordExists(node)) {\\r\\n            return old.resolver(node);\\r\\n        }\\r\\n\\r\\n        return super.resolver(node);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that owns the specified node.\\r\\n     * @param node The specified node.\\r\\n     * @return address of the owner.\\r\\n     */\\r\\n    function owner(bytes32 node) public view returns (address) {\\r\\n        if (!recordExists(node)) {\\r\\n            return old.owner(node);\\r\\n        }\\r\\n\\r\\n        return super.owner(node);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the TTL of a node, and any records associated with it.\\r\\n     * @param node The specified node.\\r\\n     * @return ttl of the node.\\r\\n     */\\r\\n    function ttl(bytes32 node) public view returns (uint64) {\\r\\n        if (!recordExists(node)) {\\r\\n            return old.ttl(node);\\r\\n        }\\r\\n\\r\\n        return super.ttl(node);\\r\\n    }\\r\\n\\r\\n    function _setOwner(bytes32 node, address owner) internal {\\r\\n        address addr = owner;\\r\\n        if (addr == address(0x0)) {\\r\\n            addr = address(this);\\r\\n        }\\r\\n\\r\\n        super._setOwner(node, addr);\\r\\n    }\\r\\n}","sourcePath":"ENSRegistryWithFallback.sol","ast":{"absolutePath":"ENSRegistryWithFallback.sol","exportedSymbols":{"ENS":[136],"ENSRegistry":[528],"ENSRegistryWithFallback":[650]},"id":651,"nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity",">=","0.4",".24"],"nodeType":"PragmaDirective","src":"113:25:0"},{"baseContracts":[],"contractDependencies":[],"contractKind":"interface","documentation":null,"fullyImplemented":false,"id":136,"linearizedBaseContracts":[136],"name":"ENS","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":null,"id":9,"name":"NewOwner","nodeType":"EventDefinition","parameters":{"id":8,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":9,"src":"254:20:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":2,"name":"bytes32","nodeType":"ElementaryTypeName","src":"254:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":5,"indexed":true,"name":"label","nodeType":"VariableDeclaration","scope":9,"src":"276:21:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":4,"name":"bytes32","nodeType":"ElementaryTypeName","src":"276:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":7,"indexed":false,"name":"owner","nodeType":"VariableDeclaration","scope":9,"src":"299:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":6,"name":"address","nodeType":"ElementaryTypeName","src":"299:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"253:60:0"},"src":"239:75:0"},{"anonymous":false,"documentation":null,"id":15,"name":"Transfer","nodeType":"EventDefinition","parameters":{"id":14,"nodeType":"ParameterList","parameters":[{"constant":false,"id":11,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":15,"src":"415:20:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":10,"name":"bytes32","nodeType":"ElementaryTypeName","src":"415:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":13,"indexed":false,"name":"owner","nodeType":"VariableDeclaration","scope":15,"src":"437:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":12,"name":"address","nodeType":"ElementaryTypeName","src":"437:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"414:37:0"},"src":"400:52:0"},{"anonymous":false,"documentation":null,"id":21,"name":"NewResolver","nodeType":"EventDefinition","parameters":{"id":20,"nodeType":"ParameterList","parameters":[{"constant":false,"id":17,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":21,"src":"531:20:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":16,"name":"bytes32","nodeType":"ElementaryTypeName","src":"531:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":19,"indexed":false,"name":"resolver","nodeType":"VariableDeclaration","scope":21,"src":"553:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":18,"name":"address","nodeType":"ElementaryTypeName","src":"553:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"530:40:0"},"src":"513:58:0"},{"anonymous":false,"documentation":null,"id":27,"name":"NewTTL","nodeType":"EventDefinition","parameters":{"id":26,"nodeType":"ParameterList","parameters":[{"constant":false,"id":23,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":27,"src":"638:20:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":22,"name":"bytes32","nodeType":"ElementaryTypeName","src":"638:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":25,"indexed":false,"name":"ttl","nodeType":"VariableDeclaration","scope":27,"src":"660:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":24,"name":"uint64","nodeType":"ElementaryTypeName","src":"660:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"637:34:0"},"src":"625:47:0"},{"anonymous":false,"documentation":null,"id":35,"name":"ApprovalForAll","nodeType":"EventDefinition","parameters":{"id":34,"nodeType":"ParameterList","parameters":[{"constant":false,"id":29,"indexed":true,"name":"owner","nodeType":"VariableDeclaration","scope":35,"src":"754:21:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":28,"name":"address","nodeType":"ElementaryTypeName","src":"754:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":31,"indexed":true,"name":"operator","nodeType":"VariableDeclaration","scope":35,"src":"777:24:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":30,"name":"address","nodeType":"ElementaryTypeName","src":"777:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":33,"indexed":false,"name":"approved","nodeType":"VariableDeclaration","scope":35,"src":"803:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":32,"name":"bool","nodeType":"ElementaryTypeName","src":"803:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"753:64:0"},"src":"733:85:0"},{"body":null,"documentation":null,"id":46,"implemented":false,"kind":"function","modifiers":[],"name":"setRecord","nodeType":"FunctionDefinition","parameters":{"id":44,"nodeType":"ParameterList","parameters":[{"constant":false,"id":37,"name":"node","nodeType":"VariableDeclaration","scope":46,"src":"845:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":36,"name":"bytes32","nodeType":"ElementaryTypeName","src":"845:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":39,"name":"owner","nodeType":"VariableDeclaration","scope":46,"src":"859:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":38,"name":"address","nodeType":"ElementaryTypeName","src":"859:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":41,"name":"resolver","nodeType":"VariableDeclaration","scope":46,"src":"874:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":40,"name":"address","nodeType":"ElementaryTypeName","src":"874:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":43,"name":"ttl","nodeType":"VariableDeclaration","scope":46,"src":"892:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":42,"name":"uint64","nodeType":"ElementaryTypeName","src":"892:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"844:59:0"},"returnParameters":{"id":45,"nodeType":"ParameterList","parameters":[],"src":"912:0:0"},"scope":136,"src":"826:87:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":59,"implemented":false,"kind":"function","modifiers":[],"name":"setSubnodeRecord","nodeType":"FunctionDefinition","parameters":{"id":57,"nodeType":"ParameterList","parameters":[{"constant":false,"id":48,"name":"node","nodeType":"VariableDeclaration","scope":59,"src":"945:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":47,"name":"bytes32","nodeType":"ElementaryTypeName","src":"945:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":50,"name":"label","nodeType":"VariableDeclaration","scope":59,"src":"959:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":49,"name":"bytes32","nodeType":"ElementaryTypeName","src":"959:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":52,"name":"owner","nodeType":"VariableDeclaration","scope":59,"src":"974:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":51,"name":"address","nodeType":"ElementaryTypeName","src":"974:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":54,"name":"resolver","nodeType":"VariableDeclaration","scope":59,"src":"989:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":53,"name":"address","nodeType":"ElementaryTypeName","src":"989:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":56,"name":"ttl","nodeType":"VariableDeclaration","scope":59,"src":"1007:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":55,"name":"uint64","nodeType":"ElementaryTypeName","src":"1007:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"944:74:0"},"returnParameters":{"id":58,"nodeType":"ParameterList","parameters":[],"src":"1027:0:0"},"scope":136,"src":"919:109:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":70,"implemented":false,"kind":"function","modifiers":[],"name":"setSubnodeOwner","nodeType":"FunctionDefinition","parameters":{"id":66,"nodeType":"ParameterList","parameters":[{"constant":false,"id":61,"name":"node","nodeType":"VariableDeclaration","scope":70,"src":"1059:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":60,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1059:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":63,"name":"label","nodeType":"VariableDeclaration","scope":70,"src":"1073:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":62,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1073:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":65,"name":"owner","nodeType":"VariableDeclaration","scope":70,"src":"1088:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":64,"name":"address","nodeType":"ElementaryTypeName","src":"1088:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1058:44:0"},"returnParameters":{"id":69,"nodeType":"ParameterList","parameters":[{"constant":false,"id":68,"name":"","nodeType":"VariableDeclaration","scope":70,"src":"1120:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":67,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1120:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"1119:9:0"},"scope":136,"src":"1034:95:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":77,"implemented":false,"kind":"function","modifiers":[],"name":"setResolver","nodeType":"FunctionDefinition","parameters":{"id":75,"nodeType":"ParameterList","parameters":[{"constant":false,"id":72,"name":"node","nodeType":"VariableDeclaration","scope":77,"src":"1156:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":71,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1156:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":74,"name":"resolver","nodeType":"VariableDeclaration","scope":77,"src":"1170:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":73,"name":"address","nodeType":"ElementaryTypeName","src":"1170:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1155:32:0"},"returnParameters":{"id":76,"nodeType":"ParameterList","parameters":[],"src":"1196:0:0"},"scope":136,"src":"1135:62:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":84,"implemented":false,"kind":"function","modifiers":[],"name":"setOwner","nodeType":"FunctionDefinition","parameters":{"id":82,"nodeType":"ParameterList","parameters":[{"constant":false,"id":79,"name":"node","nodeType":"VariableDeclaration","scope":84,"src":"1221:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":78,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1221:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":81,"name":"owner","nodeType":"VariableDeclaration","scope":84,"src":"1235:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":80,"name":"address","nodeType":"ElementaryTypeName","src":"1235:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1220:29:0"},"returnParameters":{"id":83,"nodeType":"ParameterList","parameters":[],"src":"1258:0:0"},"scope":136,"src":"1203:56:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":91,"implemented":false,"kind":"function","modifiers":[],"name":"setTTL","nodeType":"FunctionDefinition","parameters":{"id":89,"nodeType":"ParameterList","parameters":[{"constant":false,"id":86,"name":"node","nodeType":"VariableDeclaration","scope":91,"src":"1281:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":85,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1281:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":88,"name":"ttl","nodeType":"VariableDeclaration","scope":91,"src":"1295:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":87,"name":"uint64","nodeType":"ElementaryTypeName","src":"1295:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"1280:26:0"},"returnParameters":{"id":90,"nodeType":"ParameterList","parameters":[],"src":"1315:0:0"},"scope":136,"src":"1265:51:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":98,"implemented":false,"kind":"function","modifiers":[],"name":"setApprovalForAll","nodeType":"FunctionDefinition","parameters":{"id":96,"nodeType":"ParameterList","parameters":[{"constant":false,"id":93,"name":"operator","nodeType":"VariableDeclaration","scope":98,"src":"1349:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":92,"name":"address","nodeType":"ElementaryTypeName","src":"1349:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":95,"name":"approved","nodeType":"VariableDeclaration","scope":98,"src":"1367:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":94,"name":"bool","nodeType":"ElementaryTypeName","src":"1367:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1348:33:0"},"returnParameters":{"id":97,"nodeType":"ParameterList","parameters":[],"src":"1390:0:0"},"scope":136,"src":"1322:69:0","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":105,"implemented":false,"kind":"function","modifiers":[],"name":"owner","nodeType":"FunctionDefinition","parameters":{"id":101,"nodeType":"ParameterList","parameters":[{"constant":false,"id":100,"name":"node","nodeType":"VariableDeclaration","scope":105,"src":"1412:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":99,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1412:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"1411:14:0"},"returnParameters":{"id":104,"nodeType":"ParameterList","parameters":[{"constant":false,"id":103,"name":"","nodeType":"VariableDeclaration","scope":105,"src":"1449:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":102,"name":"address","nodeType":"ElementaryTypeName","src":"1449:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1448:9:0"},"scope":136,"src":"1397:61:0","stateMutability":"view","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":112,"implemented":false,"kind":"function","modifiers":[],"name":"resolver","nodeType":"FunctionDefinition","parameters":{"id":108,"nodeType":"ParameterList","parameters":[{"constant":false,"id":107,"name":"node","nodeType":"VariableDeclaration","scope":112,"src":"1482:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":106,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1482:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"1481:14:0"},"returnParameters":{"id":111,"nodeType":"ParameterList","parameters":[{"constant":false,"id":110,"name":"","nodeType":"VariableDeclaration","scope":112,"src":"1519:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":109,"name":"address","nodeType":"ElementaryTypeName","src":"1519:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1518:9:0"},"scope":136,"src":"1464:64:0","stateMutability":"view","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":119,"implemented":false,"kind":"function","modifiers":[],"name":"ttl","nodeType":"FunctionDefinition","parameters":{"id":115,"nodeType":"ParameterList","parameters":[{"constant":false,"id":114,"name":"node","nodeType":"VariableDeclaration","scope":119,"src":"1547:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":113,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1547:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"1546:14:0"},"returnParameters":{"id":118,"nodeType":"ParameterList","parameters":[{"constant":false,"id":117,"name":"","nodeType":"VariableDeclaration","scope":119,"src":"1584:6:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":116,"name":"uint64","nodeType":"ElementaryTypeName","src":"1584:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"1583:8:0"},"scope":136,"src":"1534:58:0","stateMutability":"view","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":126,"implemented":false,"kind":"function","modifiers":[],"name":"recordExists","nodeType":"FunctionDefinition","parameters":{"id":122,"nodeType":"ParameterList","parameters":[{"constant":false,"id":121,"name":"node","nodeType":"VariableDeclaration","scope":126,"src":"1620:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":120,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1620:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"1619:14:0"},"returnParameters":{"id":125,"nodeType":"ParameterList","parameters":[{"constant":false,"id":124,"name":"","nodeType":"VariableDeclaration","scope":126,"src":"1657:4:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":123,"name":"bool","nodeType":"ElementaryTypeName","src":"1657:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1656:6:0"},"scope":136,"src":"1598:65:0","stateMutability":"view","superFunction":null,"visibility":"external"},{"body":null,"documentation":null,"id":135,"implemented":false,"kind":"function","modifiers":[],"name":"isApprovedForAll","nodeType":"FunctionDefinition","parameters":{"id":131,"nodeType":"ParameterList","parameters":[{"constant":false,"id":128,"name":"owner","nodeType":"VariableDeclaration","scope":135,"src":"1695:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":127,"name":"address","nodeType":"ElementaryTypeName","src":"1695:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":130,"name":"operator","nodeType":"VariableDeclaration","scope":135,"src":"1710:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":129,"name":"address","nodeType":"ElementaryTypeName","src":"1710:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"1694:33:0"},"returnParameters":{"id":134,"nodeType":"ParameterList","parameters":[{"constant":false,"id":133,"name":"","nodeType":"VariableDeclaration","scope":135,"src":"1751:4:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":132,"name":"bool","nodeType":"ElementaryTypeName","src":"1751:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1750:6:0"},"scope":136,"src":"1669:88:0","stateMutability":"view","superFunction":null,"visibility":"external"}],"scope":651,"src":"142:1618:0"},{"id":137,"literals":["solidity","^","0.5",".0"],"nodeType":"PragmaDirective","src":"1818:23:0"},{"baseContracts":[{"arguments":null,"baseName":{"contractScope":null,"id":138,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":136,"src":"1912:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"id":139,"nodeType":"InheritanceSpecifier","src":"1912:3:0"}],"contractDependencies":[136],"contractKind":"contract","documentation":"The ENS registry contract.","fullyImplemented":true,"id":528,"linearizedBaseContracts":[528,136],"name":"ENSRegistry","nodeType":"ContractDefinition","nodes":[{"canonicalName":"ENSRegistry.Record","id":146,"members":[{"constant":false,"id":141,"name":"owner","nodeType":"VariableDeclaration","scope":146,"src":"1950:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":140,"name":"address","nodeType":"ElementaryTypeName","src":"1950:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":143,"name":"resolver","nodeType":"VariableDeclaration","scope":146,"src":"1974:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":142,"name":"address","nodeType":"ElementaryTypeName","src":"1974:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":145,"name":"ttl","nodeType":"VariableDeclaration","scope":146,"src":"2001:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":144,"name":"uint64","nodeType":"ElementaryTypeName","src":"2001:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"name":"Record","nodeType":"StructDefinition","scope":528,"src":"1925:94:0","visibility":"public"},{"constant":false,"id":150,"name":"records","nodeType":"VariableDeclaration","scope":528,"src":"2027:35:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record)"},"typeName":{"id":149,"keyType":{"id":147,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2036:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Mapping","src":"2027:27:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record)"},"valueType":{"contractScope":null,"id":148,"name":"Record","nodeType":"UserDefinedTypeName","referencedDeclaration":146,"src":"2047:6:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage_ptr","typeString":"struct ENSRegistry.Record"}}},"value":null,"visibility":"internal"},{"constant":false,"id":156,"name":"operators","nodeType":"VariableDeclaration","scope":528,"src":"2069:55:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"},"typeName":{"id":155,"keyType":{"id":151,"name":"address","nodeType":"ElementaryTypeName","src":"2078:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"2069:45:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"},"valueType":{"id":154,"keyType":{"id":152,"name":"address","nodeType":"ElementaryTypeName","src":"2097:7:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"2089:24:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"},"valueType":{"id":153,"name":"bool","nodeType":"ElementaryTypeName","src":"2108:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}}},"value":null,"visibility":"internal"},{"body":{"id":182,"nodeType":"Block","src":"2238:137:0","statements":[{"assignments":[161],"declarations":[{"constant":false,"id":161,"name":"owner","nodeType":"VariableDeclaration","scope":182,"src":"2249:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":160,"name":"address","nodeType":"ElementaryTypeName","src":"2249:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"id":166,"initialValue":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":162,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"2265:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":164,"indexExpression":{"argumentTypes":null,"id":163,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":158,"src":"2273:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2265:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":165,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":141,"src":"2265:19:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"2249:35:0"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":178,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":171,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":168,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":161,"src":"2303:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":169,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":665,"src":"2312:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":170,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2312:10:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"2303:19:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":172,"name":"operators","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":156,"src":"2326:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":174,"indexExpression":{"argumentTypes":null,"id":173,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":161,"src":"2336:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2326:16:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":177,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":175,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":665,"src":"2343:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":176,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2343:10:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2326:28:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"2303:51:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"}],"id":167,"name":"require","nodeType":"Identifier","overloadedDeclarations":[668,669],"referencedDeclaration":668,"src":"2295:7:0","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$returns$__$","typeString":"function (bool) pure"}},"id":179,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2295:60:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":180,"nodeType":"ExpressionStatement","src":"2295:60:0"},{"id":181,"nodeType":"PlaceholderStatement","src":"2366:1:0"}]},"documentation":null,"id":183,"name":"authorised","nodeType":"ModifierDefinition","parameters":{"id":159,"nodeType":"ParameterList","parameters":[{"constant":false,"id":158,"name":"node","nodeType":"VariableDeclaration","scope":183,"src":"2224:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":157,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2224:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"2223:14:0"},"src":"2204:171:0","visibility":"internal"},{"body":{"id":194,"nodeType":"Block","src":"2467:50:0","statements":[{"expression":{"argumentTypes":null,"id":192,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":186,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"2478:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":188,"indexExpression":{"argumentTypes":null,"hexValue":"307830","id":187,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2486:3:0","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0x0"},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2478:12:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":189,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":141,"src":"2478:18:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":190,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":665,"src":"2499:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":191,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2499:10:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"2478:31:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":193,"nodeType":"ExpressionStatement","src":"2478:31:0"}]},"documentation":"@dev Constructs a new ENS registrar.","id":195,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nodeType":"FunctionDefinition","parameters":{"id":184,"nodeType":"ParameterList","parameters":[],"src":"2457:2:0"},"returnParameters":{"id":185,"nodeType":"ParameterList","parameters":[],"src":"2467:0:0"},"scope":528,"src":"2446:71:0","stateMutability":"nonpayable","superFunction":null,"visibility":"public"},{"body":{"id":217,"nodeType":"Block","src":"2854:90:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":207,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":197,"src":"2874:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":208,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":199,"src":"2880:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":206,"name":"setOwner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":267,"src":"2865:8:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":209,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2865:21:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":210,"nodeType":"ExpressionStatement","src":"2865:21:0"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":212,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":197,"src":"2916:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":213,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":201,"src":"2922:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"argumentTypes":null,"id":214,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":203,"src":"2932:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"id":211,"name":"_setResolverAndTTL","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":527,"src":"2897:18:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$_t_uint64_$returns$__$","typeString":"function (bytes32,address,uint64)"}},"id":215,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2897:39:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":216,"nodeType":"ExpressionStatement","src":"2897:39:0"}]},"documentation":"@dev Sets the record for a node.\\n@param node The node to update.\\n@param owner The address of the new owner.\\n@param resolver The address of the resolver.\\n@param ttl The TTL in seconds.","id":218,"implemented":true,"kind":"function","modifiers":[],"name":"setRecord","nodeType":"FunctionDefinition","parameters":{"id":204,"nodeType":"ParameterList","parameters":[{"constant":false,"id":197,"name":"node","nodeType":"VariableDeclaration","scope":218,"src":"2786:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":196,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2786:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":199,"name":"owner","nodeType":"VariableDeclaration","scope":218,"src":"2800:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":198,"name":"address","nodeType":"ElementaryTypeName","src":"2800:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":201,"name":"resolver","nodeType":"VariableDeclaration","scope":218,"src":"2815:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":200,"name":"address","nodeType":"ElementaryTypeName","src":"2815:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":203,"name":"ttl","nodeType":"VariableDeclaration","scope":218,"src":"2833:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":202,"name":"uint64","nodeType":"ElementaryTypeName","src":"2833:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"2785:59:0"},"returnParameters":{"id":205,"nodeType":"ParameterList","parameters":[],"src":"2854:0:0"},"scope":528,"src":"2767:177:0","stateMutability":"nonpayable","superFunction":46,"visibility":"external"},{"body":{"id":245,"nodeType":"Block","src":"3370:125:0","statements":[{"assignments":[232],"declarations":[{"constant":false,"id":232,"name":"subnode","nodeType":"VariableDeclaration","scope":245,"src":"3381:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":231,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3381:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"id":238,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":234,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":220,"src":"3415:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":235,"name":"label","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":222,"src":"3421:5:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":236,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":224,"src":"3428:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":233,"name":"setSubnodeOwner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":305,"src":"3399:15:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_bytes32_$_t_address_$returns$_t_bytes32_$","typeString":"function (bytes32,bytes32,address) returns (bytes32)"}},"id":237,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"3399:35:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"3381:53:0"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":240,"name":"subnode","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":232,"src":"3464:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":241,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":226,"src":"3473:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"argumentTypes":null,"id":242,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":228,"src":"3483:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"id":239,"name":"_setResolverAndTTL","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":527,"src":"3445:18:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$_t_uint64_$returns$__$","typeString":"function (bytes32,address,uint64)"}},"id":243,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"3445:42:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":244,"nodeType":"ExpressionStatement","src":"3445:42:0"}]},"documentation":"@dev Sets the record for a subnode.\\n@param node The parent node.\\n@param label The hash of the label specifying the subnode.\\n@param owner The address of the new owner.\\n@param resolver The address of the resolver.\\n@param ttl The TTL in seconds.","id":246,"implemented":true,"kind":"function","modifiers":[],"name":"setSubnodeRecord","nodeType":"FunctionDefinition","parameters":{"id":229,"nodeType":"ParameterList","parameters":[{"constant":false,"id":220,"name":"node","nodeType":"VariableDeclaration","scope":246,"src":"3287:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":219,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3287:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":222,"name":"label","nodeType":"VariableDeclaration","scope":246,"src":"3301:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":221,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3301:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":224,"name":"owner","nodeType":"VariableDeclaration","scope":246,"src":"3316:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":223,"name":"address","nodeType":"ElementaryTypeName","src":"3316:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":226,"name":"resolver","nodeType":"VariableDeclaration","scope":246,"src":"3331:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":225,"name":"address","nodeType":"ElementaryTypeName","src":"3331:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":228,"name":"ttl","nodeType":"VariableDeclaration","scope":246,"src":"3349:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":227,"name":"uint64","nodeType":"ElementaryTypeName","src":"3349:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"3286:74:0"},"returnParameters":{"id":230,"nodeType":"ParameterList","parameters":[],"src":"3370:0:0"},"scope":528,"src":"3261:234:0","stateMutability":"nonpayable","superFunction":59,"visibility":"external"},{"body":{"id":266,"nodeType":"Block","src":"3812:78:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":257,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":248,"src":"3833:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":258,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":250,"src":"3839:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":256,"name":"_setOwner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":477,"src":"3823:9:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":259,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"3823:22:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":260,"nodeType":"ExpressionStatement","src":"3823:22:0"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":262,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":248,"src":"3870:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":263,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":250,"src":"3876:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":261,"name":"Transfer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":15,"src":"3861:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":264,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"3861:21:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":265,"nodeType":"EmitStatement","src":"3856:26:0"}]},"documentation":"@dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n@param node The node to transfer ownership of.\\n@param owner The address of the new owner.","id":267,"implemented":true,"kind":"function","modifiers":[{"arguments":[{"argumentTypes":null,"id":253,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":248,"src":"3806:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":254,"modifierName":{"argumentTypes":null,"id":252,"name":"authorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":183,"src":"3795:10:0","typeDescriptions":{"typeIdentifier":"t_modifier$_t_bytes32_$","typeString":"modifier (bytes32)"}},"nodeType":"ModifierInvocation","src":"3795:16:0"}],"name":"setOwner","nodeType":"FunctionDefinition","parameters":{"id":251,"nodeType":"ParameterList","parameters":[{"constant":false,"id":248,"name":"node","nodeType":"VariableDeclaration","scope":267,"src":"3759:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":247,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3759:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":250,"name":"owner","nodeType":"VariableDeclaration","scope":267,"src":"3773:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":249,"name":"address","nodeType":"ElementaryTypeName","src":"3773:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"3758:29:0"},"returnParameters":{"id":255,"nodeType":"ParameterList","parameters":[],"src":"3812:0:0"},"scope":528,"src":"3741:149:0","stateMutability":"nonpayable","superFunction":84,"visibility":"public"},{"body":{"id":304,"nodeType":"Block","src":"4320:182:0","statements":[{"assignments":[282],"declarations":[{"constant":false,"id":282,"name":"subnode","nodeType":"VariableDeclaration","scope":304,"src":"4331:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":281,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4331:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"id":290,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":286,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":269,"src":"4376:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":287,"name":"label","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":271,"src":"4382:5:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":284,"name":"abi","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":652,"src":"4359:3:0","typeDescriptions":{"typeIdentifier":"t_magic_abi","typeString":"abi"}},"id":285,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberName":"encodePacked","nodeType":"MemberAccess","referencedDeclaration":null,"src":"4359:16:0","typeDescriptions":{"typeIdentifier":"t_function_abiencodepacked_pure$__$returns$_t_bytes_memory_ptr_$","typeString":"function () pure returns (bytes memory)"}},"id":288,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"4359:29:0","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":283,"name":"keccak256","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":659,"src":"4349:9:0","typeDescriptions":{"typeIdentifier":"t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$","typeString":"function (bytes memory) pure returns (bytes32)"}},"id":289,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"4349:40:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"4331:58:0"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":292,"name":"subnode","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":282,"src":"4410:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":293,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":273,"src":"4419:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":291,"name":"_setOwner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":477,"src":"4400:9:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":294,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"4400:25:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":295,"nodeType":"ExpressionStatement","src":"4400:25:0"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":297,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":269,"src":"4450:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":298,"name":"label","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":271,"src":"4456:5:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":299,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":273,"src":"4463:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":296,"name":"NewOwner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":9,"src":"4441:8:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,bytes32,address)"}},"id":300,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"4441:28:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":301,"nodeType":"EmitStatement","src":"4436:33:0"},{"expression":{"argumentTypes":null,"id":302,"name":"subnode","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":282,"src":"4487:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"functionReturnParameters":280,"id":303,"nodeType":"Return","src":"4480:14:0"}]},"documentation":"@dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n@param node The parent node.\\n@param label The hash of the label specifying the subnode.\\n@param owner The address of the new owner.","id":305,"implemented":true,"kind":"function","modifiers":[{"arguments":[{"argumentTypes":null,"id":276,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":269,"src":"4297:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":277,"modifierName":{"argumentTypes":null,"id":275,"name":"authorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":183,"src":"4286:10:0","typeDescriptions":{"typeIdentifier":"t_modifier$_t_bytes32_$","typeString":"modifier (bytes32)"}},"nodeType":"ModifierInvocation","src":"4286:16:0"}],"name":"setSubnodeOwner","nodeType":"FunctionDefinition","parameters":{"id":274,"nodeType":"ParameterList","parameters":[{"constant":false,"id":269,"name":"node","nodeType":"VariableDeclaration","scope":305,"src":"4235:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":268,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4235:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":271,"name":"label","nodeType":"VariableDeclaration","scope":305,"src":"4249:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":270,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4249:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":273,"name":"owner","nodeType":"VariableDeclaration","scope":305,"src":"4264:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":272,"name":"address","nodeType":"ElementaryTypeName","src":"4264:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"4234:44:0"},"returnParameters":{"id":280,"nodeType":"ParameterList","parameters":[{"constant":false,"id":279,"name":"","nodeType":"VariableDeclaration","scope":305,"src":"4311:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":278,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4311:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"4310:9:0"},"scope":528,"src":"4210:292:0","stateMutability":"nonpayable","superFunction":70,"visibility":"public"},{"body":{"id":327,"nodeType":"Block","src":"4761:95:0","statements":[{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":316,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"4789:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":317,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":309,"src":"4795:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":315,"name":"NewResolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":21,"src":"4777:11:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":318,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"4777:27:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":319,"nodeType":"EmitStatement","src":"4772:32:0"},{"expression":{"argumentTypes":null,"id":325,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":320,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"4815:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":322,"indexExpression":{"argumentTypes":null,"id":321,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"4823:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"4815:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":323,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":143,"src":"4815:22:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":324,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":309,"src":"4840:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"4815:33:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":326,"nodeType":"ExpressionStatement","src":"4815:33:0"}]},"documentation":"@dev Sets the resolver address for the specified node.\\n@param node The node to update.\\n@param resolver The address of the resolver.","id":328,"implemented":true,"kind":"function","modifiers":[{"arguments":[{"argumentTypes":null,"id":312,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":307,"src":"4755:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":313,"modifierName":{"argumentTypes":null,"id":311,"name":"authorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":183,"src":"4744:10:0","typeDescriptions":{"typeIdentifier":"t_modifier$_t_bytes32_$","typeString":"modifier (bytes32)"}},"nodeType":"ModifierInvocation","src":"4744:16:0"}],"name":"setResolver","nodeType":"FunctionDefinition","parameters":{"id":310,"nodeType":"ParameterList","parameters":[{"constant":false,"id":307,"name":"node","nodeType":"VariableDeclaration","scope":328,"src":"4705:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":306,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4705:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":309,"name":"resolver","nodeType":"VariableDeclaration","scope":328,"src":"4719:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":308,"name":"address","nodeType":"ElementaryTypeName","src":"4719:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"4704:32:0"},"returnParameters":{"id":314,"nodeType":"ParameterList","parameters":[],"src":"4761:0:0"},"scope":528,"src":"4684:172:0","stateMutability":"nonpayable","superFunction":77,"visibility":"public"},{"body":{"id":350,"nodeType":"Block","src":"5077:75:0","statements":[{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":339,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":330,"src":"5100:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":340,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":332,"src":"5106:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"id":338,"name":"NewTTL","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":27,"src":"5093:6:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_uint64_$returns$__$","typeString":"function (bytes32,uint64)"}},"id":341,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"5093:17:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":342,"nodeType":"EmitStatement","src":"5088:22:0"},{"expression":{"argumentTypes":null,"id":348,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":343,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"5121:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":345,"indexExpression":{"argumentTypes":null,"id":344,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":330,"src":"5129:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"5121:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":346,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":145,"src":"5121:17:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":347,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":332,"src":"5141:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"src":"5121:23:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"id":349,"nodeType":"ExpressionStatement","src":"5121:23:0"}]},"documentation":"@dev Sets the TTL for the specified node.\\n@param node The node to update.\\n@param ttl The TTL in seconds.","id":351,"implemented":true,"kind":"function","modifiers":[{"arguments":[{"argumentTypes":null,"id":335,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":330,"src":"5071:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"id":336,"modifierName":{"argumentTypes":null,"id":334,"name":"authorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":183,"src":"5060:10:0","typeDescriptions":{"typeIdentifier":"t_modifier$_t_bytes32_$","typeString":"modifier (bytes32)"}},"nodeType":"ModifierInvocation","src":"5060:16:0"}],"name":"setTTL","nodeType":"FunctionDefinition","parameters":{"id":333,"nodeType":"ParameterList","parameters":[{"constant":false,"id":330,"name":"node","nodeType":"VariableDeclaration","scope":351,"src":"5027:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":329,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5027:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":332,"name":"ttl","nodeType":"VariableDeclaration","scope":351,"src":"5041:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":331,"name":"uint64","nodeType":"ElementaryTypeName","src":"5041:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"5026:26:0"},"returnParameters":{"id":337,"nodeType":"ParameterList","parameters":[],"src":"5077:0:0"},"scope":528,"src":"5011:141:0","stateMutability":"nonpayable","superFunction":91,"visibility":"public"},{"body":{"id":374,"nodeType":"Block","src":"5563:123:0","statements":[{"expression":{"argumentTypes":null,"id":365,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":358,"name":"operators","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":156,"src":"5574:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":362,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":359,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":665,"src":"5584:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":360,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"5584:10:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"5574:21:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":363,"indexExpression":{"argumentTypes":null,"id":361,"name":"operator","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":353,"src":"5596:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"5574:31:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":364,"name":"approved","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":355,"src":"5608:8:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"5574:42:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":366,"nodeType":"ExpressionStatement","src":"5574:42:0"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"expression":{"argumentTypes":null,"id":368,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":665,"src":"5647:3:0","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":369,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"5647:10:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},{"argumentTypes":null,"id":370,"name":"operator","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":353,"src":"5659:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"argumentTypes":null,"id":371,"name":"approved","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":355,"src":"5669:8:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address_payable","typeString":"address payable"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bool","typeString":"bool"}],"id":367,"name":"ApprovalForAll","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":35,"src":"5632:14:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_bool_$returns$__$","typeString":"function (address,address,bool)"}},"id":372,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"5632:46:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":373,"nodeType":"EmitStatement","src":"5627:51:0"}]},"documentation":"@dev Enable or disable approval for a third party (\\"operator\\") to manage\\n all of `msg.sender`\'s ENS records. Emits the ApprovalForAll event.\\n@param operator Address to add to the set of authorized operators.\\n@param approved True if the operator is approved, false to revoke approval.","id":375,"implemented":true,"kind":"function","modifiers":[],"name":"setApprovalForAll","nodeType":"FunctionDefinition","parameters":{"id":356,"nodeType":"ParameterList","parameters":[{"constant":false,"id":353,"name":"operator","nodeType":"VariableDeclaration","scope":375,"src":"5521:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":352,"name":"address","nodeType":"ElementaryTypeName","src":"5521:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":355,"name":"approved","nodeType":"VariableDeclaration","scope":375,"src":"5539:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":354,"name":"bool","nodeType":"ElementaryTypeName","src":"5539:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"5520:33:0"},"returnParameters":{"id":357,"nodeType":"ParameterList","parameters":[],"src":"5563:0:0"},"scope":528,"src":"5494:192:0","stateMutability":"nonpayable","superFunction":98,"visibility":"external"},{"body":{"id":402,"nodeType":"Block","src":"5912:160:0","statements":[{"assignments":[383],"declarations":[{"constant":false,"id":383,"name":"addr","nodeType":"VariableDeclaration","scope":402,"src":"5923:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":382,"name":"address","nodeType":"ElementaryTypeName","src":"5923:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"id":388,"initialValue":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":384,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"5938:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":386,"indexExpression":{"argumentTypes":null,"id":385,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":377,"src":"5946:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"5938:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":387,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":141,"src":"5938:19:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"5923:34:0"},{"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":393,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":389,"name":"addr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":383,"src":"5972:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":391,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":681,"src":"5988:4:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENSRegistry_$528","typeString":"contract ENSRegistry"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_ENSRegistry_$528","typeString":"contract ENSRegistry"}],"id":390,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"5980:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":392,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"5980:13:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"5972:21:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":399,"nodeType":"IfStatement","src":"5968:73:0","trueBody":{"id":398,"nodeType":"Block","src":"5995:46:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"hexValue":"307830","id":395,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6025:3:0","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0x0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":394,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"6017:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":396,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"6017:12:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"functionReturnParameters":381,"id":397,"nodeType":"Return","src":"6010:19:0"}]}},{"expression":{"argumentTypes":null,"id":400,"name":"addr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":383,"src":"6060:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":381,"id":401,"nodeType":"Return","src":"6053:11:0"}]},"documentation":"@dev Returns the address that owns the specified node.\\n@param node The specified node.\\n@return address of the owner.","id":403,"implemented":true,"kind":"function","modifiers":[],"name":"owner","nodeType":"FunctionDefinition","parameters":{"id":378,"nodeType":"ParameterList","parameters":[{"constant":false,"id":377,"name":"node","nodeType":"VariableDeclaration","scope":403,"src":"5868:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":376,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5868:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"5867:14:0"},"returnParameters":{"id":381,"nodeType":"ParameterList","parameters":[{"constant":false,"id":380,"name":"","nodeType":"VariableDeclaration","scope":403,"src":"5903:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":379,"name":"address","nodeType":"ElementaryTypeName","src":"5903:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"5902:9:0"},"scope":528,"src":"5853:219:0","stateMutability":"view","superFunction":105,"visibility":"public"},{"body":{"id":415,"nodeType":"Block","src":"6314:48:0","statements":[{"expression":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":410,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"6332:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":412,"indexExpression":{"argumentTypes":null,"id":411,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":405,"src":"6340:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"6332:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":413,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":143,"src":"6332:22:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":409,"id":414,"nodeType":"Return","src":"6325:29:0"}]},"documentation":"@dev Returns the address of the resolver for the specified node.\\n@param node The specified node.\\n@return address of the resolver.","id":416,"implemented":true,"kind":"function","modifiers":[],"name":"resolver","nodeType":"FunctionDefinition","parameters":{"id":406,"nodeType":"ParameterList","parameters":[{"constant":false,"id":405,"name":"node","nodeType":"VariableDeclaration","scope":416,"src":"6270:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":404,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6270:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"6269:14:0"},"returnParameters":{"id":409,"nodeType":"ParameterList","parameters":[{"constant":false,"id":408,"name":"","nodeType":"VariableDeclaration","scope":416,"src":"6305:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":407,"name":"address","nodeType":"ElementaryTypeName","src":"6305:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"6304:9:0"},"scope":528,"src":"6252:110:0","stateMutability":"view","superFunction":112,"visibility":"public"},{"body":{"id":428,"nodeType":"Block","src":"6593:43:0","statements":[{"expression":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":423,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"6611:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":425,"indexExpression":{"argumentTypes":null,"id":424,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":418,"src":"6619:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"6611:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":426,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":145,"src":"6611:17:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"functionReturnParameters":422,"id":427,"nodeType":"Return","src":"6604:24:0"}]},"documentation":"@dev Returns the TTL of a node, and any records associated with it.\\n@param node The specified node.\\n@return ttl of the node.","id":429,"implemented":true,"kind":"function","modifiers":[],"name":"ttl","nodeType":"FunctionDefinition","parameters":{"id":419,"nodeType":"ParameterList","parameters":[{"constant":false,"id":418,"name":"node","nodeType":"VariableDeclaration","scope":429,"src":"6550:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":417,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6550:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"6549:14:0"},"returnParameters":{"id":422,"nodeType":"ParameterList","parameters":[{"constant":false,"id":421,"name":"","nodeType":"VariableDeclaration","scope":429,"src":"6585:6:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":420,"name":"uint64","nodeType":"ElementaryTypeName","src":"6585:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"6584:8:0"},"scope":528,"src":"6537:99:0","stateMutability":"view","superFunction":119,"visibility":"public"},{"body":{"id":445,"nodeType":"Block","src":"6876:61:0","statements":[{"expression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":443,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":436,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"6894:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":438,"indexExpression":{"argumentTypes":null,"id":437,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":431,"src":"6902:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"6894:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":439,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":141,"src":"6894:19:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"hexValue":"307830","id":441,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"6925:3:0","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0x0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":440,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"6917:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":442,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"6917:12:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"6894:35:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":435,"id":444,"nodeType":"Return","src":"6887:42:0"}]},"documentation":"@dev Returns whether a record has been imported to the registry.\\n@param node The specified node.\\n@return Bool if record exists","id":446,"implemented":true,"kind":"function","modifiers":[],"name":"recordExists","nodeType":"FunctionDefinition","parameters":{"id":432,"nodeType":"ParameterList","parameters":[{"constant":false,"id":431,"name":"node","nodeType":"VariableDeclaration","scope":446,"src":"6835:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":430,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6835:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"6834:14:0"},"returnParameters":{"id":435,"nodeType":"ParameterList","parameters":[{"constant":false,"id":434,"name":"","nodeType":"VariableDeclaration","scope":446,"src":"6870:4:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":433,"name":"bool","nodeType":"ElementaryTypeName","src":"6870:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"6869:6:0"},"scope":528,"src":"6813:124:0","stateMutability":"view","superFunction":126,"visibility":"public"},{"body":{"id":461,"nodeType":"Block","src":"7346:52:0","statements":[{"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":455,"name":"operators","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":156,"src":"7364:9:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":457,"indexExpression":{"argumentTypes":null,"id":456,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":448,"src":"7374:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7364:16:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":459,"indexExpression":{"argumentTypes":null,"id":458,"name":"operator","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":450,"src":"7381:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7364:26:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":454,"id":460,"nodeType":"Return","src":"7357:33:0"}]},"documentation":"@dev Query if an address is an authorized operator for another address.\\n@param owner The address that owns the records.\\n@param operator The address that acts on behalf of the owner.\\n@return True if `operator` is an approved operator for `owner`, false otherwise.","id":462,"implemented":true,"kind":"function","modifiers":[],"name":"isApprovedForAll","nodeType":"FunctionDefinition","parameters":{"id":451,"nodeType":"ParameterList","parameters":[{"constant":false,"id":448,"name":"owner","nodeType":"VariableDeclaration","scope":462,"src":"7284:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":447,"name":"address","nodeType":"ElementaryTypeName","src":"7284:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":450,"name":"operator","nodeType":"VariableDeclaration","scope":462,"src":"7299:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":449,"name":"address","nodeType":"ElementaryTypeName","src":"7299:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"7283:33:0"},"returnParameters":{"id":454,"nodeType":"ParameterList","parameters":[{"constant":false,"id":453,"name":"","nodeType":"VariableDeclaration","scope":462,"src":"7340:4:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":452,"name":"bool","nodeType":"ElementaryTypeName","src":"7340:4:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"7339:6:0"},"scope":528,"src":"7258:140:0","stateMutability":"view","superFunction":135,"visibility":"external"},{"body":{"id":476,"nodeType":"Block","src":"7463:46:0","statements":[{"expression":{"argumentTypes":null,"id":474,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":469,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"7474:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":471,"indexExpression":{"argumentTypes":null,"id":470,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":464,"src":"7482:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7474:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":472,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":141,"src":"7474:19:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":473,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":466,"src":"7496:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"7474:27:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":475,"nodeType":"ExpressionStatement","src":"7474:27:0"}]},"documentation":null,"id":477,"implemented":true,"kind":"function","modifiers":[],"name":"_setOwner","nodeType":"FunctionDefinition","parameters":{"id":467,"nodeType":"ParameterList","parameters":[{"constant":false,"id":464,"name":"node","nodeType":"VariableDeclaration","scope":477,"src":"7425:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":463,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7425:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":466,"name":"owner","nodeType":"VariableDeclaration","scope":477,"src":"7439:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":465,"name":"address","nodeType":"ElementaryTypeName","src":"7439:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"7424:29:0"},"returnParameters":{"id":468,"nodeType":"ParameterList","parameters":[],"src":"7463:0:0"},"scope":528,"src":"7406:103:0","stateMutability":"nonpayable","superFunction":null,"visibility":"internal"},{"body":{"id":526,"nodeType":"Block","src":"7598:292:0","statements":[{"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":491,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":486,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":481,"src":"7612:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":487,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"7624:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":489,"indexExpression":{"argumentTypes":null,"id":488,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7632:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7624:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":490,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":143,"src":"7624:22:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"7612:34:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":505,"nodeType":"IfStatement","src":"7609:146:0","trueBody":{"id":504,"nodeType":"Block","src":"7648:107:0","statements":[{"expression":{"argumentTypes":null,"id":497,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":492,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"7663:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":494,"indexExpression":{"argumentTypes":null,"id":493,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7671:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7663:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":495,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":143,"src":"7663:22:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":496,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":481,"src":"7688:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"7663:33:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":498,"nodeType":"ExpressionStatement","src":"7663:33:0"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":500,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7728:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":501,"name":"resolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":481,"src":"7734:8:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":499,"name":"NewResolver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":21,"src":"7716:11:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":502,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"7716:27:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":503,"nodeType":"EmitStatement","src":"7711:32:0"}]}},{"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_uint64","typeString":"uint64"},"id":511,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":506,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":483,"src":"7770:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":507,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"7777:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":509,"indexExpression":{"argumentTypes":null,"id":508,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7785:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7777:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":510,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":145,"src":"7777:17:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"src":"7770:24:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":525,"nodeType":"IfStatement","src":"7767:116:0","trueBody":{"id":524,"nodeType":"Block","src":"7796:87:0","statements":[{"expression":{"argumentTypes":null,"id":517,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"expression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":512,"name":"records","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":150,"src":"7811:7:0","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_struct$_Record_$146_storage_$","typeString":"mapping(bytes32 => struct ENSRegistry.Record storage ref)"}},"id":514,"indexExpression":{"argumentTypes":null,"id":513,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7819:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"7811:13:0","typeDescriptions":{"typeIdentifier":"t_struct$_Record_$146_storage","typeString":"struct ENSRegistry.Record storage ref"}},"id":515,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":145,"src":"7811:17:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":516,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":483,"src":"7831:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"src":"7811:23:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"id":518,"nodeType":"ExpressionStatement","src":"7811:23:0"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":520,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"7861:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":521,"name":"ttl","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":483,"src":"7867:3:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"id":519,"name":"NewTTL","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":27,"src":"7854:6:0","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_uint64_$returns$__$","typeString":"function (bytes32,uint64)"}},"id":522,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"7854:17:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":523,"nodeType":"EmitStatement","src":"7849:22:0"}]}}]},"documentation":null,"id":527,"implemented":true,"kind":"function","modifiers":[],"name":"_setResolverAndTTL","nodeType":"FunctionDefinition","parameters":{"id":484,"nodeType":"ParameterList","parameters":[{"constant":false,"id":479,"name":"node","nodeType":"VariableDeclaration","scope":527,"src":"7545:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":478,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7545:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":481,"name":"resolver","nodeType":"VariableDeclaration","scope":527,"src":"7559:16:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":480,"name":"address","nodeType":"ElementaryTypeName","src":"7559:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":483,"name":"ttl","nodeType":"VariableDeclaration","scope":527,"src":"7577:10:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":482,"name":"uint64","nodeType":"ElementaryTypeName","src":"7577:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"7544:44:0"},"returnParameters":{"id":485,"nodeType":"ParameterList","parameters":[],"src":"7598:0:0"},"scope":528,"src":"7517:373:0","stateMutability":"nonpayable","superFunction":null,"visibility":"internal"}],"scope":651,"src":"1888:6005:0"},{"id":529,"literals":["solidity","^","0.5",".0"],"nodeType":"PragmaDirective","src":"7963:23:0"},{"baseContracts":[{"arguments":null,"baseName":{"contractScope":null,"id":530,"name":"ENSRegistry","nodeType":"UserDefinedTypeName","referencedDeclaration":528,"src":"8071:11:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENSRegistry_$528","typeString":"contract ENSRegistry"}},"id":531,"nodeType":"InheritanceSpecifier","src":"8071:11:0"}],"contractDependencies":[136,528],"contractKind":"contract","documentation":"The ENS registry contract.","fullyImplemented":true,"id":650,"linearizedBaseContracts":[650,528,136],"name":"ENSRegistryWithFallback","nodeType":"ContractDefinition","nodes":[{"constant":false,"id":533,"name":"old","nodeType":"VariableDeclaration","scope":650,"src":"8092:14:0","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":532,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":136,"src":"8092:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"value":null,"visibility":"public"},{"body":{"id":544,"nodeType":"Block","src":"8221:29:0","statements":[{"expression":{"argumentTypes":null,"id":542,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":540,"name":"old","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":533,"src":"8232:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":541,"name":"_old","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":535,"src":"8238:4:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"src":"8232:10:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"id":543,"nodeType":"ExpressionStatement","src":"8232:10:0"}]},"documentation":"@dev Constructs a new ENS registrar.","id":545,"implemented":true,"kind":"constructor","modifiers":[{"arguments":[],"id":538,"modifierName":{"argumentTypes":null,"id":537,"name":"ENSRegistry","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":528,"src":"8207:11:0","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ENSRegistry_$528_$","typeString":"type(contract ENSRegistry)"}},"nodeType":"ModifierInvocation","src":"8207:13:0"}],"name":"","nodeType":"FunctionDefinition","parameters":{"id":536,"nodeType":"ParameterList","parameters":[{"constant":false,"id":535,"name":"_old","nodeType":"VariableDeclaration","scope":545,"src":"8190:8:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":534,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":136,"src":"8190:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"value":null,"visibility":"internal"}],"src":"8189:10:0"},"returnParameters":{"id":539,"nodeType":"ParameterList","parameters":[],"src":"8221:0:0"},"scope":650,"src":"8178:72:0","stateMutability":"nonpayable","superFunction":null,"visibility":"public"},{"body":{"id":568,"nodeType":"Block","src":"8492:135:0","statements":[{"condition":{"argumentTypes":null,"id":555,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"!","prefix":true,"src":"8507:19:0","subExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":553,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":547,"src":"8521:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":552,"name":"recordExists","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":446,"src":"8508:12:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_bool_$","typeString":"function (bytes32) view returns (bool)"}},"id":554,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8508:18:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":562,"nodeType":"IfStatement","src":"8503:77:0","trueBody":{"id":561,"nodeType":"Block","src":"8528:52:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":558,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":547,"src":"8563:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":556,"name":"old","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":533,"src":"8550:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"id":557,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":112,"src":"8550:12:0","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view external returns (address)"}},"id":559,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8550:18:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":551,"id":560,"nodeType":"Return","src":"8543:25:0"}]}},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":565,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":547,"src":"8614:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":563,"name":"super","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":684,"src":"8599:5:0","typeDescriptions":{"typeIdentifier":"t_super$_ENSRegistryWithFallback_$650","typeString":"contract super ENSRegistryWithFallback"}},"id":564,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"resolver","nodeType":"MemberAccess","referencedDeclaration":416,"src":"8599:14:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view returns (address)"}},"id":566,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8599:20:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":551,"id":567,"nodeType":"Return","src":"8592:27:0"}]},"documentation":"@dev Returns the address of the resolver for the specified node.\\n@param node The specified node.\\n@return address of the resolver.","id":569,"implemented":true,"kind":"function","modifiers":[],"name":"resolver","nodeType":"FunctionDefinition","parameters":{"id":548,"nodeType":"ParameterList","parameters":[{"constant":false,"id":547,"name":"node","nodeType":"VariableDeclaration","scope":569,"src":"8448:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":546,"name":"bytes32","nodeType":"ElementaryTypeName","src":"8448:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"8447:14:0"},"returnParameters":{"id":551,"nodeType":"ParameterList","parameters":[{"constant":false,"id":550,"name":"","nodeType":"VariableDeclaration","scope":569,"src":"8483:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":549,"name":"address","nodeType":"ElementaryTypeName","src":"8483:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"8482:9:0"},"scope":650,"src":"8430:197:0","stateMutability":"view","superFunction":416,"visibility":"public"},{"body":{"id":592,"nodeType":"Block","src":"8853:129:0","statements":[{"condition":{"argumentTypes":null,"id":579,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"!","prefix":true,"src":"8868:19:0","subExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":577,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":571,"src":"8882:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":576,"name":"recordExists","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":446,"src":"8869:12:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_bool_$","typeString":"function (bytes32) view returns (bool)"}},"id":578,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8869:18:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":586,"nodeType":"IfStatement","src":"8864:74:0","trueBody":{"id":585,"nodeType":"Block","src":"8889:49:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":582,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":571,"src":"8921:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":580,"name":"old","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":533,"src":"8911:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"id":581,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":105,"src":"8911:9:0","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view external returns (address)"}},"id":583,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8911:15:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":575,"id":584,"nodeType":"Return","src":"8904:22:0"}]}},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":589,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":571,"src":"8969:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":587,"name":"super","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":684,"src":"8957:5:0","typeDescriptions":{"typeIdentifier":"t_super$_ENSRegistryWithFallback_$650","typeString":"contract super ENSRegistryWithFallback"}},"id":588,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":403,"src":"8957:11:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view returns (address)"}},"id":590,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"8957:17:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":575,"id":591,"nodeType":"Return","src":"8950:24:0"}]},"documentation":"@dev Returns the address that owns the specified node.\\n@param node The specified node.\\n@return address of the owner.","id":593,"implemented":true,"kind":"function","modifiers":[],"name":"owner","nodeType":"FunctionDefinition","parameters":{"id":572,"nodeType":"ParameterList","parameters":[{"constant":false,"id":571,"name":"node","nodeType":"VariableDeclaration","scope":593,"src":"8809:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":570,"name":"bytes32","nodeType":"ElementaryTypeName","src":"8809:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"8808:14:0"},"returnParameters":{"id":575,"nodeType":"ParameterList","parameters":[{"constant":false,"id":574,"name":"","nodeType":"VariableDeclaration","scope":593,"src":"8844:7:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":573,"name":"address","nodeType":"ElementaryTypeName","src":"8844:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"8843:9:0"},"scope":650,"src":"8794:188:0","stateMutability":"view","superFunction":403,"visibility":"public"},{"body":{"id":616,"nodeType":"Block","src":"9213:125:0","statements":[{"condition":{"argumentTypes":null,"id":603,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"!","prefix":true,"src":"9228:19:0","subExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":601,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":595,"src":"9242:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":600,"name":"recordExists","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":446,"src":"9229:12:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_bool_$","typeString":"function (bytes32) view returns (bool)"}},"id":602,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9229:18:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":610,"nodeType":"IfStatement","src":"9224:72:0","trueBody":{"id":609,"nodeType":"Block","src":"9249:47:0","statements":[{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":606,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":595,"src":"9279:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":604,"name":"old","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":533,"src":"9271:3:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$136","typeString":"contract ENS"}},"id":605,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":119,"src":"9271:7:0","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_bytes32_$returns$_t_uint64_$","typeString":"function (bytes32) view external returns (uint64)"}},"id":607,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9271:13:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"functionReturnParameters":599,"id":608,"nodeType":"Return","src":"9264:20:0"}]}},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":613,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":595,"src":"9325:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":611,"name":"super","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":684,"src":"9315:5:0","typeDescriptions":{"typeIdentifier":"t_super$_ENSRegistryWithFallback_$650","typeString":"contract super ENSRegistryWithFallback"}},"id":612,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"ttl","nodeType":"MemberAccess","referencedDeclaration":429,"src":"9315:9:0","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes32_$returns$_t_uint64_$","typeString":"function (bytes32) view returns (uint64)"}},"id":614,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9315:15:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"functionReturnParameters":599,"id":615,"nodeType":"Return","src":"9308:22:0"}]},"documentation":"@dev Returns the TTL of a node, and any records associated with it.\\n@param node The specified node.\\n@return ttl of the node.","id":617,"implemented":true,"kind":"function","modifiers":[],"name":"ttl","nodeType":"FunctionDefinition","parameters":{"id":596,"nodeType":"ParameterList","parameters":[{"constant":false,"id":595,"name":"node","nodeType":"VariableDeclaration","scope":617,"src":"9170:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":594,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9170:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"9169:14:0"},"returnParameters":{"id":599,"nodeType":"ParameterList","parameters":[{"constant":false,"id":598,"name":"","nodeType":"VariableDeclaration","scope":617,"src":"9205:6:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":597,"name":"uint64","nodeType":"ElementaryTypeName","src":"9205:6:0","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":null,"visibility":"internal"}],"src":"9204:8:0"},"scope":650,"src":"9157:181:0","stateMutability":"view","superFunction":429,"visibility":"public"},{"body":{"id":648,"nodeType":"Block","src":"9403:162:0","statements":[{"assignments":[625],"declarations":[{"constant":false,"id":625,"name":"addr","nodeType":"VariableDeclaration","scope":648,"src":"9414:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":624,"name":"address","nodeType":"ElementaryTypeName","src":"9414:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"id":627,"initialValue":{"argumentTypes":null,"id":626,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":621,"src":"9429:5:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"9414:20:0"},{"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":632,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":628,"name":"addr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":625,"src":"9449:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"hexValue":"307830","id":630,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"9465:3:0","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0x0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":629,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"9457:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":631,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9457:12:0","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"9449:20:0","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"falseBody":null,"id":640,"nodeType":"IfStatement","src":"9445:73:0","trueBody":{"id":639,"nodeType":"Block","src":"9471:47:0","statements":[{"expression":{"argumentTypes":null,"id":637,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":633,"name":"addr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":625,"src":"9486:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":635,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":683,"src":"9501:4:0","typeDescriptions":{"typeIdentifier":"t_contract$_ENSRegistryWithFallback_$650","typeString":"contract ENSRegistryWithFallback"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_ENSRegistryWithFallback_$650","typeString":"contract ENSRegistryWithFallback"}],"id":634,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"9493:7:0","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":636,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9493:13:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"9486:20:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":638,"nodeType":"ExpressionStatement","src":"9486:20:0"}]}},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":644,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":619,"src":"9546:4:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"id":645,"name":"addr","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":625,"src":"9552:4:0","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"argumentTypes":null,"id":641,"name":"super","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":684,"src":"9530:5:0","typeDescriptions":{"typeIdentifier":"t_super$_ENSRegistryWithFallback_$650","typeString":"contract super ENSRegistryWithFallback"}},"id":643,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"_setOwner","nodeType":"MemberAccess","referencedDeclaration":477,"src":"9530:15:0","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_bytes32_$_t_address_$returns$__$","typeString":"function (bytes32,address)"}},"id":646,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"9530:27:0","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":647,"nodeType":"ExpressionStatement","src":"9530:27:0"}]},"documentation":null,"id":649,"implemented":true,"kind":"function","modifiers":[],"name":"_setOwner","nodeType":"FunctionDefinition","parameters":{"id":622,"nodeType":"ParameterList","parameters":[{"constant":false,"id":619,"name":"node","nodeType":"VariableDeclaration","scope":649,"src":"9365:12:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":618,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9365:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":621,"name":"owner","nodeType":"VariableDeclaration","scope":649,"src":"9379:13:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":620,"name":"address","nodeType":"ElementaryTypeName","src":"9379:7:0","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"src":"9364:29:0"},"returnParameters":{"id":623,"nodeType":"ParameterList","parameters":[],"src":"9403:0:0"},"scope":650,"src":"9346:219:0","stateMutability":"nonpayable","superFunction":477,"visibility":"internal"}],"scope":651,"src":"8035:1533:0"}],"src":"113:9455:0"},"legacyAST":{"attributes":{"absolutePath":"ENSRegistryWithFallback.sol","exportedSymbols":{"ENS":[136],"ENSRegistry":[528],"ENSRegistryWithFallback":[650]}},"children":[{"attributes":{"literals":["solidity",">=","0.4",".24"]},"id":1,"name":"PragmaDirective","src":"113:25:0"},{"attributes":{"baseContracts":[null],"contractDependencies":[null],"contractKind":"interface","documentation":null,"fullyImplemented":false,"linearizedBaseContracts":[136],"name":"ENS","scope":651},"children":[{"attributes":{"anonymous":false,"documentation":null,"name":"NewOwner"},"children":[{"children":[{"attributes":{"constant":false,"indexed":true,"name":"node","scope":9,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":2,"name":"ElementaryTypeName","src":"254:7:0"}],"id":3,"name":"VariableDeclaration","src":"254:20:0"},{"attributes":{"constant":false,"indexed":true,"name":"label","scope":9,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":4,"name":"ElementaryTypeName","src":"276:7:0"}],"id":5,"name":"VariableDeclaration","src":"276:21:0"},{"attributes":{"constant":false,"indexed":false,"name":"owner","scope":9,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":6,"name":"ElementaryTypeName","src":"299:7:0"}],"id":7,"name":"VariableDeclaration","src":"299:13:0"}],"id":8,"name":"ParameterList","src":"253:60:0"}],"id":9,"name":"EventDefinition","src":"239:75:0"},{"attributes":{"anonymous":false,"documentation":null,"name":"Transfer"},"children":[{"children":[{"attributes":{"constant":false,"indexed":true,"name":"node","scope":15,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":10,"name":"ElementaryTypeName","src":"415:7:0"}],"id":11,"name":"VariableDeclaration","src":"415:20:0"},{"attributes":{"constant":false,"indexed":false,"name":"owner","scope":15,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":12,"name":"ElementaryTypeName","src":"437:7:0"}],"id":13,"name":"VariableDeclaration","src":"437:13:0"}],"id":14,"name":"ParameterList","src":"414:37:0"}],"id":15,"name":"EventDefinition","src":"400:52:0"},{"attributes":{"anonymous":false,"documentation":null,"name":"NewResolver"},"children":[{"children":[{"attributes":{"constant":false,"indexed":true,"name":"node","scope":21,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":16,"name":"ElementaryTypeName","src":"531:7:0"}],"id":17,"name":"VariableDeclaration","src":"531:20:0"},{"attributes":{"constant":false,"indexed":false,"name":"resolver","scope":21,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":18,"name":"ElementaryTypeName","src":"553:7:0"}],"id":19,"name":"VariableDeclaration","src":"553:16:0"}],"id":20,"name":"ParameterList","src":"530:40:0"}],"id":21,"name":"EventDefinition","src":"513:58:0"},{"attributes":{"anonymous":false,"documentation":null,"name":"NewTTL"},"children":[{"children":[{"attributes":{"constant":false,"indexed":true,"name":"node","scope":27,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":22,"name":"ElementaryTypeName","src":"638:7:0"}],"id":23,"name":"VariableDeclaration","src":"638:20:0"},{"attributes":{"constant":false,"indexed":false,"name":"ttl","scope":27,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":24,"name":"ElementaryTypeName","src":"660:6:0"}],"id":25,"name":"VariableDeclaration","src":"660:10:0"}],"id":26,"name":"ParameterList","src":"637:34:0"}],"id":27,"name":"EventDefinition","src":"625:47:0"},{"attributes":{"anonymous":false,"documentation":null,"name":"ApprovalForAll"},"children":[{"children":[{"attributes":{"constant":false,"indexed":true,"name":"owner","scope":35,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":28,"name":"ElementaryTypeName","src":"754:7:0"}],"id":29,"name":"VariableDeclaration","src":"754:21:0"},{"attributes":{"constant":false,"indexed":true,"name":"operator","scope":35,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":30,"name":"ElementaryTypeName","src":"777:7:0"}],"id":31,"name":"VariableDeclaration","src":"777:24:0"},{"attributes":{"constant":false,"indexed":false,"name":"approved","scope":35,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":32,"name":"ElementaryTypeName","src":"803:4:0"}],"id":33,"name":"VariableDeclaration","src":"803:13:0"}],"id":34,"name":"ParameterList","src":"753:64:0"}],"id":35,"name":"EventDefinition","src":"733:85:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setRecord","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":46,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":36,"name":"ElementaryTypeName","src":"845:7:0"}],"id":37,"name":"VariableDeclaration","src":"845:12:0"},{"attributes":{"constant":false,"name":"owner","scope":46,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":38,"name":"ElementaryTypeName","src":"859:7:0"}],"id":39,"name":"VariableDeclaration","src":"859:13:0"},{"attributes":{"constant":false,"name":"resolver","scope":46,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":40,"name":"ElementaryTypeName","src":"874:7:0"}],"id":41,"name":"VariableDeclaration","src":"874:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":46,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":42,"name":"ElementaryTypeName","src":"892:6:0"}],"id":43,"name":"VariableDeclaration","src":"892:10:0"}],"id":44,"name":"ParameterList","src":"844:59:0"},{"attributes":{"parameters":[null]},"children":[],"id":45,"name":"ParameterList","src":"912:0:0"}],"id":46,"name":"FunctionDefinition","src":"826:87:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setSubnodeRecord","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":59,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":47,"name":"ElementaryTypeName","src":"945:7:0"}],"id":48,"name":"VariableDeclaration","src":"945:12:0"},{"attributes":{"constant":false,"name":"label","scope":59,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":49,"name":"ElementaryTypeName","src":"959:7:0"}],"id":50,"name":"VariableDeclaration","src":"959:13:0"},{"attributes":{"constant":false,"name":"owner","scope":59,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":51,"name":"ElementaryTypeName","src":"974:7:0"}],"id":52,"name":"VariableDeclaration","src":"974:13:0"},{"attributes":{"constant":false,"name":"resolver","scope":59,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":53,"name":"ElementaryTypeName","src":"989:7:0"}],"id":54,"name":"VariableDeclaration","src":"989:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":59,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":55,"name":"ElementaryTypeName","src":"1007:6:0"}],"id":56,"name":"VariableDeclaration","src":"1007:10:0"}],"id":57,"name":"ParameterList","src":"944:74:0"},{"attributes":{"parameters":[null]},"children":[],"id":58,"name":"ParameterList","src":"1027:0:0"}],"id":59,"name":"FunctionDefinition","src":"919:109:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setSubnodeOwner","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":70,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":60,"name":"ElementaryTypeName","src":"1059:7:0"}],"id":61,"name":"VariableDeclaration","src":"1059:12:0"},{"attributes":{"constant":false,"name":"label","scope":70,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":62,"name":"ElementaryTypeName","src":"1073:7:0"}],"id":63,"name":"VariableDeclaration","src":"1073:13:0"},{"attributes":{"constant":false,"name":"owner","scope":70,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":64,"name":"ElementaryTypeName","src":"1088:7:0"}],"id":65,"name":"VariableDeclaration","src":"1088:13:0"}],"id":66,"name":"ParameterList","src":"1058:44:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":70,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":67,"name":"ElementaryTypeName","src":"1120:7:0"}],"id":68,"name":"VariableDeclaration","src":"1120:7:0"}],"id":69,"name":"ParameterList","src":"1119:9:0"}],"id":70,"name":"FunctionDefinition","src":"1034:95:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setResolver","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":77,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":71,"name":"ElementaryTypeName","src":"1156:7:0"}],"id":72,"name":"VariableDeclaration","src":"1156:12:0"},{"attributes":{"constant":false,"name":"resolver","scope":77,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":73,"name":"ElementaryTypeName","src":"1170:7:0"}],"id":74,"name":"VariableDeclaration","src":"1170:16:0"}],"id":75,"name":"ParameterList","src":"1155:32:0"},{"attributes":{"parameters":[null]},"children":[],"id":76,"name":"ParameterList","src":"1196:0:0"}],"id":77,"name":"FunctionDefinition","src":"1135:62:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setOwner","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":84,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":78,"name":"ElementaryTypeName","src":"1221:7:0"}],"id":79,"name":"VariableDeclaration","src":"1221:12:0"},{"attributes":{"constant":false,"name":"owner","scope":84,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":80,"name":"ElementaryTypeName","src":"1235:7:0"}],"id":81,"name":"VariableDeclaration","src":"1235:13:0"}],"id":82,"name":"ParameterList","src":"1220:29:0"},{"attributes":{"parameters":[null]},"children":[],"id":83,"name":"ParameterList","src":"1258:0:0"}],"id":84,"name":"FunctionDefinition","src":"1203:56:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setTTL","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":91,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":85,"name":"ElementaryTypeName","src":"1281:7:0"}],"id":86,"name":"VariableDeclaration","src":"1281:12:0"},{"attributes":{"constant":false,"name":"ttl","scope":91,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":87,"name":"ElementaryTypeName","src":"1295:6:0"}],"id":88,"name":"VariableDeclaration","src":"1295:10:0"}],"id":89,"name":"ParameterList","src":"1280:26:0"},{"attributes":{"parameters":[null]},"children":[],"id":90,"name":"ParameterList","src":"1315:0:0"}],"id":91,"name":"FunctionDefinition","src":"1265:51:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setApprovalForAll","scope":136,"stateMutability":"nonpayable","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"operator","scope":98,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":92,"name":"ElementaryTypeName","src":"1349:7:0"}],"id":93,"name":"VariableDeclaration","src":"1349:16:0"},{"attributes":{"constant":false,"name":"approved","scope":98,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":94,"name":"ElementaryTypeName","src":"1367:4:0"}],"id":95,"name":"VariableDeclaration","src":"1367:13:0"}],"id":96,"name":"ParameterList","src":"1348:33:0"},{"attributes":{"parameters":[null]},"children":[],"id":97,"name":"ParameterList","src":"1390:0:0"}],"id":98,"name":"FunctionDefinition","src":"1322:69:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"owner","scope":136,"stateMutability":"view","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":105,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":99,"name":"ElementaryTypeName","src":"1412:7:0"}],"id":100,"name":"VariableDeclaration","src":"1412:12:0"}],"id":101,"name":"ParameterList","src":"1411:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":105,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":102,"name":"ElementaryTypeName","src":"1449:7:0"}],"id":103,"name":"VariableDeclaration","src":"1449:7:0"}],"id":104,"name":"ParameterList","src":"1448:9:0"}],"id":105,"name":"FunctionDefinition","src":"1397:61:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"resolver","scope":136,"stateMutability":"view","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":112,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":106,"name":"ElementaryTypeName","src":"1482:7:0"}],"id":107,"name":"VariableDeclaration","src":"1482:12:0"}],"id":108,"name":"ParameterList","src":"1481:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":112,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":109,"name":"ElementaryTypeName","src":"1519:7:0"}],"id":110,"name":"VariableDeclaration","src":"1519:7:0"}],"id":111,"name":"ParameterList","src":"1518:9:0"}],"id":112,"name":"FunctionDefinition","src":"1464:64:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"ttl","scope":136,"stateMutability":"view","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":119,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":113,"name":"ElementaryTypeName","src":"1547:7:0"}],"id":114,"name":"VariableDeclaration","src":"1547:12:0"}],"id":115,"name":"ParameterList","src":"1546:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":119,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":116,"name":"ElementaryTypeName","src":"1584:6:0"}],"id":117,"name":"VariableDeclaration","src":"1584:6:0"}],"id":118,"name":"ParameterList","src":"1583:8:0"}],"id":119,"name":"FunctionDefinition","src":"1534:58:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"recordExists","scope":136,"stateMutability":"view","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":126,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":120,"name":"ElementaryTypeName","src":"1620:7:0"}],"id":121,"name":"VariableDeclaration","src":"1620:12:0"}],"id":122,"name":"ParameterList","src":"1619:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":126,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":123,"name":"ElementaryTypeName","src":"1657:4:0"}],"id":124,"name":"VariableDeclaration","src":"1657:4:0"}],"id":125,"name":"ParameterList","src":"1656:6:0"}],"id":126,"name":"FunctionDefinition","src":"1598:65:0"},{"attributes":{"body":null,"documentation":null,"implemented":false,"isConstructor":false,"kind":"function","modifiers":[null],"name":"isApprovedForAll","scope":136,"stateMutability":"view","superFunction":null,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"owner","scope":135,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":127,"name":"ElementaryTypeName","src":"1695:7:0"}],"id":128,"name":"VariableDeclaration","src":"1695:13:0"},{"attributes":{"constant":false,"name":"operator","scope":135,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":129,"name":"ElementaryTypeName","src":"1710:7:0"}],"id":130,"name":"VariableDeclaration","src":"1710:16:0"}],"id":131,"name":"ParameterList","src":"1694:33:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":135,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":132,"name":"ElementaryTypeName","src":"1751:4:0"}],"id":133,"name":"VariableDeclaration","src":"1751:4:0"}],"id":134,"name":"ParameterList","src":"1750:6:0"}],"id":135,"name":"FunctionDefinition","src":"1669:88:0"}],"id":136,"name":"ContractDefinition","src":"142:1618:0"},{"attributes":{"literals":["solidity","^","0.5",".0"]},"id":137,"name":"PragmaDirective","src":"1818:23:0"},{"attributes":{"contractDependencies":[136],"contractKind":"contract","documentation":"The ENS registry contract.","fullyImplemented":true,"linearizedBaseContracts":[528,136],"name":"ENSRegistry","scope":651},"children":[{"attributes":{"arguments":null},"children":[{"attributes":{"contractScope":null,"name":"ENS","referencedDeclaration":136,"type":"contract ENS"},"id":138,"name":"UserDefinedTypeName","src":"1912:3:0"}],"id":139,"name":"InheritanceSpecifier","src":"1912:3:0"},{"attributes":{"canonicalName":"ENSRegistry.Record","name":"Record","scope":528,"visibility":"public"},"children":[{"attributes":{"constant":false,"name":"owner","scope":146,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":140,"name":"ElementaryTypeName","src":"1950:7:0"}],"id":141,"name":"VariableDeclaration","src":"1950:13:0"},{"attributes":{"constant":false,"name":"resolver","scope":146,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":142,"name":"ElementaryTypeName","src":"1974:7:0"}],"id":143,"name":"VariableDeclaration","src":"1974:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":146,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":144,"name":"ElementaryTypeName","src":"2001:6:0"}],"id":145,"name":"VariableDeclaration","src":"2001:10:0"}],"id":146,"name":"StructDefinition","src":"1925:94:0"},{"attributes":{"constant":false,"name":"records","scope":528,"stateVariable":true,"storageLocation":"default","type":"mapping(bytes32 => struct ENSRegistry.Record)","value":null,"visibility":"internal"},"children":[{"attributes":{"type":"mapping(bytes32 => struct ENSRegistry.Record)"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":147,"name":"ElementaryTypeName","src":"2036:7:0"},{"attributes":{"contractScope":null,"name":"Record","referencedDeclaration":146,"type":"struct ENSRegistry.Record"},"id":148,"name":"UserDefinedTypeName","src":"2047:6:0"}],"id":149,"name":"Mapping","src":"2027:27:0"}],"id":150,"name":"VariableDeclaration","src":"2027:35:0"},{"attributes":{"constant":false,"name":"operators","scope":528,"stateVariable":true,"storageLocation":"default","type":"mapping(address => mapping(address => bool))","value":null,"visibility":"internal"},"children":[{"attributes":{"type":"mapping(address => mapping(address => bool))"},"children":[{"attributes":{"name":"address","type":"address"},"id":151,"name":"ElementaryTypeName","src":"2078:7:0"},{"attributes":{"type":"mapping(address => bool)"},"children":[{"attributes":{"name":"address","type":"address"},"id":152,"name":"ElementaryTypeName","src":"2097:7:0"},{"attributes":{"name":"bool","type":"bool"},"id":153,"name":"ElementaryTypeName","src":"2108:4:0"}],"id":154,"name":"Mapping","src":"2089:24:0"}],"id":155,"name":"Mapping","src":"2069:45:0"}],"id":156,"name":"VariableDeclaration","src":"2069:55:0"},{"attributes":{"documentation":null,"name":"authorised","visibility":"internal"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":183,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":157,"name":"ElementaryTypeName","src":"2224:7:0"}],"id":158,"name":"VariableDeclaration","src":"2224:12:0"}],"id":159,"name":"ParameterList","src":"2223:14:0"},{"children":[{"attributes":{"assignments":[161]},"children":[{"attributes":{"constant":false,"name":"owner","scope":182,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":160,"name":"ElementaryTypeName","src":"2249:7:0"}],"id":161,"name":"VariableDeclaration","src":"2249:13:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"owner","referencedDeclaration":141,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":162,"name":"Identifier","src":"2265:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":158,"type":"bytes32","value":"node"},"id":163,"name":"Identifier","src":"2273:4:0"}],"id":164,"name":"IndexAccess","src":"2265:13:0"}],"id":165,"name":"MemberAccess","src":"2265:19:0"}],"id":166,"name":"VariableDeclarationStatement","src":"2249:35:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"}],"overloadedDeclarations":[668,669],"referencedDeclaration":668,"type":"function (bool) pure","value":"require"},"id":167,"name":"Identifier","src":"2295:7:0"},{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"||","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"==","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":161,"type":"address","value":"owner"},"id":168,"name":"Identifier","src":"2303:5:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"sender","referencedDeclaration":null,"type":"address payable"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":665,"type":"msg","value":"msg"},"id":169,"name":"Identifier","src":"2312:3:0"}],"id":170,"name":"MemberAccess","src":"2312:10:0"}],"id":171,"name":"BinaryOperation","src":"2303:19:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"mapping(address => bool)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":156,"type":"mapping(address => mapping(address => bool))","value":"operators"},"id":172,"name":"Identifier","src":"2326:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":161,"type":"address","value":"owner"},"id":173,"name":"Identifier","src":"2336:5:0"}],"id":174,"name":"IndexAccess","src":"2326:16:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"sender","referencedDeclaration":null,"type":"address payable"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":665,"type":"msg","value":"msg"},"id":175,"name":"Identifier","src":"2343:3:0"}],"id":176,"name":"MemberAccess","src":"2343:10:0"}],"id":177,"name":"IndexAccess","src":"2326:28:0"}],"id":178,"name":"BinaryOperation","src":"2303:51:0"}],"id":179,"name":"FunctionCall","src":"2295:60:0"}],"id":180,"name":"ExpressionStatement","src":"2295:60:0"},{"id":181,"name":"PlaceholderStatement","src":"2366:1:0"}],"id":182,"name":"Block","src":"2238:137:0"}],"id":183,"name":"ModifierDefinition","src":"2204:171:0"},{"attributes":{"documentation":"@dev Constructs a new ENS registrar.","implemented":true,"isConstructor":true,"kind":"constructor","modifiers":[null],"name":"","scope":528,"stateMutability":"nonpayable","superFunction":null,"visibility":"public"},"children":[{"attributes":{"parameters":[null]},"children":[],"id":184,"name":"ParameterList","src":"2457:2:0"},{"attributes":{"parameters":[null]},"children":[],"id":185,"name":"ParameterList","src":"2467:0:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"owner","referencedDeclaration":141,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":186,"name":"Identifier","src":"2478:7:0"},{"attributes":{"argumentTypes":null,"hexvalue":"307830","isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"subdenomination":null,"token":"number","type":"int_const 0","value":"0x0"},"id":187,"name":"Literal","src":"2486:3:0"}],"id":188,"name":"IndexAccess","src":"2478:12:0"}],"id":189,"name":"MemberAccess","src":"2478:18:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"sender","referencedDeclaration":null,"type":"address payable"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":665,"type":"msg","value":"msg"},"id":190,"name":"Identifier","src":"2499:3:0"}],"id":191,"name":"MemberAccess","src":"2499:10:0"}],"id":192,"name":"Assignment","src":"2478:31:0"}],"id":193,"name":"ExpressionStatement","src":"2478:31:0"}],"id":194,"name":"Block","src":"2467:50:0"}],"id":195,"name":"FunctionDefinition","src":"2446:71:0"},{"attributes":{"documentation":"@dev Sets the record for a node.\\n@param node The node to update.\\n@param owner The address of the new owner.\\n@param resolver The address of the resolver.\\n@param ttl The TTL in seconds.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setRecord","scope":528,"stateMutability":"nonpayable","superFunction":46,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":218,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":196,"name":"ElementaryTypeName","src":"2786:7:0"}],"id":197,"name":"VariableDeclaration","src":"2786:12:0"},{"attributes":{"constant":false,"name":"owner","scope":218,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":198,"name":"ElementaryTypeName","src":"2800:7:0"}],"id":199,"name":"VariableDeclaration","src":"2800:13:0"},{"attributes":{"constant":false,"name":"resolver","scope":218,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":200,"name":"ElementaryTypeName","src":"2815:7:0"}],"id":201,"name":"VariableDeclaration","src":"2815:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":218,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":202,"name":"ElementaryTypeName","src":"2833:6:0"}],"id":203,"name":"VariableDeclaration","src":"2833:10:0"}],"id":204,"name":"ParameterList","src":"2785:59:0"},{"attributes":{"parameters":[null]},"children":[],"id":205,"name":"ParameterList","src":"2854:0:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":267,"type":"function (bytes32,address)","value":"setOwner"},"id":206,"name":"Identifier","src":"2865:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":197,"type":"bytes32","value":"node"},"id":207,"name":"Identifier","src":"2874:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":199,"type":"address","value":"owner"},"id":208,"name":"Identifier","src":"2880:5:0"}],"id":209,"name":"FunctionCall","src":"2865:21:0"}],"id":210,"name":"ExpressionStatement","src":"2865:21:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"overloadedDeclarations":[null],"referencedDeclaration":527,"type":"function (bytes32,address,uint64)","value":"_setResolverAndTTL"},"id":211,"name":"Identifier","src":"2897:18:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":197,"type":"bytes32","value":"node"},"id":212,"name":"Identifier","src":"2916:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":201,"type":"address","value":"resolver"},"id":213,"name":"Identifier","src":"2922:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":203,"type":"uint64","value":"ttl"},"id":214,"name":"Identifier","src":"2932:3:0"}],"id":215,"name":"FunctionCall","src":"2897:39:0"}],"id":216,"name":"ExpressionStatement","src":"2897:39:0"}],"id":217,"name":"Block","src":"2854:90:0"}],"id":218,"name":"FunctionDefinition","src":"2767:177:0"},{"attributes":{"documentation":"@dev Sets the record for a subnode.\\n@param node The parent node.\\n@param label The hash of the label specifying the subnode.\\n@param owner The address of the new owner.\\n@param resolver The address of the resolver.\\n@param ttl The TTL in seconds.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setSubnodeRecord","scope":528,"stateMutability":"nonpayable","superFunction":59,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":246,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":219,"name":"ElementaryTypeName","src":"3287:7:0"}],"id":220,"name":"VariableDeclaration","src":"3287:12:0"},{"attributes":{"constant":false,"name":"label","scope":246,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":221,"name":"ElementaryTypeName","src":"3301:7:0"}],"id":222,"name":"VariableDeclaration","src":"3301:13:0"},{"attributes":{"constant":false,"name":"owner","scope":246,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":223,"name":"ElementaryTypeName","src":"3316:7:0"}],"id":224,"name":"VariableDeclaration","src":"3316:13:0"},{"attributes":{"constant":false,"name":"resolver","scope":246,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":225,"name":"ElementaryTypeName","src":"3331:7:0"}],"id":226,"name":"VariableDeclaration","src":"3331:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":246,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":227,"name":"ElementaryTypeName","src":"3349:6:0"}],"id":228,"name":"VariableDeclaration","src":"3349:10:0"}],"id":229,"name":"ParameterList","src":"3286:74:0"},{"attributes":{"parameters":[null]},"children":[],"id":230,"name":"ParameterList","src":"3370:0:0"},{"children":[{"attributes":{"assignments":[232]},"children":[{"attributes":{"constant":false,"name":"subnode","scope":245,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":231,"name":"ElementaryTypeName","src":"3381:7:0"}],"id":232,"name":"VariableDeclaration","src":"3381:15:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bytes32","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":305,"type":"function (bytes32,bytes32,address) returns (bytes32)","value":"setSubnodeOwner"},"id":233,"name":"Identifier","src":"3399:15:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":220,"type":"bytes32","value":"node"},"id":234,"name":"Identifier","src":"3415:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":222,"type":"bytes32","value":"label"},"id":235,"name":"Identifier","src":"3421:5:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":224,"type":"address","value":"owner"},"id":236,"name":"Identifier","src":"3428:5:0"}],"id":237,"name":"FunctionCall","src":"3399:35:0"}],"id":238,"name":"VariableDeclarationStatement","src":"3381:53:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"overloadedDeclarations":[null],"referencedDeclaration":527,"type":"function (bytes32,address,uint64)","value":"_setResolverAndTTL"},"id":239,"name":"Identifier","src":"3445:18:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":232,"type":"bytes32","value":"subnode"},"id":240,"name":"Identifier","src":"3464:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":226,"type":"address","value":"resolver"},"id":241,"name":"Identifier","src":"3473:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":228,"type":"uint64","value":"ttl"},"id":242,"name":"Identifier","src":"3483:3:0"}],"id":243,"name":"FunctionCall","src":"3445:42:0"}],"id":244,"name":"ExpressionStatement","src":"3445:42:0"}],"id":245,"name":"Block","src":"3370:125:0"}],"id":246,"name":"FunctionDefinition","src":"3261:234:0"},{"attributes":{"documentation":"@dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n@param node The node to transfer ownership of.\\n@param owner The address of the new owner.","implemented":true,"isConstructor":false,"kind":"function","name":"setOwner","scope":528,"stateMutability":"nonpayable","superFunction":84,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":267,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":247,"name":"ElementaryTypeName","src":"3759:7:0"}],"id":248,"name":"VariableDeclaration","src":"3759:12:0"},{"attributes":{"constant":false,"name":"owner","scope":267,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":249,"name":"ElementaryTypeName","src":"3773:7:0"}],"id":250,"name":"VariableDeclaration","src":"3773:13:0"}],"id":251,"name":"ParameterList","src":"3758:29:0"},{"attributes":{"parameters":[null]},"children":[],"id":255,"name":"ParameterList","src":"3812:0:0"},{"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":183,"type":"modifier (bytes32)","value":"authorised"},"id":252,"name":"Identifier","src":"3795:10:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":248,"type":"bytes32","value":"node"},"id":253,"name":"Identifier","src":"3806:4:0"}],"id":254,"name":"ModifierInvocation","src":"3795:16:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":477,"type":"function (bytes32,address)","value":"_setOwner"},"id":256,"name":"Identifier","src":"3823:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":248,"type":"bytes32","value":"node"},"id":257,"name":"Identifier","src":"3833:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":250,"type":"address","value":"owner"},"id":258,"name":"Identifier","src":"3839:5:0"}],"id":259,"name":"FunctionCall","src":"3823:22:0"}],"id":260,"name":"ExpressionStatement","src":"3823:22:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":15,"type":"function (bytes32,address)","value":"Transfer"},"id":261,"name":"Identifier","src":"3861:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":248,"type":"bytes32","value":"node"},"id":262,"name":"Identifier","src":"3870:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":250,"type":"address","value":"owner"},"id":263,"name":"Identifier","src":"3876:5:0"}],"id":264,"name":"FunctionCall","src":"3861:21:0"}],"id":265,"name":"EmitStatement","src":"3856:26:0"}],"id":266,"name":"Block","src":"3812:78:0"}],"id":267,"name":"FunctionDefinition","src":"3741:149:0"},{"attributes":{"documentation":"@dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n@param node The parent node.\\n@param label The hash of the label specifying the subnode.\\n@param owner The address of the new owner.","implemented":true,"isConstructor":false,"kind":"function","name":"setSubnodeOwner","scope":528,"stateMutability":"nonpayable","superFunction":70,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":305,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":268,"name":"ElementaryTypeName","src":"4235:7:0"}],"id":269,"name":"VariableDeclaration","src":"4235:12:0"},{"attributes":{"constant":false,"name":"label","scope":305,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":270,"name":"ElementaryTypeName","src":"4249:7:0"}],"id":271,"name":"VariableDeclaration","src":"4249:13:0"},{"attributes":{"constant":false,"name":"owner","scope":305,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":272,"name":"ElementaryTypeName","src":"4264:7:0"}],"id":273,"name":"VariableDeclaration","src":"4264:13:0"}],"id":274,"name":"ParameterList","src":"4234:44:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":305,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":278,"name":"ElementaryTypeName","src":"4311:7:0"}],"id":279,"name":"VariableDeclaration","src":"4311:7:0"}],"id":280,"name":"ParameterList","src":"4310:9:0"},{"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":183,"type":"modifier (bytes32)","value":"authorised"},"id":275,"name":"Identifier","src":"4286:10:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":269,"type":"bytes32","value":"node"},"id":276,"name":"Identifier","src":"4297:4:0"}],"id":277,"name":"ModifierInvocation","src":"4286:16:0"},{"children":[{"attributes":{"assignments":[282]},"children":[{"attributes":{"constant":false,"name":"subnode","scope":304,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":281,"name":"ElementaryTypeName","src":"4331:7:0"}],"id":282,"name":"VariableDeclaration","src":"4331:15:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bytes32","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"overloadedDeclarations":[null],"referencedDeclaration":659,"type":"function (bytes memory) pure returns (bytes32)","value":"keccak256"},"id":283,"name":"Identifier","src":"4349:9:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bytes memory","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"member_name":"encodePacked","referencedDeclaration":null,"type":"function () pure returns (bytes memory)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":652,"type":"abi","value":"abi"},"id":284,"name":"Identifier","src":"4359:3:0"}],"id":285,"name":"MemberAccess","src":"4359:16:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":269,"type":"bytes32","value":"node"},"id":286,"name":"Identifier","src":"4376:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":271,"type":"bytes32","value":"label"},"id":287,"name":"Identifier","src":"4382:5:0"}],"id":288,"name":"FunctionCall","src":"4359:29:0"}],"id":289,"name":"FunctionCall","src":"4349:40:0"}],"id":290,"name":"VariableDeclarationStatement","src":"4331:58:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":477,"type":"function (bytes32,address)","value":"_setOwner"},"id":291,"name":"Identifier","src":"4400:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":282,"type":"bytes32","value":"subnode"},"id":292,"name":"Identifier","src":"4410:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":273,"type":"address","value":"owner"},"id":293,"name":"Identifier","src":"4419:5:0"}],"id":294,"name":"FunctionCall","src":"4400:25:0"}],"id":295,"name":"ExpressionStatement","src":"4400:25:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":9,"type":"function (bytes32,bytes32,address)","value":"NewOwner"},"id":296,"name":"Identifier","src":"4441:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":269,"type":"bytes32","value":"node"},"id":297,"name":"Identifier","src":"4450:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":271,"type":"bytes32","value":"label"},"id":298,"name":"Identifier","src":"4456:5:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":273,"type":"address","value":"owner"},"id":299,"name":"Identifier","src":"4463:5:0"}],"id":300,"name":"FunctionCall","src":"4441:28:0"}],"id":301,"name":"EmitStatement","src":"4436:33:0"},{"attributes":{"functionReturnParameters":280},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":282,"type":"bytes32","value":"subnode"},"id":302,"name":"Identifier","src":"4487:7:0"}],"id":303,"name":"Return","src":"4480:14:0"}],"id":304,"name":"Block","src":"4320:182:0"}],"id":305,"name":"FunctionDefinition","src":"4210:292:0"},{"attributes":{"documentation":"@dev Sets the resolver address for the specified node.\\n@param node The node to update.\\n@param resolver The address of the resolver.","implemented":true,"isConstructor":false,"kind":"function","name":"setResolver","scope":528,"stateMutability":"nonpayable","superFunction":77,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":328,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":306,"name":"ElementaryTypeName","src":"4705:7:0"}],"id":307,"name":"VariableDeclaration","src":"4705:12:0"},{"attributes":{"constant":false,"name":"resolver","scope":328,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":308,"name":"ElementaryTypeName","src":"4719:7:0"}],"id":309,"name":"VariableDeclaration","src":"4719:16:0"}],"id":310,"name":"ParameterList","src":"4704:32:0"},{"attributes":{"parameters":[null]},"children":[],"id":314,"name":"ParameterList","src":"4761:0:0"},{"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":183,"type":"modifier (bytes32)","value":"authorised"},"id":311,"name":"Identifier","src":"4744:10:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":307,"type":"bytes32","value":"node"},"id":312,"name":"Identifier","src":"4755:4:0"}],"id":313,"name":"ModifierInvocation","src":"4744:16:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":21,"type":"function (bytes32,address)","value":"NewResolver"},"id":315,"name":"Identifier","src":"4777:11:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":307,"type":"bytes32","value":"node"},"id":316,"name":"Identifier","src":"4789:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":309,"type":"address","value":"resolver"},"id":317,"name":"Identifier","src":"4795:8:0"}],"id":318,"name":"FunctionCall","src":"4777:27:0"}],"id":319,"name":"EmitStatement","src":"4772:32:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"resolver","referencedDeclaration":143,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":320,"name":"Identifier","src":"4815:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":307,"type":"bytes32","value":"node"},"id":321,"name":"Identifier","src":"4823:4:0"}],"id":322,"name":"IndexAccess","src":"4815:13:0"}],"id":323,"name":"MemberAccess","src":"4815:22:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":309,"type":"address","value":"resolver"},"id":324,"name":"Identifier","src":"4840:8:0"}],"id":325,"name":"Assignment","src":"4815:33:0"}],"id":326,"name":"ExpressionStatement","src":"4815:33:0"}],"id":327,"name":"Block","src":"4761:95:0"}],"id":328,"name":"FunctionDefinition","src":"4684:172:0"},{"attributes":{"documentation":"@dev Sets the TTL for the specified node.\\n@param node The node to update.\\n@param ttl The TTL in seconds.","implemented":true,"isConstructor":false,"kind":"function","name":"setTTL","scope":528,"stateMutability":"nonpayable","superFunction":91,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":351,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":329,"name":"ElementaryTypeName","src":"5027:7:0"}],"id":330,"name":"VariableDeclaration","src":"5027:12:0"},{"attributes":{"constant":false,"name":"ttl","scope":351,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":331,"name":"ElementaryTypeName","src":"5041:6:0"}],"id":332,"name":"VariableDeclaration","src":"5041:10:0"}],"id":333,"name":"ParameterList","src":"5026:26:0"},{"attributes":{"parameters":[null]},"children":[],"id":337,"name":"ParameterList","src":"5077:0:0"},{"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":183,"type":"modifier (bytes32)","value":"authorised"},"id":334,"name":"Identifier","src":"5060:10:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":330,"type":"bytes32","value":"node"},"id":335,"name":"Identifier","src":"5071:4:0"}],"id":336,"name":"ModifierInvocation","src":"5060:16:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"overloadedDeclarations":[null],"referencedDeclaration":27,"type":"function (bytes32,uint64)","value":"NewTTL"},"id":338,"name":"Identifier","src":"5093:6:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":330,"type":"bytes32","value":"node"},"id":339,"name":"Identifier","src":"5100:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":332,"type":"uint64","value":"ttl"},"id":340,"name":"Identifier","src":"5106:3:0"}],"id":341,"name":"FunctionCall","src":"5093:17:0"}],"id":342,"name":"EmitStatement","src":"5088:22:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"ttl","referencedDeclaration":145,"type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":343,"name":"Identifier","src":"5121:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":330,"type":"bytes32","value":"node"},"id":344,"name":"Identifier","src":"5129:4:0"}],"id":345,"name":"IndexAccess","src":"5121:13:0"}],"id":346,"name":"MemberAccess","src":"5121:17:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":332,"type":"uint64","value":"ttl"},"id":347,"name":"Identifier","src":"5141:3:0"}],"id":348,"name":"Assignment","src":"5121:23:0"}],"id":349,"name":"ExpressionStatement","src":"5121:23:0"}],"id":350,"name":"Block","src":"5077:75:0"}],"id":351,"name":"FunctionDefinition","src":"5011:141:0"},{"attributes":{"documentation":"@dev Enable or disable approval for a third party (\\"operator\\") to manage\\n all of `msg.sender`\'s ENS records. Emits the ApprovalForAll event.\\n@param operator Address to add to the set of authorized operators.\\n@param approved True if the operator is approved, false to revoke approval.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"setApprovalForAll","scope":528,"stateMutability":"nonpayable","superFunction":98,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"operator","scope":375,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":352,"name":"ElementaryTypeName","src":"5521:7:0"}],"id":353,"name":"VariableDeclaration","src":"5521:16:0"},{"attributes":{"constant":false,"name":"approved","scope":375,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":354,"name":"ElementaryTypeName","src":"5539:4:0"}],"id":355,"name":"VariableDeclaration","src":"5539:13:0"}],"id":356,"name":"ParameterList","src":"5520:33:0"},{"attributes":{"parameters":[null]},"children":[],"id":357,"name":"ParameterList","src":"5563:0:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"mapping(address => bool)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":156,"type":"mapping(address => mapping(address => bool))","value":"operators"},"id":358,"name":"Identifier","src":"5574:9:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"sender","referencedDeclaration":null,"type":"address payable"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":665,"type":"msg","value":"msg"},"id":359,"name":"Identifier","src":"5584:3:0"}],"id":360,"name":"MemberAccess","src":"5584:10:0"}],"id":362,"name":"IndexAccess","src":"5574:21:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":353,"type":"address","value":"operator"},"id":361,"name":"Identifier","src":"5596:8:0"}],"id":363,"name":"IndexAccess","src":"5574:31:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":355,"type":"bool","value":"approved"},"id":364,"name":"Identifier","src":"5608:8:0"}],"id":365,"name":"Assignment","src":"5574:42:0"}],"id":366,"name":"ExpressionStatement","src":"5574:42:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_address_payable","typeString":"address payable"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bool","typeString":"bool"}],"overloadedDeclarations":[null],"referencedDeclaration":35,"type":"function (address,address,bool)","value":"ApprovalForAll"},"id":367,"name":"Identifier","src":"5632:14:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"sender","referencedDeclaration":null,"type":"address payable"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":665,"type":"msg","value":"msg"},"id":368,"name":"Identifier","src":"5647:3:0"}],"id":369,"name":"MemberAccess","src":"5647:10:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":353,"type":"address","value":"operator"},"id":370,"name":"Identifier","src":"5659:8:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":355,"type":"bool","value":"approved"},"id":371,"name":"Identifier","src":"5669:8:0"}],"id":372,"name":"FunctionCall","src":"5632:46:0"}],"id":373,"name":"EmitStatement","src":"5627:51:0"}],"id":374,"name":"Block","src":"5563:123:0"}],"id":375,"name":"FunctionDefinition","src":"5494:192:0"},{"attributes":{"documentation":"@dev Returns the address that owns the specified node.\\n@param node The specified node.\\n@return address of the owner.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"owner","scope":528,"stateMutability":"view","superFunction":105,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":403,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":376,"name":"ElementaryTypeName","src":"5868:7:0"}],"id":377,"name":"VariableDeclaration","src":"5868:12:0"}],"id":378,"name":"ParameterList","src":"5867:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":403,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":379,"name":"ElementaryTypeName","src":"5903:7:0"}],"id":380,"name":"VariableDeclaration","src":"5903:7:0"}],"id":381,"name":"ParameterList","src":"5902:9:0"},{"children":[{"attributes":{"assignments":[383]},"children":[{"attributes":{"constant":false,"name":"addr","scope":402,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":382,"name":"ElementaryTypeName","src":"5923:7:0"}],"id":383,"name":"VariableDeclaration","src":"5923:12:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"owner","referencedDeclaration":141,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":384,"name":"Identifier","src":"5938:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":377,"type":"bytes32","value":"node"},"id":385,"name":"Identifier","src":"5946:4:0"}],"id":386,"name":"IndexAccess","src":"5938:13:0"}],"id":387,"name":"MemberAccess","src":"5938:19:0"}],"id":388,"name":"VariableDeclarationStatement","src":"5923:34:0"},{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"==","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":383,"type":"address","value":"addr"},"id":389,"name":"Identifier","src":"5972:4:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":true},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_contract$_ENSRegistry_$528","typeString":"contract ENSRegistry"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"type":"type(address)","value":"address"},"id":390,"name":"ElementaryTypeNameExpression","src":"5980:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":681,"type":"contract ENSRegistry","value":"this"},"id":391,"name":"Identifier","src":"5988:4:0"}],"id":392,"name":"FunctionCall","src":"5980:13:0"}],"id":393,"name":"BinaryOperation","src":"5972:21:0"},{"children":[{"attributes":{"functionReturnParameters":381},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":true,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address payable","type_conversion":true},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"type":"type(address)","value":"address"},"id":394,"name":"ElementaryTypeNameExpression","src":"6017:7:0"},{"attributes":{"argumentTypes":null,"hexvalue":"307830","isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"subdenomination":null,"token":"number","type":"int_const 0","value":"0x0"},"id":395,"name":"Literal","src":"6025:3:0"}],"id":396,"name":"FunctionCall","src":"6017:12:0"}],"id":397,"name":"Return","src":"6010:19:0"}],"id":398,"name":"Block","src":"5995:46:0"}],"id":399,"name":"IfStatement","src":"5968:73:0"},{"attributes":{"functionReturnParameters":381},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":383,"type":"address","value":"addr"},"id":400,"name":"Identifier","src":"6060:4:0"}],"id":401,"name":"Return","src":"6053:11:0"}],"id":402,"name":"Block","src":"5912:160:0"}],"id":403,"name":"FunctionDefinition","src":"5853:219:0"},{"attributes":{"documentation":"@dev Returns the address of the resolver for the specified node.\\n@param node The specified node.\\n@return address of the resolver.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"resolver","scope":528,"stateMutability":"view","superFunction":112,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":416,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":404,"name":"ElementaryTypeName","src":"6270:7:0"}],"id":405,"name":"VariableDeclaration","src":"6270:12:0"}],"id":406,"name":"ParameterList","src":"6269:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":416,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":407,"name":"ElementaryTypeName","src":"6305:7:0"}],"id":408,"name":"VariableDeclaration","src":"6305:7:0"}],"id":409,"name":"ParameterList","src":"6304:9:0"},{"children":[{"attributes":{"functionReturnParameters":409},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"resolver","referencedDeclaration":143,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":410,"name":"Identifier","src":"6332:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":405,"type":"bytes32","value":"node"},"id":411,"name":"Identifier","src":"6340:4:0"}],"id":412,"name":"IndexAccess","src":"6332:13:0"}],"id":413,"name":"MemberAccess","src":"6332:22:0"}],"id":414,"name":"Return","src":"6325:29:0"}],"id":415,"name":"Block","src":"6314:48:0"}],"id":416,"name":"FunctionDefinition","src":"6252:110:0"},{"attributes":{"documentation":"@dev Returns the TTL of a node, and any records associated with it.\\n@param node The specified node.\\n@return ttl of the node.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"ttl","scope":528,"stateMutability":"view","superFunction":119,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":429,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":417,"name":"ElementaryTypeName","src":"6550:7:0"}],"id":418,"name":"VariableDeclaration","src":"6550:12:0"}],"id":419,"name":"ParameterList","src":"6549:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":429,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":420,"name":"ElementaryTypeName","src":"6585:6:0"}],"id":421,"name":"VariableDeclaration","src":"6585:6:0"}],"id":422,"name":"ParameterList","src":"6584:8:0"},{"children":[{"attributes":{"functionReturnParameters":422},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"ttl","referencedDeclaration":145,"type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":423,"name":"Identifier","src":"6611:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":418,"type":"bytes32","value":"node"},"id":424,"name":"Identifier","src":"6619:4:0"}],"id":425,"name":"IndexAccess","src":"6611:13:0"}],"id":426,"name":"MemberAccess","src":"6611:17:0"}],"id":427,"name":"Return","src":"6604:24:0"}],"id":428,"name":"Block","src":"6593:43:0"}],"id":429,"name":"FunctionDefinition","src":"6537:99:0"},{"attributes":{"documentation":"@dev Returns whether a record has been imported to the registry.\\n@param node The specified node.\\n@return Bool if record exists","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"recordExists","scope":528,"stateMutability":"view","superFunction":126,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":446,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":430,"name":"ElementaryTypeName","src":"6835:7:0"}],"id":431,"name":"VariableDeclaration","src":"6835:12:0"}],"id":432,"name":"ParameterList","src":"6834:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":446,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":433,"name":"ElementaryTypeName","src":"6870:4:0"}],"id":434,"name":"VariableDeclaration","src":"6870:4:0"}],"id":435,"name":"ParameterList","src":"6869:6:0"},{"children":[{"attributes":{"functionReturnParameters":435},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!=","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"owner","referencedDeclaration":141,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":436,"name":"Identifier","src":"6894:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":431,"type":"bytes32","value":"node"},"id":437,"name":"Identifier","src":"6902:4:0"}],"id":438,"name":"IndexAccess","src":"6894:13:0"}],"id":439,"name":"MemberAccess","src":"6894:19:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":true,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address payable","type_conversion":true},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"type":"type(address)","value":"address"},"id":440,"name":"ElementaryTypeNameExpression","src":"6917:7:0"},{"attributes":{"argumentTypes":null,"hexvalue":"307830","isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"subdenomination":null,"token":"number","type":"int_const 0","value":"0x0"},"id":441,"name":"Literal","src":"6925:3:0"}],"id":442,"name":"FunctionCall","src":"6917:12:0"}],"id":443,"name":"BinaryOperation","src":"6894:35:0"}],"id":444,"name":"Return","src":"6887:42:0"}],"id":445,"name":"Block","src":"6876:61:0"}],"id":446,"name":"FunctionDefinition","src":"6813:124:0"},{"attributes":{"documentation":"@dev Query if an address is an authorized operator for another address.\\n@param owner The address that owns the records.\\n@param operator The address that acts on behalf of the owner.\\n@return True if `operator` is an approved operator for `owner`, false otherwise.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"isApprovedForAll","scope":528,"stateMutability":"view","superFunction":135,"visibility":"external"},"children":[{"children":[{"attributes":{"constant":false,"name":"owner","scope":462,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":447,"name":"ElementaryTypeName","src":"7284:7:0"}],"id":448,"name":"VariableDeclaration","src":"7284:13:0"},{"attributes":{"constant":false,"name":"operator","scope":462,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":449,"name":"ElementaryTypeName","src":"7299:7:0"}],"id":450,"name":"VariableDeclaration","src":"7299:16:0"}],"id":451,"name":"ParameterList","src":"7283:33:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":462,"stateVariable":false,"storageLocation":"default","type":"bool","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bool","type":"bool"},"id":452,"name":"ElementaryTypeName","src":"7340:4:0"}],"id":453,"name":"VariableDeclaration","src":"7340:4:0"}],"id":454,"name":"ParameterList","src":"7339:6:0"},{"children":[{"attributes":{"functionReturnParameters":454},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"mapping(address => bool)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":156,"type":"mapping(address => mapping(address => bool))","value":"operators"},"id":455,"name":"Identifier","src":"7364:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":448,"type":"address","value":"owner"},"id":456,"name":"Identifier","src":"7374:5:0"}],"id":457,"name":"IndexAccess","src":"7364:16:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":450,"type":"address","value":"operator"},"id":458,"name":"Identifier","src":"7381:8:0"}],"id":459,"name":"IndexAccess","src":"7364:26:0"}],"id":460,"name":"Return","src":"7357:33:0"}],"id":461,"name":"Block","src":"7346:52:0"}],"id":462,"name":"FunctionDefinition","src":"7258:140:0"},{"attributes":{"documentation":null,"implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"_setOwner","scope":528,"stateMutability":"nonpayable","superFunction":null,"visibility":"internal"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":477,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":463,"name":"ElementaryTypeName","src":"7425:7:0"}],"id":464,"name":"VariableDeclaration","src":"7425:12:0"},{"attributes":{"constant":false,"name":"owner","scope":477,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":465,"name":"ElementaryTypeName","src":"7439:7:0"}],"id":466,"name":"VariableDeclaration","src":"7439:13:0"}],"id":467,"name":"ParameterList","src":"7424:29:0"},{"attributes":{"parameters":[null]},"children":[],"id":468,"name":"ParameterList","src":"7463:0:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"owner","referencedDeclaration":141,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":469,"name":"Identifier","src":"7474:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":464,"type":"bytes32","value":"node"},"id":470,"name":"Identifier","src":"7482:4:0"}],"id":471,"name":"IndexAccess","src":"7474:13:0"}],"id":472,"name":"MemberAccess","src":"7474:19:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":466,"type":"address","value":"owner"},"id":473,"name":"Identifier","src":"7496:5:0"}],"id":474,"name":"Assignment","src":"7474:27:0"}],"id":475,"name":"ExpressionStatement","src":"7474:27:0"}],"id":476,"name":"Block","src":"7463:46:0"}],"id":477,"name":"FunctionDefinition","src":"7406:103:0"},{"attributes":{"documentation":null,"implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"_setResolverAndTTL","scope":528,"stateMutability":"nonpayable","superFunction":null,"visibility":"internal"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":527,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":478,"name":"ElementaryTypeName","src":"7545:7:0"}],"id":479,"name":"VariableDeclaration","src":"7545:12:0"},{"attributes":{"constant":false,"name":"resolver","scope":527,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":480,"name":"ElementaryTypeName","src":"7559:7:0"}],"id":481,"name":"VariableDeclaration","src":"7559:16:0"},{"attributes":{"constant":false,"name":"ttl","scope":527,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":482,"name":"ElementaryTypeName","src":"7577:6:0"}],"id":483,"name":"VariableDeclaration","src":"7577:10:0"}],"id":484,"name":"ParameterList","src":"7544:44:0"},{"attributes":{"parameters":[null]},"children":[],"id":485,"name":"ParameterList","src":"7598:0:0"},{"children":[{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!=","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":481,"type":"address","value":"resolver"},"id":486,"name":"Identifier","src":"7612:8:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"resolver","referencedDeclaration":143,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":487,"name":"Identifier","src":"7624:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":488,"name":"Identifier","src":"7632:4:0"}],"id":489,"name":"IndexAccess","src":"7624:13:0"}],"id":490,"name":"MemberAccess","src":"7624:22:0"}],"id":491,"name":"BinaryOperation","src":"7612:34:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"resolver","referencedDeclaration":143,"type":"address"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":492,"name":"Identifier","src":"7663:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":493,"name":"Identifier","src":"7671:4:0"}],"id":494,"name":"IndexAccess","src":"7663:13:0"}],"id":495,"name":"MemberAccess","src":"7663:22:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":481,"type":"address","value":"resolver"},"id":496,"name":"Identifier","src":"7688:8:0"}],"id":497,"name":"Assignment","src":"7663:33:0"}],"id":498,"name":"ExpressionStatement","src":"7663:33:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"overloadedDeclarations":[null],"referencedDeclaration":21,"type":"function (bytes32,address)","value":"NewResolver"},"id":499,"name":"Identifier","src":"7716:11:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":500,"name":"Identifier","src":"7728:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":481,"type":"address","value":"resolver"},"id":501,"name":"Identifier","src":"7734:8:0"}],"id":502,"name":"FunctionCall","src":"7716:27:0"}],"id":503,"name":"EmitStatement","src":"7711:32:0"}],"id":504,"name":"Block","src":"7648:107:0"}],"id":505,"name":"IfStatement","src":"7609:146:0"},{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_uint64","typeString":"uint64"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!=","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":483,"type":"uint64","value":"ttl"},"id":506,"name":"Identifier","src":"7770:3:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"member_name":"ttl","referencedDeclaration":145,"type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":507,"name":"Identifier","src":"7777:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":508,"name":"Identifier","src":"7785:4:0"}],"id":509,"name":"IndexAccess","src":"7777:13:0"}],"id":510,"name":"MemberAccess","src":"7777:17:0"}],"id":511,"name":"BinaryOperation","src":"7770:24:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"member_name":"ttl","referencedDeclaration":145,"type":"uint64"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"type":"struct ENSRegistry.Record storage ref"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":150,"type":"mapping(bytes32 => struct ENSRegistry.Record storage ref)","value":"records"},"id":512,"name":"Identifier","src":"7811:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":513,"name":"Identifier","src":"7819:4:0"}],"id":514,"name":"IndexAccess","src":"7811:13:0"}],"id":515,"name":"MemberAccess","src":"7811:17:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":483,"type":"uint64","value":"ttl"},"id":516,"name":"Identifier","src":"7831:3:0"}],"id":517,"name":"Assignment","src":"7811:23:0"}],"id":518,"name":"ExpressionStatement","src":"7811:23:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_uint64","typeString":"uint64"}],"overloadedDeclarations":[null],"referencedDeclaration":27,"type":"function (bytes32,uint64)","value":"NewTTL"},"id":519,"name":"Identifier","src":"7854:6:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":479,"type":"bytes32","value":"node"},"id":520,"name":"Identifier","src":"7861:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":483,"type":"uint64","value":"ttl"},"id":521,"name":"Identifier","src":"7867:3:0"}],"id":522,"name":"FunctionCall","src":"7854:17:0"}],"id":523,"name":"EmitStatement","src":"7849:22:0"}],"id":524,"name":"Block","src":"7796:87:0"}],"id":525,"name":"IfStatement","src":"7767:116:0"}],"id":526,"name":"Block","src":"7598:292:0"}],"id":527,"name":"FunctionDefinition","src":"7517:373:0"}],"id":528,"name":"ContractDefinition","src":"1888:6005:0"},{"attributes":{"literals":["solidity","^","0.5",".0"]},"id":529,"name":"PragmaDirective","src":"7963:23:0"},{"attributes":{"contractDependencies":[136,528],"contractKind":"contract","documentation":"The ENS registry contract.","fullyImplemented":true,"linearizedBaseContracts":[650,528,136],"name":"ENSRegistryWithFallback","scope":651},"children":[{"attributes":{"arguments":null},"children":[{"attributes":{"contractScope":null,"name":"ENSRegistry","referencedDeclaration":528,"type":"contract ENSRegistry"},"id":530,"name":"UserDefinedTypeName","src":"8071:11:0"}],"id":531,"name":"InheritanceSpecifier","src":"8071:11:0"},{"attributes":{"constant":false,"name":"old","scope":650,"stateVariable":true,"storageLocation":"default","type":"contract ENS","value":null,"visibility":"public"},"children":[{"attributes":{"contractScope":null,"name":"ENS","referencedDeclaration":136,"type":"contract ENS"},"id":532,"name":"UserDefinedTypeName","src":"8092:3:0"}],"id":533,"name":"VariableDeclaration","src":"8092:14:0"},{"attributes":{"documentation":"@dev Constructs a new ENS registrar.","implemented":true,"isConstructor":true,"kind":"constructor","name":"","scope":650,"stateMutability":"nonpayable","superFunction":null,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"_old","scope":545,"stateVariable":false,"storageLocation":"default","type":"contract ENS","value":null,"visibility":"internal"},"children":[{"attributes":{"contractScope":null,"name":"ENS","referencedDeclaration":136,"type":"contract ENS"},"id":534,"name":"UserDefinedTypeName","src":"8190:3:0"}],"id":535,"name":"VariableDeclaration","src":"8190:8:0"}],"id":536,"name":"ParameterList","src":"8189:10:0"},{"attributes":{"parameters":[null]},"children":[],"id":539,"name":"ParameterList","src":"8221:0:0"},{"attributes":{"arguments":[null]},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":528,"type":"type(contract ENSRegistry)","value":"ENSRegistry"},"id":537,"name":"Identifier","src":"8207:11:0"}],"id":538,"name":"ModifierInvocation","src":"8207:13:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"contract ENS"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":533,"type":"contract ENS","value":"old"},"id":540,"name":"Identifier","src":"8232:3:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":535,"type":"contract ENS","value":"_old"},"id":541,"name":"Identifier","src":"8238:4:0"}],"id":542,"name":"Assignment","src":"8232:10:0"}],"id":543,"name":"ExpressionStatement","src":"8232:10:0"}],"id":544,"name":"Block","src":"8221:29:0"}],"id":545,"name":"FunctionDefinition","src":"8178:72:0"},{"attributes":{"documentation":"@dev Returns the address of the resolver for the specified node.\\n@param node The specified node.\\n@return address of the resolver.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"resolver","scope":650,"stateMutability":"view","superFunction":416,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":569,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":546,"name":"ElementaryTypeName","src":"8448:7:0"}],"id":547,"name":"VariableDeclaration","src":"8448:12:0"}],"id":548,"name":"ParameterList","src":"8447:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":569,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":549,"name":"ElementaryTypeName","src":"8483:7:0"}],"id":550,"name":"VariableDeclaration","src":"8483:7:0"}],"id":551,"name":"ParameterList","src":"8482:9:0"},{"children":[{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!","prefix":true,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bool","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"overloadedDeclarations":[null],"referencedDeclaration":446,"type":"function (bytes32) view returns (bool)","value":"recordExists"},"id":552,"name":"Identifier","src":"8508:12:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":547,"type":"bytes32","value":"node"},"id":553,"name":"Identifier","src":"8521:4:0"}],"id":554,"name":"FunctionCall","src":"8508:18:0"}],"id":555,"name":"UnaryOperation","src":"8507:19:0"},{"children":[{"attributes":{"functionReturnParameters":551},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"resolver","referencedDeclaration":112,"type":"function (bytes32) view external returns (address)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":533,"type":"contract ENS","value":"old"},"id":556,"name":"Identifier","src":"8550:3:0"}],"id":557,"name":"MemberAccess","src":"8550:12:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":547,"type":"bytes32","value":"node"},"id":558,"name":"Identifier","src":"8563:4:0"}],"id":559,"name":"FunctionCall","src":"8550:18:0"}],"id":560,"name":"Return","src":"8543:25:0"}],"id":561,"name":"Block","src":"8528:52:0"}],"id":562,"name":"IfStatement","src":"8503:77:0"},{"attributes":{"functionReturnParameters":551},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"resolver","referencedDeclaration":416,"type":"function (bytes32) view returns (address)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":684,"type":"contract super ENSRegistryWithFallback","value":"super"},"id":563,"name":"Identifier","src":"8599:5:0"}],"id":564,"name":"MemberAccess","src":"8599:14:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":547,"type":"bytes32","value":"node"},"id":565,"name":"Identifier","src":"8614:4:0"}],"id":566,"name":"FunctionCall","src":"8599:20:0"}],"id":567,"name":"Return","src":"8592:27:0"}],"id":568,"name":"Block","src":"8492:135:0"}],"id":569,"name":"FunctionDefinition","src":"8430:197:0"},{"attributes":{"documentation":"@dev Returns the address that owns the specified node.\\n@param node The specified node.\\n@return address of the owner.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"owner","scope":650,"stateMutability":"view","superFunction":403,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":593,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":570,"name":"ElementaryTypeName","src":"8809:7:0"}],"id":571,"name":"VariableDeclaration","src":"8809:12:0"}],"id":572,"name":"ParameterList","src":"8808:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":593,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":573,"name":"ElementaryTypeName","src":"8844:7:0"}],"id":574,"name":"VariableDeclaration","src":"8844:7:0"}],"id":575,"name":"ParameterList","src":"8843:9:0"},{"children":[{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!","prefix":true,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bool","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"overloadedDeclarations":[null],"referencedDeclaration":446,"type":"function (bytes32) view returns (bool)","value":"recordExists"},"id":576,"name":"Identifier","src":"8869:12:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":571,"type":"bytes32","value":"node"},"id":577,"name":"Identifier","src":"8882:4:0"}],"id":578,"name":"FunctionCall","src":"8869:18:0"}],"id":579,"name":"UnaryOperation","src":"8868:19:0"},{"children":[{"attributes":{"functionReturnParameters":575},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"owner","referencedDeclaration":105,"type":"function (bytes32) view external returns (address)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":533,"type":"contract ENS","value":"old"},"id":580,"name":"Identifier","src":"8911:3:0"}],"id":581,"name":"MemberAccess","src":"8911:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":571,"type":"bytes32","value":"node"},"id":582,"name":"Identifier","src":"8921:4:0"}],"id":583,"name":"FunctionCall","src":"8911:15:0"}],"id":584,"name":"Return","src":"8904:22:0"}],"id":585,"name":"Block","src":"8889:49:0"}],"id":586,"name":"IfStatement","src":"8864:74:0"},{"attributes":{"functionReturnParameters":575},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"owner","referencedDeclaration":403,"type":"function (bytes32) view returns (address)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":684,"type":"contract super ENSRegistryWithFallback","value":"super"},"id":587,"name":"Identifier","src":"8957:5:0"}],"id":588,"name":"MemberAccess","src":"8957:11:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":571,"type":"bytes32","value":"node"},"id":589,"name":"Identifier","src":"8969:4:0"}],"id":590,"name":"FunctionCall","src":"8957:17:0"}],"id":591,"name":"Return","src":"8950:24:0"}],"id":592,"name":"Block","src":"8853:129:0"}],"id":593,"name":"FunctionDefinition","src":"8794:188:0"},{"attributes":{"documentation":"@dev Returns the TTL of a node, and any records associated with it.\\n@param node The specified node.\\n@return ttl of the node.","implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"ttl","scope":650,"stateMutability":"view","superFunction":429,"visibility":"public"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":617,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":594,"name":"ElementaryTypeName","src":"9170:7:0"}],"id":595,"name":"VariableDeclaration","src":"9170:12:0"}],"id":596,"name":"ParameterList","src":"9169:14:0"},{"children":[{"attributes":{"constant":false,"name":"","scope":617,"stateVariable":false,"storageLocation":"default","type":"uint64","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"uint64","type":"uint64"},"id":597,"name":"ElementaryTypeName","src":"9205:6:0"}],"id":598,"name":"VariableDeclaration","src":"9205:6:0"}],"id":599,"name":"ParameterList","src":"9204:8:0"},{"children":[{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"!","prefix":true,"type":"bool"},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"bool","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"overloadedDeclarations":[null],"referencedDeclaration":446,"type":"function (bytes32) view returns (bool)","value":"recordExists"},"id":600,"name":"Identifier","src":"9229:12:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":595,"type":"bytes32","value":"node"},"id":601,"name":"Identifier","src":"9242:4:0"}],"id":602,"name":"FunctionCall","src":"9229:18:0"}],"id":603,"name":"UnaryOperation","src":"9228:19:0"},{"children":[{"attributes":{"functionReturnParameters":599},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"uint64","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"ttl","referencedDeclaration":119,"type":"function (bytes32) view external returns (uint64)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":533,"type":"contract ENS","value":"old"},"id":604,"name":"Identifier","src":"9271:3:0"}],"id":605,"name":"MemberAccess","src":"9271:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":595,"type":"bytes32","value":"node"},"id":606,"name":"Identifier","src":"9279:4:0"}],"id":607,"name":"FunctionCall","src":"9271:13:0"}],"id":608,"name":"Return","src":"9264:20:0"}],"id":609,"name":"Block","src":"9249:47:0"}],"id":610,"name":"IfStatement","src":"9224:72:0"},{"attributes":{"functionReturnParameters":599},"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"uint64","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"ttl","referencedDeclaration":429,"type":"function (bytes32) view returns (uint64)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":684,"type":"contract super ENSRegistryWithFallback","value":"super"},"id":611,"name":"Identifier","src":"9315:5:0"}],"id":612,"name":"MemberAccess","src":"9315:9:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":595,"type":"bytes32","value":"node"},"id":613,"name":"Identifier","src":"9325:4:0"}],"id":614,"name":"FunctionCall","src":"9315:15:0"}],"id":615,"name":"Return","src":"9308:22:0"}],"id":616,"name":"Block","src":"9213:125:0"}],"id":617,"name":"FunctionDefinition","src":"9157:181:0"},{"attributes":{"documentation":null,"implemented":true,"isConstructor":false,"kind":"function","modifiers":[null],"name":"_setOwner","scope":650,"stateMutability":"nonpayable","superFunction":477,"visibility":"internal"},"children":[{"children":[{"attributes":{"constant":false,"name":"node","scope":649,"stateVariable":false,"storageLocation":"default","type":"bytes32","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"bytes32","type":"bytes32"},"id":618,"name":"ElementaryTypeName","src":"9365:7:0"}],"id":619,"name":"VariableDeclaration","src":"9365:12:0"},{"attributes":{"constant":false,"name":"owner","scope":649,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":620,"name":"ElementaryTypeName","src":"9379:7:0"}],"id":621,"name":"VariableDeclaration","src":"9379:13:0"}],"id":622,"name":"ParameterList","src":"9364:29:0"},{"attributes":{"parameters":[null]},"children":[],"id":623,"name":"ParameterList","src":"9403:0:0"},{"children":[{"attributes":{"assignments":[625]},"children":[{"attributes":{"constant":false,"name":"addr","scope":648,"stateVariable":false,"storageLocation":"default","type":"address","value":null,"visibility":"internal"},"children":[{"attributes":{"name":"address","stateMutability":"nonpayable","type":"address"},"id":624,"name":"ElementaryTypeName","src":"9414:7:0"}],"id":625,"name":"VariableDeclaration","src":"9414:12:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":621,"type":"address","value":"owner"},"id":626,"name":"Identifier","src":"9429:5:0"}],"id":627,"name":"VariableDeclarationStatement","src":"9414:20:0"},{"attributes":{"falseBody":null},"children":[{"attributes":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"==","type":"bool"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":625,"type":"address","value":"addr"},"id":628,"name":"Identifier","src":"9449:4:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":true,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address payable","type_conversion":true},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"type":"type(address)","value":"address"},"id":629,"name":"ElementaryTypeNameExpression","src":"9457:7:0"},{"attributes":{"argumentTypes":null,"hexvalue":"307830","isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"subdenomination":null,"token":"number","type":"int_const 0","value":"0x0"},"id":630,"name":"Literal","src":"9465:3:0"}],"id":631,"name":"FunctionCall","src":"9457:12:0"}],"id":632,"name":"BinaryOperation","src":"9449:20:0"},{"children":[{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"operator":"=","type":"address"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":625,"type":"address","value":"addr"},"id":633,"name":"Identifier","src":"9486:4:0"},{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"address","type_conversion":true},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_contract$_ENSRegistryWithFallback_$650","typeString":"contract ENSRegistryWithFallback"}],"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"type":"type(address)","value":"address"},"id":634,"name":"ElementaryTypeNameExpression","src":"9493:7:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":683,"type":"contract ENSRegistryWithFallback","value":"this"},"id":635,"name":"Identifier","src":"9501:4:0"}],"id":636,"name":"FunctionCall","src":"9493:13:0"}],"id":637,"name":"Assignment","src":"9486:20:0"}],"id":638,"name":"ExpressionStatement","src":"9486:20:0"}],"id":639,"name":"Block","src":"9471:47:0"}],"id":640,"name":"IfStatement","src":"9445:73:0"},{"children":[{"attributes":{"argumentTypes":null,"isConstant":false,"isLValue":false,"isPure":false,"isStructConstructorCall":false,"lValueRequested":false,"names":[null],"type":"tuple()","type_conversion":false},"children":[{"attributes":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"member_name":"_setOwner","referencedDeclaration":477,"type":"function (bytes32,address)"},"children":[{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":684,"type":"contract super ENSRegistryWithFallback","value":"super"},"id":641,"name":"Identifier","src":"9530:5:0"}],"id":643,"name":"MemberAccess","src":"9530:15:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":619,"type":"bytes32","value":"node"},"id":644,"name":"Identifier","src":"9546:4:0"},{"attributes":{"argumentTypes":null,"overloadedDeclarations":[null],"referencedDeclaration":625,"type":"address","value":"addr"},"id":645,"name":"Identifier","src":"9552:4:0"}],"id":646,"name":"FunctionCall","src":"9530:27:0"}],"id":647,"name":"ExpressionStatement","src":"9530:27:0"}],"id":648,"name":"Block","src":"9403:162:0"}],"id":649,"name":"FunctionDefinition","src":"9346:219:0"}],"id":650,"name":"ContractDefinition","src":"8035:1533:0"}],"id":651,"name":"SourceUnit","src":"113:9455:0"},"compiler":{"name":"solc","version":"0.5.16+commit.9c3226ce.Emscripten.clang"},"networks":{},"schemaVersion":"3.4.4","updatedAt":"2022-01-25T21:14:45.322Z","devdoc":{"methods":{"constructor":{"details":"Constructs a new ENS registrar."},"isApprovedForAll(address,address)":{"details":"Query if an address is an authorized operator for another address.","params":{"operator":"The address that acts on behalf of the owner.","owner":"The address that owns the records."},"return":"True if `operator` is an approved operator for `owner`, false otherwise."},"owner(bytes32)":{"details":"Returns the address that owns the specified node.","params":{"node":"The specified node."},"return":"address of the owner."},"recordExists(bytes32)":{"details":"Returns whether a record has been imported to the registry.","params":{"node":"The specified node."},"return":"Bool if record exists"},"resolver(bytes32)":{"details":"Returns the address of the resolver for the specified node.","params":{"node":"The specified node."},"return":"address of the resolver."},"setApprovalForAll(address,bool)":{"details":"Enable or disable approval for a third party (\\"operator\\") to manage all of `msg.sender`\'s ENS records. Emits the ApprovalForAll event.","params":{"approved":"True if the operator is approved, false to revoke approval.","operator":"Address to add to the set of authorized operators."}},"setOwner(bytes32,address)":{"details":"Transfers ownership of a node to a new address. May only be called by the current owner of the node.","params":{"node":"The node to transfer ownership of.","owner":"The address of the new owner."}},"setRecord(bytes32,address,address,uint64)":{"details":"Sets the record for a node.","params":{"node":"The node to update.","owner":"The address of the new owner.","resolver":"The address of the resolver.","ttl":"The TTL in seconds."}},"setResolver(bytes32,address)":{"details":"Sets the resolver address for the specified node.","params":{"node":"The node to update.","resolver":"The address of the resolver."}},"setSubnodeOwner(bytes32,bytes32,address)":{"details":"Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.","params":{"label":"The hash of the label specifying the subnode.","node":"The parent node.","owner":"The address of the new owner."}},"setSubnodeRecord(bytes32,bytes32,address,address,uint64)":{"details":"Sets the record for a subnode.","params":{"label":"The hash of the label specifying the subnode.","node":"The parent node.","owner":"The address of the new owner.","resolver":"The address of the resolver.","ttl":"The TTL in seconds."}},"setTTL(bytes32,uint64)":{"details":"Sets the TTL for the specified node.","params":{"node":"The node to update.","ttl":"The TTL in seconds."}},"ttl(bytes32)":{"details":"Returns the TTL of a node, and any records associated with it.","params":{"node":"The specified node."},"return":"ttl of the node."}}},"userdoc":{"methods":{},"notice":"The ENS registry contract."}}');

/***/ }),

/***/ 332927:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"contractName":"PublicResolver","abi":[{"constant":true,"inputs":[{"name":"interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"data","type":"bytes"}],"name":"setDNSRecords","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"key","type":"string"},{"name":"value","type":"string"}],"name":"setText","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"interfaceID","type":"bytes4"}],"name":"interfaceImplementer","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"contentTypes","type":"uint256"}],"name":"ABI","outputs":[{"name":"","type":"uint256"},{"name":"","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"x","type":"bytes32"},{"name":"y","type":"bytes32"}],"name":"setPubkey","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"hash","type":"bytes"}],"name":"setContenthash","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"name","type":"bytes32"}],"name":"hasDNSRecords","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"key","type":"string"}],"name":"text","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"contentType","type":"uint256"},{"name":"data","type":"bytes"}],"name":"setABI","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"name","type":"string"}],"name":"setName","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"coinType","type":"uint256"},{"name":"a","type":"bytes"}],"name":"setAddr","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"name","type":"bytes32"},{"name":"resource","type":"uint16"}],"name":"dnsRecord","outputs":[{"name":"","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"}],"name":"clearDNSZone","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"contenthash","outputs":[{"name":"","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"pubkey","outputs":[{"name":"x","type":"bytes32"},{"name":"y","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"a","type":"address"}],"name":"setAddr","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"interfaceID","type":"bytes4"},{"name":"implementer","type":"address"}],"name":"setInterface","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"},{"name":"coinType","type":"uint256"}],"name":"addr","outputs":[{"name":"","type":"bytes"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"bytes32"},{"name":"","type":"address"},{"name":"","type":"address"}],"name":"authorisations","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_ens","type":"address"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"target","type":"address"},{"indexed":false,"name":"isAuthorised","type":"bool"}],"name":"AuthorisationChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":true,"name":"indexedKey","type":"string"},{"indexed":false,"name":"key","type":"string"}],"name":"TextChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"x","type":"bytes32"},{"indexed":false,"name":"y","type":"bytes32"}],"name":"PubkeyChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"name","type":"string"}],"name":"NameChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":true,"name":"interfaceID","type":"bytes4"},{"indexed":false,"name":"implementer","type":"address"}],"name":"InterfaceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"name","type":"bytes"},{"indexed":false,"name":"resource","type":"uint16"},{"indexed":false,"name":"record","type":"bytes"}],"name":"DNSRecordChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"name","type":"bytes"},{"indexed":false,"name":"resource","type":"uint16"}],"name":"DNSRecordDeleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"}],"name":"DNSZoneCleared","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"hash","type":"bytes"}],"name":"ContenthashChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"a","type":"address"}],"name":"AddrChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":false,"name":"coinType","type":"uint256"},{"indexed":false,"name":"newAddress","type":"bytes"}],"name":"AddressChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"node","type":"bytes32"},{"indexed":true,"name":"contentType","type":"uint256"}],"name":"ABIChanged","type":"event"},{"constant":false,"inputs":[{"name":"node","type":"bytes32"},{"name":"target","type":"address"},{"name":"isAuthorised","type":"bool"}],"name":"setAuthorisation","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"name":"results","type":"bytes[]"}],"payable":false,"stateMutability":"nonpayable","type":"function"}],"metadata":"{\\"compiler\\":{\\"version\\":\\"0.5.8+commit.23d335f2\\"},\\"language\\":\\"Solidity\\",\\"output\\":{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"}],\\"name\\":\\"supportsInterface\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setDNSRecords\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"key\\",\\"type\\":\\"string\\"},{\\"name\\":\\"value\\",\\"type\\":\\"string\\"}],\\"name\\":\\"setText\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"}],\\"name\\":\\"interfaceImplementer\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"contentTypes\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"ABI\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"},{\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"setPubkey\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"hash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setContenthash\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"addr\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"target\\",\\"type\\":\\"address\\"},{\\"name\\":\\"isAuthorised\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"setAuthorisation\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"name\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"hasDNSRecords\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"key\\",\\"type\\":\\"string\\"}],\\"name\\":\\"text\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"contentType\\",\\"type\\":\\"uint256\\"},{\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setABI\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"name\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"name\\",\\"type\\":\\"string\\"}],\\"name\\":\\"setName\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"},{\\"name\\":\\"a\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setAddr\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"name\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"dnsRecord\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"data\\",\\"type\\":\\"bytes[]\\"}],\\"name\\":\\"multicall\\",\\"outputs\\":[{\\"name\\":\\"results\\",\\"type\\":\\"bytes[]\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"clearDNSZone\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"contenthash\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"pubkey\\",\\"outputs\\":[{\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"a\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setAddr\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"},{\\"name\\":\\"implementer\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setInterface\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"addr\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"\\",\\"type\\":\\"address\\"},{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"name\\":\\"authorisations\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"name\\":\\"_ens\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"constructor\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"target\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"isAuthorised\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"AuthorisationChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"indexedKey\\",\\"type\\":\\"string\\"},{\\"indexed\\":false,\\"name\\":\\"key\\",\\"type\\":\\"string\\"}],\\"name\\":\\"TextChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"PubkeyChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"name\\",\\"type\\":\\"string\\"}],\\"name\\":\\"NameChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"},{\\"indexed\\":false,\\"name\\":\\"implementer\\",\\"type\\":\\"address\\"}],\\"name\\":\\"InterfaceChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"},{\\"indexed\\":false,\\"name\\":\\"record\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"DNSRecordChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"DNSRecordDeleted\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"DNSZoneCleared\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"hash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ContenthashChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"a\\",\\"type\\":\\"address\\"}],\\"name\\":\\"AddrChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":false,\\"name\\":\\"newAddress\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"AddressChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"contentType\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"ABIChanged\\",\\"type\\":\\"event\\"}],\\"devdoc\\":{\\"methods\\":{\\"ABI(bytes32,uint256)\\":{\\"params\\":{\\"contentTypes\\":\\"A bitwise OR of the ABI formats accepted by the caller.\\",\\"node\\":\\"The ENS node to query\\"},\\"return\\":\\"contentType The content type of the return valuedata The ABI data\\"},\\"addr(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"return\\":\\"The associated address.\\"},\\"clearDNSZone(bytes32)\\":{\\"params\\":{\\"node\\":\\"the namehash of the node for which to clear the zone\\"}},\\"contenthash(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"return\\":\\"The associated contenthash.\\"},\\"dnsRecord(bytes32,bytes32,uint16)\\":{\\"params\\":{\\"name\\":\\"the keccak-256 hash of the fully-qualified name for which to fetch the record\\",\\"node\\":\\"the namehash of the node for which to fetch the record\\",\\"resource\\":\\"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\"},\\"return\\":\\"the DNS record in wire format if present, otherwise empty\\"},\\"hasDNSRecords(bytes32,bytes32)\\":{\\"params\\":{\\"name\\":\\"the namehash of the node for which to check the records\\",\\"node\\":\\"the namehash of the node for which to check the records\\"}},\\"interfaceImplementer(bytes32,bytes4)\\":{\\"params\\":{\\"interfaceID\\":\\"The EIP 168 interface ID to check for.\\",\\"node\\":\\"The ENS node to query.\\"},\\"return\\":\\"The address that implements this interface, or 0 if the interface is unsupported.\\"},\\"name(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"return\\":\\"The associated name.\\"},\\"pubkey(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query\\"},\\"return\\":\\"x, y the X and Y coordinates of the curve point for the public key.\\"},\\"setABI(bytes32,uint256,bytes)\\":{\\"params\\":{\\"contentType\\":\\"The content type of the ABI\\",\\"data\\":\\"The ABI data.\\",\\"node\\":\\"The node to update.\\"}},\\"setAddr(bytes32,address)\\":{\\"params\\":{\\"a\\":\\"The address to set.\\",\\"node\\":\\"The node to update.\\"}},\\"setAuthorisation(bytes32,address,bool)\\":{\\"details\\":\\"Sets or clears an authorisation. Authorisations are specific to the caller. Any account can set an authorisation for any name, but the authorisation that is checked will be that of the current owner of a name. Thus, transferring a name effectively clears any existing authorisations, and new authorisations can be set in advance of an ownership transfer if desired.\\",\\"params\\":{\\"isAuthorised\\":\\"True if the address should be authorised, or false if it should be deauthorised.\\",\\"node\\":\\"The name to change the authorisation on.\\",\\"target\\":\\"The address that is to be authorised or deauthorised.\\"}},\\"setContenthash(bytes32,bytes)\\":{\\"params\\":{\\"hash\\":\\"The contenthash to set\\",\\"node\\":\\"The node to update.\\"}},\\"setDNSRecords(bytes32,bytes)\\":{\\"params\\":{\\"data\\":\\"the DNS wire format records to set\\",\\"node\\":\\"the namehash of the node for which to set the records\\"}},\\"setInterface(bytes32,bytes4,address)\\":{\\"params\\":{\\"implementer\\":\\"The address of a contract that implements this interface for this node.\\",\\"interfaceID\\":\\"The EIP 168 interface ID.\\",\\"node\\":\\"The node to update.\\"}},\\"setName(bytes32,string)\\":{\\"params\\":{\\"name\\":\\"The name to set.\\",\\"node\\":\\"The node to update.\\"}},\\"setPubkey(bytes32,bytes32,bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query\\",\\"x\\":\\"the X coordinate of the curve point for the public key.\\",\\"y\\":\\"the Y coordinate of the curve point for the public key.\\"}},\\"setText(bytes32,string,string)\\":{\\"params\\":{\\"key\\":\\"The key to set.\\",\\"node\\":\\"The node to update.\\",\\"value\\":\\"The text data value to set.\\"}},\\"text(bytes32,string)\\":{\\"params\\":{\\"key\\":\\"The text data key to query.\\",\\"node\\":\\"The ENS node to query.\\"},\\"return\\":\\"The associated text data.\\"}}},\\"userdoc\\":{\\"methods\\":{\\"ABI(bytes32,uint256)\\":{\\"notice\\":\\"Returns the ABI associated with an ENS node. Defined in EIP205.\\"},\\"addr(bytes32)\\":{\\"notice\\":\\"Returns the address associated with an ENS node.\\"},\\"clearDNSZone(bytes32)\\":{\\"notice\\":\\"Clear all information for a DNS zone.\\"},\\"contenthash(bytes32)\\":{\\"notice\\":\\"Returns the contenthash associated with an ENS node.\\"},\\"dnsRecord(bytes32,bytes32,uint16)\\":{\\"notice\\":\\"Obtain a DNS record.\\"},\\"hasDNSRecords(bytes32,bytes32)\\":{\\"notice\\":\\"Check if a given node has records.\\"},\\"interfaceImplementer(bytes32,bytes4)\\":{\\"notice\\":\\"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP168 and returns `true` for the specified interfaceID, its address will be returned.\\"},\\"name(bytes32)\\":{\\"notice\\":\\"Returns the name associated with an ENS node, for reverse records. Defined in EIP181.\\"},\\"pubkey(bytes32)\\":{\\"notice\\":\\"Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619.\\"},\\"setABI(bytes32,uint256,bytes)\\":{\\"notice\\":\\"Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string.\\"},\\"setAddr(bytes32,address)\\":{\\"notice\\":\\"Sets the address associated with an ENS node. May only be called by the owner of that node in the ENS registry.\\"},\\"setContenthash(bytes32,bytes)\\":{\\"notice\\":\\"Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry.\\"},\\"setDNSRecords(bytes32,bytes)\\":{\\"notice\\":\\"Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:    a.example.com IN A 1.2.3.4    a.example.com IN A 5.6.7.8    www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:    a.example.com IN A 1.2.3.4    www.example.com IN CNAME a.example.com.    a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first.\\"},\\"setInterface(bytes32,bytes4,address)\\":{\\"notice\\":\\"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\"},\\"setName(bytes32,string)\\":{\\"notice\\":\\"Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry.\\"},\\"setPubkey(bytes32,bytes32,bytes32)\\":{\\"notice\\":\\"Sets the SECP256k1 public key associated with an ENS node.\\"},\\"setText(bytes32,string,string)\\":{\\"notice\\":\\"Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry.\\"},\\"text(bytes32,string)\\":{\\"notice\\":\\"Returns the text data associated with an ENS node and key.\\"}},\\"notice\\":\\"A simple resolver anyone can use; only allows the owner of a node to set its address.\\"}},\\"settings\\":{\\"compilationTarget\\":{\\"/home/user/Dropbox/projects/resolvers/contracts/PublicResolver.sol\\":\\"PublicResolver\\"},\\"evmVersion\\":\\"petersburg\\",\\"libraries\\":{},\\"optimizer\\":{\\"enabled\\":false,\\"runs\\":200},\\"remappings\\":[]},\\"sources\\":{\\"/home/user/Dropbox/projects/resolvers/contracts/PublicResolver.sol\\":{\\"keccak256\\":\\"0xefbe75eae88d73e4db56bc22f72fbf157d027caf2d20644eb99298f04b27fa5f\\",\\"urls\\":[\\"bzzr://4cb74b326c91262a10141c4c2dfe36a303793fbb300f502a0f3e2fbfbb468c58\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/ResolverBase.sol\\":{\\"keccak256\\":\\"0xfc7d550960829127576d6fc3080513d74ef18a6d7057d0d9262ce071890053e8\\",\\"urls\\":[\\"bzzr://81e5565403a67f558d12c787f53f40ff19a5da99c648f8a4f99f2caa449ca0e6\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/ABIResolver.sol\\":{\\"keccak256\\":\\"0x794514d39c469bab511822ca7a1a7a7838dca338499889896c7dac4303c30c1f\\",\\"urls\\":[\\"bzzr://9fdf58339517baeca57889519a4bb2f30a010f2f4262771e6f5de4374fc436b1\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/AddrResolver.sol\\":{\\"keccak256\\":\\"0xbe84f840b10f6ddc3d695d5905fe4034569c646bdf56b1367c16271aa92071c6\\",\\"urls\\":[\\"bzzr://c97941ee4075d43abe371cc52f3bfa018d7dc93c7cfbb72da565ecaa72996381\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/ContentHashResolver.sol\\":{\\"keccak256\\":\\"0xaa3d9b9baae36fbf831b8297832b54ffd1023b9ac508f2c5068b92ce0c30edfc\\",\\"urls\\":[\\"bzzr://c80ec35a145dd4b853e1e04b32763843313be216462a4993d28d5b489a6912f7\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/DNSResolver.sol\\":{\\"keccak256\\":\\"0x51534f5ebdcfda403b1a935f256e7f27d16b490e5b023b6e57877973daf9a4d4\\",\\"urls\\":[\\"bzzr://a81c189814102f6debd761795650d94694225b7486d490faf7d5fb6e0704ed28\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/InterfaceResolver.sol\\":{\\"keccak256\\":\\"0x6398dc59dd38501acd6a716173793e84aa1c454c3e21c190e10ddbe54dd8be41\\",\\"urls\\":[\\"bzzr://0d539232d308722b6a434ed5e9a22b0c4cb849c641b6d0739f2f83e566cb59f1\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/NameResolver.sol\\":{\\"keccak256\\":\\"0xcff06da8901397164ca9bea36361ac518fb62cd5283d2e2e835e006980ba4d16\\",\\"urls\\":[\\"bzzr://a4a8988916719c4976bb0caf1cff3bdee3c94ae693b57970f6b925124cff38ee\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/PubkeyResolver.sol\\":{\\"keccak256\\":\\"0xaa10a8a7e1579987b6781657153ae3f16806f240b3ffaa54ea1f303f7cb7a74a\\",\\"urls\\":[\\"bzzr://1caaa8668f536f654f4e6d68129ab5091e0ed5c72e0e70216b82d0bb9e7cd86f\\"]},\\"/home/user/Dropbox/projects/resolvers/contracts/profiles/TextResolver.sol\\":{\\"keccak256\\":\\"0x1feb20d9466c52f471c57344c1e3792e2c69b24ab9d7f7a4de6e49912abc75bb\\",\\"urls\\":[\\"bzzr://25ce3b4bf68f29d54e8916c0682b746a9e15f14bcccfc76136fc17ae2c902898\\"]},\\"@ensdomains/buffer/contracts/Buffer.sol\\":{\\"keccak256\\":\\"0x1264adbd06f6e05b04539bb225063a988b7fa90343d068de60cdde6cfb6fa92d\\",\\"urls\\":[\\"bzzr://8f1cb39e242b73bb7fac1f48bf0380ccccad14f06aae9cf4f87329cc78186122\\"]},\\"@ensdomains/dnssec-oracle/contracts/BytesUtils.sol\\":{\\"keccak256\\":\\"0x4014e689ef4a36cbf7103d88286abd2a7c560c2a7af99a561c33c61bc78be27a\\",\\"urls\\":[\\"bzzr://adf984996598f1e0d446eea1eda14ed2c49ab86a4ea1ae837cf4f9d99556b9c2\\"]},\\"@ensdomains/dnssec-oracle/contracts/RRUtils.sol\\":{\\"keccak256\\":\\"0x5135591043cf38413b19f93d16f189f0f8b50b01b78642fb764635d9790cc7ca\\",\\"urls\\":[\\"bzzr://7e3a0111306a7c5640e213da22bcfac1e42b813e8d4d99ef7ea33c09747049fc\\"]},\\"@ensdomains/ens/contracts/ENS.sol\\":{\\"keccak256\\":\\"0xe688db01c0b974f8ff8565557f7fe81aa1f209c1497ec1e74536241f4cc11f08\\",\\"urls\\":[\\"bzzr://04aa083550728a1da54d9acf874f4fca77cc3afef81c57f1ec19be78af05019a\\"]}},\\"version\\":1}","bytecode":"0x60806040523480156200001157600080fd5b506040516020806200386d833981018060405262000033919081019062000092565b80600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505062000120565b6000815190506200008c8162000106565b92915050565b600060208284031215620000a557600080fd5b6000620000b5848285016200007b565b91505092915050565b6000620000cb82620000e6565b9050919050565b6000620000df82620000be565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6200011181620000d2565b81146200011d57600080fd5b50565b61373d80620001306000396000f3fe608060405234801561001057600080fd5b50600436106101585760003560e01c8063691f3431116100c3578063bc1c58d11161007c578063bc1c58d11461040a578063c86902331461043a578063d5fa2b001461046b578063e59d895d14610487578063f1cb7e06146104a3578063f86bc879146104d357610158565b8063691f34311461032657806377372213146103565780638b95dd7114610372578063a8fa56821461038e578063ac9650d8146103be578063ad5780af146103ee57610158565b8063304e6ade11610115578063304e6ade146102425780633b3b57de1461025e5780633e9ce7941461028e5780634cbf6ba4146102aa57806359d1d43c146102da578063623195b01461030a57610158565b806301ffc9a71461015d5780630af179d71461018d57806310f13a8c146101a9578063124a319c146101c55780632203ab56146101f557806329cd62ea14610226575b600080fd5b61017760048036036101729190810190612ecd565b610503565b60405161018491906132ae565b60405180910390f35b6101a760048036036101a29190810190612c85565b610564565b005b6101c360048036036101be9190810190612d35565b610792565b005b6101df60048036036101da9190810190612bfa565b610840565b6040516101ec919061323b565b60405180910390f35b61020f600480360361020a9190810190612dbe565b610c2b565b60405161021d929190613429565b60405180910390f35b610240600480360361023b9190810190612b5c565b610d7a565b005b61025c60048036036102579190810190612c85565b610e0c565b005b61027860048036036102739190810190612a1d565b610e82565b6040516102859190613271565b60405180910390f35b6102a860048036036102a39190810190612ad1565b610eb9565b005b6102c460048036036102bf9190810190612b20565b610fc9565b6040516102d191906132ae565b60405180910390f35b6102f460048036036102ef9190810190612cdd565b611031565b6040516103019190613407565b60405180910390f35b610324600480360361031f9190810190612dfa565b611106565b005b610340600480360361033b9190810190612a1d565b611193565b60405161034d9190613407565b60405180910390f35b610370600480360361036b9190810190612cdd565b611248565b005b61038c60048036036103879190810190612e66565b6112be565b005b6103a860048036036103a39190810190612bab565b611394565b6040516103b5919061334c565b60405180910390f35b6103d860048036036103d391908101906129d8565b611499565b6040516103e5919061328c565b60405180910390f35b61040860048036036104039190810190612a1d565b6115ef565b005b610424600480360361041f9190810190612a1d565b611656565b604051610431919061334c565b60405180910390f35b610454600480360361044f9190810190612a1d565b61170b565b6040516104629291906132e4565b60405180910390f35b61048560048036036104809190810190612a46565b611745565b005b6104a1600480360361049c9190810190612c36565b611771565b005b6104bd60048036036104b89190810190612dbe565b611883565b6040516104ca919061334c565b60405180910390f35b6104ed60048036036104e89190810190612a82565b61194a565b6040516104fa91906132ae565b60405180910390f35b60006359d1d43c60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061055d575061055c82611986565b5b9050919050565b8261056e816119e7565b61057757600080fd5b60008090506000809050606080600061058e6125b2565b6105e660008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050611b7090919063ffffffff16565b90505b6105f281611b9a565b61071f5760008661ffff16141561064e578060400151955061061381611bb0565b93508360405160200161062691906131f6565b60405160208183030381529060405280519060200120915061064781611be7565b9250610711565b606061065982611bb0565b9050816040015161ffff168761ffff1614158061068657506106848186611c1790919063ffffffff16565b155b1561070f576106e88b86898d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508a8b88602001510360008b5114611c3e565b81604001519650816020015195508094508480519060200120925061070c82611be7565b93505b505b61071a81611f6e565b6105e9565b50600083511115610787576107868984878b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505088898e8e9050036000895114611c3e565b5b505050505050505050565b8461079c816119e7565b6107a557600080fd5b82826009600089815260200190815260200160002087876040516107ca92919061320d565b908152602001604051809103902091906107e59291906125fd565b5084846040516107f692919061320d565b6040518091039020867fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a755087876040516108309291906133e3565b60405180910390a3505050505050565b600080600660008581526020019081526020016000206000847bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146109055780915050610c25565b600061091085610e82565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561095257600092505050610c25565b600060608273ffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b604051602401610985919061330d565b6040516020818303038152906040527f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051610a0f91906131f6565b600060405180830381855afa9150503d8060008114610a4a576040519150601f19603f3d011682016040523d82523d6000602084013e610a4f565b606091505b5091509150811580610a62575060208151105b80610aa95750600060f81b81601f81518110610a7a57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610abb576000945050505050610c25565b8273ffffffffffffffffffffffffffffffffffffffff1686604051602401610ae3919061330d565b6040516020818303038152906040527f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051610b6d91906131f6565b600060405180830381855afa9150503d8060008114610ba8576040519150601f19603f3d011682016040523d82523d6000602084013e610bad565b606091505b508092508193505050811580610bc4575060208151105b80610c0b5750600060f81b81601f81518110610bdc57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610c1d576000945050505050610c25565b829450505050505b92915050565b60006060600080600086815260200190815260200160002090506000600190505b848111610d5757600085821614158015610c8c57506000826000838152602001908152602001600020805460018160011615610100020316600290049050115b15610d4b5780826000838152602001908152602001600020808054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610d395780601f10610d0e57610100808354040283529160200191610d39565b820191906000526020600020905b815481529060010190602001808311610d1c57829003601f168201915b50505050509050935093505050610d73565b600181901b9050610c4c565b5060006040518060200160405280600081525081915092509250505b9250929050565b82610d84816119e7565b610d8d57600080fd5b604051806040016040528084815260200183815250600860008681526020019081526020016000206000820151816000015560208201518160010155905050837f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e468484604051610dfe9291906132e4565b60405180910390a250505050565b82610e16816119e7565b610e1f57600080fd5b8282600260008781526020019081526020016000209190610e4192919061267d565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610e74929190613328565b60405180910390a250505050565b60006060610e9183603c611883565b9050600081511415610ea7576000915050610eb4565b610eb081612082565b9150505b919050565b80600b600085815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16847fe1c5610a6e0cbe10764ecd182adcef1ec338dc4e199c99c32ce98f38e12791df84604051610fbc91906132ae565b60405180910390a4505050565b60008060056000858152602001908152602001600020600060036000878152602001908152602001600020548152602001908152602001600020600084815260200190815260200160002060009054906101000a900461ffff1661ffff161415905092915050565b606060096000858152602001908152602001600020838360405161105692919061320d565b90815260200160405180910390208054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156110f85780601f106110cd576101008083540402835291602001916110f8565b820191906000526020600020905b8154815290600101906020018083116110db57829003601f168201915b505050505090509392505050565b83611110816119e7565b61111957600080fd5b60008460018603161461112b57600080fd5b82826000808881526020019081526020016000206000878152602001908152602001600020919061115d92919061267d565b5083857faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe360405160405180910390a35050505050565b6060600760008381526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561123c5780601f106112115761010080835404028352916020019161123c565b820191906000526020600020905b81548152906001019060200180831161121f57829003601f168201915b50505050509050919050565b82611252816119e7565b61125b57600080fd5b828260076000878152602001908152602001600020919061127d9291906125fd565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f784846040516112b09291906133e3565b60405180910390a250505050565b826112c8816119e7565b6112d157600080fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051611303929190613429565b60405180910390a2603c83141561135557837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd261133f84612082565b60405161134c9190613256565b60405180910390a25b81600160008681526020019081526020016000206000858152602001908152602001600020908051906020019061138d9291906126fd565b5050505050565b606060046000858152602001908152602001600020600060036000878152602001908152602001600020548152602001908152602001600020600084815260200190815260200160002060008361ffff1661ffff1681526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561148b5780601f106114605761010080835404028352916020019161148b565b820191906000526020600020905b81548152906001019060200180831161146e57829003601f168201915b505050505090509392505050565b6060828290506040519080825280602002602001820160405280156114d257816020015b60608152602001906001900390816114bd5790505b50905060008090505b838390508110156115e557600060603073ffffffffffffffffffffffffffffffffffffffff1686868581811061150d57fe5b905060200281018035600160200383360303811261152a57600080fd5b8083019250508135905060208201915067ffffffffffffffff81111561154f57600080fd5b60018102360382131561156157600080fd5b60405161156f9291906131dd565b600060405180830381855af49150503d80600081146115aa576040519150601f19603f3d011682016040523d82523d6000602084013e6115af565b606091505b5091509150816115be57600080fd5b808484815181106115cb57fe5b6020026020010181905250505080806001019150506114db565b5080905092915050565b806115f9816119e7565b61160257600080fd5b6003600083815260200190815260200160002060008154809291906001019190505550817fb757169b8492ca2f1c6619d9d76ce22803035c3b1d5f6930dffe7b127c1a198360405160405180910390a25050565b6060600260008381526020019081526020016000208054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156116ff5780601f106116d4576101008083540402835291602001916116ff565b820191906000526020600020905b8154815290600101906020018083116116e257829003601f168201915b50505050509050919050565b6000806008600084815260200190815260200160002060000154600860008581526020019081526020016000206001015491509150915091565b8161174f816119e7565b61175857600080fd5b61176c83603c611767856120a5565b6112be565b505050565b8261177b816119e7565b61178457600080fd5b81600660008681526020019081526020016000206000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916847f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa84604051611875919061323b565b60405180910390a350505050565b60606001600084815260200190815260200160002060008381526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561193d5780601f106119125761010080835404028352916020019161193d565b820191906000526020600020905b81548152906001019060200180831161192057829003601f168201915b5050505050905092915050565b600b602052826000526040600020602052816000526040600020602052806000526040600020600092509250509054906101000a900460ff1681565b600063c869023360e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806119e057506119df826120f0565b5b9050919050565b600080600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3846040518263ffffffff1660e01b8152600401611a4591906132c9565b60206040518083038186803b158015611a5d57600080fd5b505afa158015611a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250611a9591908101906129af565b90503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480611b685750600b600084815260200190815260200160002060008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b915050919050565b611b786125b2565b828160000181905250818160c0018181525050611b9481611f6e565b92915050565b6000816000015151826020015110159050919050565b6060611be08260200151611bcc84600001518560200151612151565b84600001516121ac9092919063ffffffff16565b9050919050565b6060611c108260a001518360a001518460c001510384600001516121ac9092919063ffffffff16565b9050919050565b600081518351148015611c365750611c35836000846000875161221f565b5b905092915050565b6000600360008981526020019081526020016000205490506000878051906020012090506060611c798686896121ac9092919063ffffffff16565b90508315611dee576000600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff16815260200190815260200160002080546001816001161561010002031660029004905014611d5557600560008b815260200190815260200160002060008481526020019081526020016000206000838152602001908152602001600020600081819054906101000a900461ffff16809291906001900391906101000a81548161ffff021916908361ffff160217905550505b600460008b81526020019081526020016000206000848152602001908152602001600020600083815260200190815260200160002060008961ffff1661ffff1681526020019081526020016000206000611daf919061277d565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611de192919061336e565b60405180910390a2611f62565b6000600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff1681526020019081526020016000208054600181600116156101000203166002900490501415611ec257600560008b815260200190815260200160002060008481526020019081526020016000206000838152602001908152602001600020600081819054906101000a900461ffff168092919060010191906101000a81548161ffff021916908361ffff160217905550505b80600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff1681526020019081526020016000209080519060200190611f249291906126fd565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611f599392919061339e565b60405180910390a25b50505050505050505050565b8060c00151816020018181525050806000015151816020015110611f915761207f565b6000611fa582600001518360200151612151565b8260200151019050611fc481836000015161224390919063ffffffff16565b826040019061ffff16908161ffff1681525050600281019050611ff481836000015161224390919063ffffffff16565b826060019061ffff16908161ffff168152505060028101905061202481836000015161226990919063ffffffff16565b826080019063ffffffff16908163ffffffff1681525050600481019050600061205a82846000015161224390919063ffffffff16565b61ffff169050600282019150818360a00181815250508082018360c001818152505050505b50565b6000601482511461209257600080fd5b600c6101000a6020830151049050919050565b606060146040519080825280601f01601f1916602001820160405280156120db5781602001600182028038833980820191505090505b509050600c6101000a82026020820152919050565b600063691f343160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061214a575061214982612291565b5b9050919050565b6000808290505b6001156121a0578351811061216957fe5b600061217e82866122fe90919063ffffffff16565b60ff1690506001810182019150600081141561219a57506121a0565b50612158565b82810391505092915050565b6060835182840111156121be57600080fd5b6060826040519080825280601f01601f1916602001820160405280156121f35781602001600182028038833980820191505090505b5090506000806020830191508560208801019050612212828287612322565b8293505050509392505050565b600061222c84848461236b565b61223787878561236b565b14905095945050505050565b6000825160028301111561225657600080fd5b61ffff8260028501015116905092915050565b6000825160048301111561227c57600080fd5b63ffffffff8260048501015116905092915050565b600060405161229f90613226565b60405180910390207bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806122f757506122f68261238e565b5b9050919050565b600082828151811061230c57fe5b602001015160f81c60f81b60f81c905092915050565b5b602081106123465781518352602083019250602082019150602081039050612323565b60006001826020036101000a0390508019835116818551168181178652505050505050565b60008351828401111561237d57600080fd5b818360208601012090509392505050565b600063a8fa568260e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806123e857506123e7826123ef565b5b9050919050565b600063bc1c58d160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161480612449575061244882612450565b5b9050919050565b6000633b3b57de60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806124e9575063f1cb7e0660e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b806124f957506124f882612500565b5b9050919050565b6000632203ab5660e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061255a575061255982612561565b5b9050919050565b60006301ffc9a760e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b6040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061263e57803560ff191683800117855561266c565b8280016001018555821561266c579182015b8281111561266b578235825591602001919060010190612650565b5b50905061267991906127c5565b5090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106126be57803560ff19168380011785556126ec565b828001600101855582156126ec579182015b828111156126eb5782358255916020019190600101906126d0565b5b5090506126f991906127c5565b5090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061273e57805160ff191683800117855561276c565b8280016001018555821561276c579182015b8281111561276b578251825591602001919060010190612750565b5b50905061277991906127c5565b5090565b50805460018160011615610100020316600290046000825580601f106127a357506127c2565b601f0160209004906000526020600020908101906127c191906127c5565b5b50565b6127e791905b808211156127e35760008160009055506001016127cb565b5090565b90565b6000813590506127f981613679565b92915050565b60008151905061280e81613679565b92915050565b60008083601f84011261282657600080fd5b8235905067ffffffffffffffff81111561283f57600080fd5b60208301915083602082028301111561285757600080fd5b9250929050565b60008135905061286d81613690565b92915050565b600081359050612882816136a7565b92915050565b600081359050612897816136be565b92915050565b60008083601f8401126128af57600080fd5b8235905067ffffffffffffffff8111156128c857600080fd5b6020830191508360018202830111156128e057600080fd5b9250929050565b600082601f8301126128f857600080fd5b813561290b61290682613486565b613459565b9150808252602083016020830185838301111561292757600080fd5b612932838284613626565b50505092915050565b60008083601f84011261294d57600080fd5b8235905067ffffffffffffffff81111561296657600080fd5b60208301915083600182028301111561297e57600080fd5b9250929050565b600081359050612994816136d5565b92915050565b6000813590506129a9816136ec565b92915050565b6000602082840312156129c157600080fd5b60006129cf848285016127ff565b91505092915050565b600080602083850312156129eb57600080fd5b600083013567ffffffffffffffff811115612a0557600080fd5b612a1185828601612814565b92509250509250929050565b600060208284031215612a2f57600080fd5b6000612a3d84828501612873565b91505092915050565b60008060408385031215612a5957600080fd5b6000612a6785828601612873565b9250506020612a78858286016127ea565b9150509250929050565b600080600060608486031215612a9757600080fd5b6000612aa586828701612873565b9350506020612ab6868287016127ea565b9250506040612ac7868287016127ea565b9150509250925092565b600080600060608486031215612ae657600080fd5b6000612af486828701612873565b9350506020612b05868287016127ea565b9250506040612b168682870161285e565b9150509250925092565b60008060408385031215612b3357600080fd5b6000612b4185828601612873565b9250506020612b5285828601612873565b9150509250929050565b600080600060608486031215612b7157600080fd5b6000612b7f86828701612873565b9350506020612b9086828701612873565b9250506040612ba186828701612873565b9150509250925092565b600080600060608486031215612bc057600080fd5b6000612bce86828701612873565b9350506020612bdf86828701612873565b9250506040612bf086828701612985565b9150509250925092565b60008060408385031215612c0d57600080fd5b6000612c1b85828601612873565b9250506020612c2c85828601612888565b9150509250929050565b600080600060608486031215612c4b57600080fd5b6000612c5986828701612873565b9350506020612c6a86828701612888565b9250506040612c7b868287016127ea565b9150509250925092565b600080600060408486031215612c9a57600080fd5b6000612ca886828701612873565b935050602084013567ffffffffffffffff811115612cc557600080fd5b612cd18682870161289d565b92509250509250925092565b600080600060408486031215612cf257600080fd5b6000612d0086828701612873565b935050602084013567ffffffffffffffff811115612d1d57600080fd5b612d298682870161293b565b92509250509250925092565b600080600080600060608688031215612d4d57600080fd5b6000612d5b88828901612873565b955050602086013567ffffffffffffffff811115612d7857600080fd5b612d848882890161293b565b9450945050604086013567ffffffffffffffff811115612da357600080fd5b612daf8882890161293b565b92509250509295509295909350565b60008060408385031215612dd157600080fd5b6000612ddf85828601612873565b9250506020612df08582860161299a565b9150509250929050565b60008060008060608587031215612e1057600080fd5b6000612e1e87828801612873565b9450506020612e2f8782880161299a565b935050604085013567ffffffffffffffff811115612e4c57600080fd5b612e588782880161289d565b925092505092959194509250565b600080600060608486031215612e7b57600080fd5b6000612e8986828701612873565b9350506020612e9a8682870161299a565b925050604084013567ffffffffffffffff811115612eb757600080fd5b612ec3868287016128e7565b9150509250925092565b600060208284031215612edf57600080fd5b6000612eed84828501612888565b91505092915050565b6000612f028383613095565b905092915050565b612f13816135f0565b82525050565b612f2281613564565b82525050565b612f3181613552565b82525050565b6000612f42826134bf565b612f4c81856134f8565b935083602082028501612f5e856134b2565b8060005b85811015612f9a5784840389528151612f7b8582612ef6565b9450612f86836134eb565b925060208a01995050600181019050612f62565b50829750879550505050505092915050565b612fb581613576565b82525050565b612fc481613582565b82525050565b612fd38161358c565b82525050565b6000612fe5838561351a565b9350612ff2838584613626565b612ffb83613668565b840190509392505050565b6000613012838561352b565b935061301f838584613626565b82840190509392505050565b6000613036826134d5565b613040818561351a565b9350613050818560208601613635565b61305981613668565b840191505092915050565b600061306f826134d5565b613079818561352b565b9350613089818560208601613635565b80840191505092915050565b60006130a0826134ca565b6130aa8185613509565b93506130ba818560208601613635565b6130c381613668565b840191505092915050565b60006130da8385613536565b93506130e7838584613626565b6130f083613668565b840190509392505050565b60006131078385613547565b9350613114838584613626565b82840190509392505050565b600061312b826134e0565b6131358185613536565b9350613145818560208601613635565b61314e81613668565b840191505092915050565b6000613166602483613547565b91507f696e74657266616365496d706c656d656e74657228627974657333322c62797460008301527f65733429000000000000000000000000000000000000000000000000000000006020830152602482019050919050565b6131c8816135b8565b82525050565b6131d7816135e6565b82525050565b60006131ea828486613006565b91508190509392505050565b60006132028284613064565b915081905092915050565b600061321a8284866130fb565b91508190509392505050565b600061323182613159565b9150819050919050565b60006020820190506132506000830184612f28565b92915050565b600060208201905061326b6000830184612f0a565b92915050565b60006020820190506132866000830184612f19565b92915050565b600060208201905081810360008301526132a68184612f37565b905092915050565b60006020820190506132c36000830184612fac565b92915050565b60006020820190506132de6000830184612fbb565b92915050565b60006040820190506132f96000830185612fbb565b6133066020830184612fbb565b9392505050565b60006020820190506133226000830184612fca565b92915050565b60006020820190508181036000830152613343818486612fd9565b90509392505050565b60006020820190508181036000830152613366818461302b565b905092915050565b60006040820190508181036000830152613388818561302b565b905061339760208301846131bf565b9392505050565b600060608201905081810360008301526133b8818661302b565b90506133c760208301856131bf565b81810360408301526133d9818461302b565b9050949350505050565b600060208201905081810360008301526133fe8184866130ce565b90509392505050565b600060208201905081810360008301526134218184613120565b905092915050565b600060408201905061343e60008301856131ce565b8181036020830152613450818461302b565b90509392505050565b6000604051905081810181811067ffffffffffffffff8211171561347c57600080fd5b8060405250919050565b600067ffffffffffffffff82111561349d57600080fd5b601f19601f8301169050602081019050919050565b6000602082019050919050565b600081519050919050565b600081519050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b600061355d826135c6565b9050919050565b600061356f826135c6565b9050919050565b60008115159050919050565b6000819050919050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b600061ffff82169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006135fb82613602565b9050919050565b600061360d82613614565b9050919050565b600061361f826135c6565b9050919050565b82818337600083830152505050565b60005b83811015613653578082015181840152602081019050613638565b83811115613662576000848401525b50505050565b6000601f19601f8301169050919050565b61368281613552565b811461368d57600080fd5b50565b61369981613576565b81146136a457600080fd5b50565b6136b081613582565b81146136bb57600080fd5b50565b6136c78161358c565b81146136d257600080fd5b50565b6136de816135b8565b81146136e957600080fd5b50565b6136f5816135e6565b811461370057600080fd5b5056fea265627a7a7230582049ebf27fa2f4353ae0dc98302f101fe3256ef5930b91c52222dcf860d94f3c326c6578706572696d656e74616cf50037","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106101585760003560e01c8063691f3431116100c3578063bc1c58d11161007c578063bc1c58d11461040a578063c86902331461043a578063d5fa2b001461046b578063e59d895d14610487578063f1cb7e06146104a3578063f86bc879146104d357610158565b8063691f34311461032657806377372213146103565780638b95dd7114610372578063a8fa56821461038e578063ac9650d8146103be578063ad5780af146103ee57610158565b8063304e6ade11610115578063304e6ade146102425780633b3b57de1461025e5780633e9ce7941461028e5780634cbf6ba4146102aa57806359d1d43c146102da578063623195b01461030a57610158565b806301ffc9a71461015d5780630af179d71461018d57806310f13a8c146101a9578063124a319c146101c55780632203ab56146101f557806329cd62ea14610226575b600080fd5b61017760048036036101729190810190612ecd565b610503565b60405161018491906132ae565b60405180910390f35b6101a760048036036101a29190810190612c85565b610564565b005b6101c360048036036101be9190810190612d35565b610792565b005b6101df60048036036101da9190810190612bfa565b610840565b6040516101ec919061323b565b60405180910390f35b61020f600480360361020a9190810190612dbe565b610c2b565b60405161021d929190613429565b60405180910390f35b610240600480360361023b9190810190612b5c565b610d7a565b005b61025c60048036036102579190810190612c85565b610e0c565b005b61027860048036036102739190810190612a1d565b610e82565b6040516102859190613271565b60405180910390f35b6102a860048036036102a39190810190612ad1565b610eb9565b005b6102c460048036036102bf9190810190612b20565b610fc9565b6040516102d191906132ae565b60405180910390f35b6102f460048036036102ef9190810190612cdd565b611031565b6040516103019190613407565b60405180910390f35b610324600480360361031f9190810190612dfa565b611106565b005b610340600480360361033b9190810190612a1d565b611193565b60405161034d9190613407565b60405180910390f35b610370600480360361036b9190810190612cdd565b611248565b005b61038c60048036036103879190810190612e66565b6112be565b005b6103a860048036036103a39190810190612bab565b611394565b6040516103b5919061334c565b60405180910390f35b6103d860048036036103d391908101906129d8565b611499565b6040516103e5919061328c565b60405180910390f35b61040860048036036104039190810190612a1d565b6115ef565b005b610424600480360361041f9190810190612a1d565b611656565b604051610431919061334c565b60405180910390f35b610454600480360361044f9190810190612a1d565b61170b565b6040516104629291906132e4565b60405180910390f35b61048560048036036104809190810190612a46565b611745565b005b6104a1600480360361049c9190810190612c36565b611771565b005b6104bd60048036036104b89190810190612dbe565b611883565b6040516104ca919061334c565b60405180910390f35b6104ed60048036036104e89190810190612a82565b61194a565b6040516104fa91906132ae565b60405180910390f35b60006359d1d43c60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061055d575061055c82611986565b5b9050919050565b8261056e816119e7565b61057757600080fd5b60008090506000809050606080600061058e6125b2565b6105e660008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050611b7090919063ffffffff16565b90505b6105f281611b9a565b61071f5760008661ffff16141561064e578060400151955061061381611bb0565b93508360405160200161062691906131f6565b60405160208183030381529060405280519060200120915061064781611be7565b9250610711565b606061065982611bb0565b9050816040015161ffff168761ffff1614158061068657506106848186611c1790919063ffffffff16565b155b1561070f576106e88b86898d8d8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050508a8b88602001510360008b5114611c3e565b81604001519650816020015195508094508480519060200120925061070c82611be7565b93505b505b61071a81611f6e565b6105e9565b50600083511115610787576107868984878b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505088898e8e9050036000895114611c3e565b5b505050505050505050565b8461079c816119e7565b6107a557600080fd5b82826009600089815260200190815260200160002087876040516107ca92919061320d565b908152602001604051809103902091906107e59291906125fd565b5084846040516107f692919061320d565b6040518091039020867fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a755087876040516108309291906133e3565b60405180910390a3505050505050565b600080600660008581526020019081526020016000206000847bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146109055780915050610c25565b600061091085610e82565b9050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561095257600092505050610c25565b600060608273ffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b604051602401610985919061330d565b6040516020818303038152906040527f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051610a0f91906131f6565b600060405180830381855afa9150503d8060008114610a4a576040519150601f19603f3d011682016040523d82523d6000602084013e610a4f565b606091505b5091509150811580610a62575060208151105b80610aa95750600060f81b81601f81518110610a7a57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610abb576000945050505050610c25565b8273ffffffffffffffffffffffffffffffffffffffff1686604051602401610ae3919061330d565b6040516020818303038152906040527f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050604051610b6d91906131f6565b600060405180830381855afa9150503d8060008114610ba8576040519150601f19603f3d011682016040523d82523d6000602084013e610bad565b606091505b508092508193505050811580610bc4575060208151105b80610c0b5750600060f81b81601f81518110610bdc57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610c1d576000945050505050610c25565b829450505050505b92915050565b60006060600080600086815260200190815260200160002090506000600190505b848111610d5757600085821614158015610c8c57506000826000838152602001908152602001600020805460018160011615610100020316600290049050115b15610d4b5780826000838152602001908152602001600020808054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610d395780601f10610d0e57610100808354040283529160200191610d39565b820191906000526020600020905b815481529060010190602001808311610d1c57829003601f168201915b50505050509050935093505050610d73565b600181901b9050610c4c565b5060006040518060200160405280600081525081915092509250505b9250929050565b82610d84816119e7565b610d8d57600080fd5b604051806040016040528084815260200183815250600860008681526020019081526020016000206000820151816000015560208201518160010155905050837f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e468484604051610dfe9291906132e4565b60405180910390a250505050565b82610e16816119e7565b610e1f57600080fd5b8282600260008781526020019081526020016000209190610e4192919061267d565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610e74929190613328565b60405180910390a250505050565b60006060610e9183603c611883565b9050600081511415610ea7576000915050610eb4565b610eb081612082565b9150505b919050565b80600b600085815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16847fe1c5610a6e0cbe10764ecd182adcef1ec338dc4e199c99c32ce98f38e12791df84604051610fbc91906132ae565b60405180910390a4505050565b60008060056000858152602001908152602001600020600060036000878152602001908152602001600020548152602001908152602001600020600084815260200190815260200160002060009054906101000a900461ffff1661ffff161415905092915050565b606060096000858152602001908152602001600020838360405161105692919061320d565b90815260200160405180910390208054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156110f85780601f106110cd576101008083540402835291602001916110f8565b820191906000526020600020905b8154815290600101906020018083116110db57829003601f168201915b505050505090509392505050565b83611110816119e7565b61111957600080fd5b60008460018603161461112b57600080fd5b82826000808881526020019081526020016000206000878152602001908152602001600020919061115d92919061267d565b5083857faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe360405160405180910390a35050505050565b6060600760008381526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561123c5780601f106112115761010080835404028352916020019161123c565b820191906000526020600020905b81548152906001019060200180831161121f57829003601f168201915b50505050509050919050565b82611252816119e7565b61125b57600080fd5b828260076000878152602001908152602001600020919061127d9291906125fd565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f784846040516112b09291906133e3565b60405180910390a250505050565b826112c8816119e7565b6112d157600080fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051611303929190613429565b60405180910390a2603c83141561135557837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd261133f84612082565b60405161134c9190613256565b60405180910390a25b81600160008681526020019081526020016000206000858152602001908152602001600020908051906020019061138d9291906126fd565b5050505050565b606060046000858152602001908152602001600020600060036000878152602001908152602001600020548152602001908152602001600020600084815260200190815260200160002060008361ffff1661ffff1681526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561148b5780601f106114605761010080835404028352916020019161148b565b820191906000526020600020905b81548152906001019060200180831161146e57829003601f168201915b505050505090509392505050565b6060828290506040519080825280602002602001820160405280156114d257816020015b60608152602001906001900390816114bd5790505b50905060008090505b838390508110156115e557600060603073ffffffffffffffffffffffffffffffffffffffff1686868581811061150d57fe5b905060200281018035600160200383360303811261152a57600080fd5b8083019250508135905060208201915067ffffffffffffffff81111561154f57600080fd5b60018102360382131561156157600080fd5b60405161156f9291906131dd565b600060405180830381855af49150503d80600081146115aa576040519150601f19603f3d011682016040523d82523d6000602084013e6115af565b606091505b5091509150816115be57600080fd5b808484815181106115cb57fe5b6020026020010181905250505080806001019150506114db565b5080905092915050565b806115f9816119e7565b61160257600080fd5b6003600083815260200190815260200160002060008154809291906001019190505550817fb757169b8492ca2f1c6619d9d76ce22803035c3b1d5f6930dffe7b127c1a198360405160405180910390a25050565b6060600260008381526020019081526020016000208054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156116ff5780601f106116d4576101008083540402835291602001916116ff565b820191906000526020600020905b8154815290600101906020018083116116e257829003601f168201915b50505050509050919050565b6000806008600084815260200190815260200160002060000154600860008581526020019081526020016000206001015491509150915091565b8161174f816119e7565b61175857600080fd5b61176c83603c611767856120a5565b6112be565b505050565b8261177b816119e7565b61178457600080fd5b81600660008681526020019081526020016000206000857bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916847f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa84604051611875919061323b565b60405180910390a350505050565b60606001600084815260200190815260200160002060008381526020019081526020016000208054600181600116156101000203166002900480601f01602080910402602001604051908101604052809291908181526020018280546001816001161561010002031660029004801561193d5780601f106119125761010080835404028352916020019161193d565b820191906000526020600020905b81548152906001019060200180831161192057829003601f168201915b5050505050905092915050565b600b602052826000526040600020602052816000526040600020602052806000526040600020600092509250509054906101000a900460ff1681565b600063c869023360e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806119e057506119df826120f0565b5b9050919050565b600080600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3846040518263ffffffff1660e01b8152600401611a4591906132c9565b60206040518083038186803b158015611a5d57600080fd5b505afa158015611a71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250611a9591908101906129af565b90503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480611b685750600b600084815260200190815260200160002060008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff165b915050919050565b611b786125b2565b828160000181905250818160c0018181525050611b9481611f6e565b92915050565b6000816000015151826020015110159050919050565b6060611be08260200151611bcc84600001518560200151612151565b84600001516121ac9092919063ffffffff16565b9050919050565b6060611c108260a001518360a001518460c001510384600001516121ac9092919063ffffffff16565b9050919050565b600081518351148015611c365750611c35836000846000875161221f565b5b905092915050565b6000600360008981526020019081526020016000205490506000878051906020012090506060611c798686896121ac9092919063ffffffff16565b90508315611dee576000600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff16815260200190815260200160002080546001816001161561010002031660029004905014611d5557600560008b815260200190815260200160002060008481526020019081526020016000206000838152602001908152602001600020600081819054906101000a900461ffff16809291906001900391906101000a81548161ffff021916908361ffff160217905550505b600460008b81526020019081526020016000206000848152602001908152602001600020600083815260200190815260200160002060008961ffff1661ffff1681526020019081526020016000206000611daf919061277d565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051611de192919061336e565b60405180910390a2611f62565b6000600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff1681526020019081526020016000208054600181600116156101000203166002900490501415611ec257600560008b815260200190815260200160002060008481526020019081526020016000206000838152602001908152602001600020600081819054906101000a900461ffff168092919060010191906101000a81548161ffff021916908361ffff160217905550505b80600460008c81526020019081526020016000206000858152602001908152602001600020600084815260200190815260200160002060008a61ffff1661ffff1681526020019081526020016000209080519060200190611f249291906126fd565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a84604051611f599392919061339e565b60405180910390a25b50505050505050505050565b8060c00151816020018181525050806000015151816020015110611f915761207f565b6000611fa582600001518360200151612151565b8260200151019050611fc481836000015161224390919063ffffffff16565b826040019061ffff16908161ffff1681525050600281019050611ff481836000015161224390919063ffffffff16565b826060019061ffff16908161ffff168152505060028101905061202481836000015161226990919063ffffffff16565b826080019063ffffffff16908163ffffffff1681525050600481019050600061205a82846000015161224390919063ffffffff16565b61ffff169050600282019150818360a00181815250508082018360c001818152505050505b50565b6000601482511461209257600080fd5b600c6101000a6020830151049050919050565b606060146040519080825280601f01601f1916602001820160405280156120db5781602001600182028038833980820191505090505b509050600c6101000a82026020820152919050565b600063691f343160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061214a575061214982612291565b5b9050919050565b6000808290505b6001156121a0578351811061216957fe5b600061217e82866122fe90919063ffffffff16565b60ff1690506001810182019150600081141561219a57506121a0565b50612158565b82810391505092915050565b6060835182840111156121be57600080fd5b6060826040519080825280601f01601f1916602001820160405280156121f35781602001600182028038833980820191505090505b5090506000806020830191508560208801019050612212828287612322565b8293505050509392505050565b600061222c84848461236b565b61223787878561236b565b14905095945050505050565b6000825160028301111561225657600080fd5b61ffff8260028501015116905092915050565b6000825160048301111561227c57600080fd5b63ffffffff8260048501015116905092915050565b600060405161229f90613226565b60405180910390207bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806122f757506122f68261238e565b5b9050919050565b600082828151811061230c57fe5b602001015160f81c60f81b60f81c905092915050565b5b602081106123465781518352602083019250602082019150602081039050612323565b60006001826020036101000a0390508019835116818551168181178652505050505050565b60008351828401111561237d57600080fd5b818360208601012090509392505050565b600063a8fa568260e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806123e857506123e7826123ef565b5b9050919050565b600063bc1c58d160e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161480612449575061244882612450565b5b9050919050565b6000633b3b57de60e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806124e9575063f1cb7e0660e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b806124f957506124f882612500565b5b9050919050565b6000632203ab5660e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061255a575061255982612561565b5b9050919050565b60006301ffc9a760e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b6040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061263e57803560ff191683800117855561266c565b8280016001018555821561266c579182015b8281111561266b578235825591602001919060010190612650565b5b50905061267991906127c5565b5090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106126be57803560ff19168380011785556126ec565b828001600101855582156126ec579182015b828111156126eb5782358255916020019190600101906126d0565b5b5090506126f991906127c5565b5090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061273e57805160ff191683800117855561276c565b8280016001018555821561276c579182015b8281111561276b578251825591602001919060010190612750565b5b50905061277991906127c5565b5090565b50805460018160011615610100020316600290046000825580601f106127a357506127c2565b601f0160209004906000526020600020908101906127c191906127c5565b5b50565b6127e791905b808211156127e35760008160009055506001016127cb565b5090565b90565b6000813590506127f981613679565b92915050565b60008151905061280e81613679565b92915050565b60008083601f84011261282657600080fd5b8235905067ffffffffffffffff81111561283f57600080fd5b60208301915083602082028301111561285757600080fd5b9250929050565b60008135905061286d81613690565b92915050565b600081359050612882816136a7565b92915050565b600081359050612897816136be565b92915050565b60008083601f8401126128af57600080fd5b8235905067ffffffffffffffff8111156128c857600080fd5b6020830191508360018202830111156128e057600080fd5b9250929050565b600082601f8301126128f857600080fd5b813561290b61290682613486565b613459565b9150808252602083016020830185838301111561292757600080fd5b612932838284613626565b50505092915050565b60008083601f84011261294d57600080fd5b8235905067ffffffffffffffff81111561296657600080fd5b60208301915083600182028301111561297e57600080fd5b9250929050565b600081359050612994816136d5565b92915050565b6000813590506129a9816136ec565b92915050565b6000602082840312156129c157600080fd5b60006129cf848285016127ff565b91505092915050565b600080602083850312156129eb57600080fd5b600083013567ffffffffffffffff811115612a0557600080fd5b612a1185828601612814565b92509250509250929050565b600060208284031215612a2f57600080fd5b6000612a3d84828501612873565b91505092915050565b60008060408385031215612a5957600080fd5b6000612a6785828601612873565b9250506020612a78858286016127ea565b9150509250929050565b600080600060608486031215612a9757600080fd5b6000612aa586828701612873565b9350506020612ab6868287016127ea565b9250506040612ac7868287016127ea565b9150509250925092565b600080600060608486031215612ae657600080fd5b6000612af486828701612873565b9350506020612b05868287016127ea565b9250506040612b168682870161285e565b9150509250925092565b60008060408385031215612b3357600080fd5b6000612b4185828601612873565b9250506020612b5285828601612873565b9150509250929050565b600080600060608486031215612b7157600080fd5b6000612b7f86828701612873565b9350506020612b9086828701612873565b9250506040612ba186828701612873565b9150509250925092565b600080600060608486031215612bc057600080fd5b6000612bce86828701612873565b9350506020612bdf86828701612873565b9250506040612bf086828701612985565b9150509250925092565b60008060408385031215612c0d57600080fd5b6000612c1b85828601612873565b9250506020612c2c85828601612888565b9150509250929050565b600080600060608486031215612c4b57600080fd5b6000612c5986828701612873565b9350506020612c6a86828701612888565b9250506040612c7b868287016127ea565b9150509250925092565b600080600060408486031215612c9a57600080fd5b6000612ca886828701612873565b935050602084013567ffffffffffffffff811115612cc557600080fd5b612cd18682870161289d565b92509250509250925092565b600080600060408486031215612cf257600080fd5b6000612d0086828701612873565b935050602084013567ffffffffffffffff811115612d1d57600080fd5b612d298682870161293b565b92509250509250925092565b600080600080600060608688031215612d4d57600080fd5b6000612d5b88828901612873565b955050602086013567ffffffffffffffff811115612d7857600080fd5b612d848882890161293b565b9450945050604086013567ffffffffffffffff811115612da357600080fd5b612daf8882890161293b565b92509250509295509295909350565b60008060408385031215612dd157600080fd5b6000612ddf85828601612873565b9250506020612df08582860161299a565b9150509250929050565b60008060008060608587031215612e1057600080fd5b6000612e1e87828801612873565b9450506020612e2f8782880161299a565b935050604085013567ffffffffffffffff811115612e4c57600080fd5b612e588782880161289d565b925092505092959194509250565b600080600060608486031215612e7b57600080fd5b6000612e8986828701612873565b9350506020612e9a8682870161299a565b925050604084013567ffffffffffffffff811115612eb757600080fd5b612ec3868287016128e7565b9150509250925092565b600060208284031215612edf57600080fd5b6000612eed84828501612888565b91505092915050565b6000612f028383613095565b905092915050565b612f13816135f0565b82525050565b612f2281613564565b82525050565b612f3181613552565b82525050565b6000612f42826134bf565b612f4c81856134f8565b935083602082028501612f5e856134b2565b8060005b85811015612f9a5784840389528151612f7b8582612ef6565b9450612f86836134eb565b925060208a01995050600181019050612f62565b50829750879550505050505092915050565b612fb581613576565b82525050565b612fc481613582565b82525050565b612fd38161358c565b82525050565b6000612fe5838561351a565b9350612ff2838584613626565b612ffb83613668565b840190509392505050565b6000613012838561352b565b935061301f838584613626565b82840190509392505050565b6000613036826134d5565b613040818561351a565b9350613050818560208601613635565b61305981613668565b840191505092915050565b600061306f826134d5565b613079818561352b565b9350613089818560208601613635565b80840191505092915050565b60006130a0826134ca565b6130aa8185613509565b93506130ba818560208601613635565b6130c381613668565b840191505092915050565b60006130da8385613536565b93506130e7838584613626565b6130f083613668565b840190509392505050565b60006131078385613547565b9350613114838584613626565b82840190509392505050565b600061312b826134e0565b6131358185613536565b9350613145818560208601613635565b61314e81613668565b840191505092915050565b6000613166602483613547565b91507f696e74657266616365496d706c656d656e74657228627974657333322c62797460008301527f65733429000000000000000000000000000000000000000000000000000000006020830152602482019050919050565b6131c8816135b8565b82525050565b6131d7816135e6565b82525050565b60006131ea828486613006565b91508190509392505050565b60006132028284613064565b915081905092915050565b600061321a8284866130fb565b91508190509392505050565b600061323182613159565b9150819050919050565b60006020820190506132506000830184612f28565b92915050565b600060208201905061326b6000830184612f0a565b92915050565b60006020820190506132866000830184612f19565b92915050565b600060208201905081810360008301526132a68184612f37565b905092915050565b60006020820190506132c36000830184612fac565b92915050565b60006020820190506132de6000830184612fbb565b92915050565b60006040820190506132f96000830185612fbb565b6133066020830184612fbb565b9392505050565b60006020820190506133226000830184612fca565b92915050565b60006020820190508181036000830152613343818486612fd9565b90509392505050565b60006020820190508181036000830152613366818461302b565b905092915050565b60006040820190508181036000830152613388818561302b565b905061339760208301846131bf565b9392505050565b600060608201905081810360008301526133b8818661302b565b90506133c760208301856131bf565b81810360408301526133d9818461302b565b9050949350505050565b600060208201905081810360008301526133fe8184866130ce565b90509392505050565b600060208201905081810360008301526134218184613120565b905092915050565b600060408201905061343e60008301856131ce565b8181036020830152613450818461302b565b90509392505050565b6000604051905081810181811067ffffffffffffffff8211171561347c57600080fd5b8060405250919050565b600067ffffffffffffffff82111561349d57600080fd5b601f19601f8301169050602081019050919050565b6000602082019050919050565b600081519050919050565b600081519050919050565b600081519050919050565b600081519050919050565b6000602082019050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b600061355d826135c6565b9050919050565b600061356f826135c6565b9050919050565b60008115159050919050565b6000819050919050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b600061ffff82169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006135fb82613602565b9050919050565b600061360d82613614565b9050919050565b600061361f826135c6565b9050919050565b82818337600083830152505050565b60005b83811015613653578082015181840152602081019050613638565b83811115613662576000848401525b50505050565b6000601f19601f8301169050919050565b61368281613552565b811461368d57600080fd5b50565b61369981613576565b81146136a457600080fd5b50565b6136b081613582565b81146136bb57600080fd5b50565b6136c78161358c565b81146136d257600080fd5b50565b6136de816135b8565b81146136e957600080fd5b50565b6136f5816135e6565b811461370057600080fd5b5056fea265627a7a7230582049ebf27fa2f4353ae0dc98302f101fe3256ef5930b91c52222dcf860d94f3c326c6578706572696d656e74616cf50037","sourceMap":"520:2174:3:-;;;1151:56;8:9:-1;5:2;;;30:1;27;20:12;5:2;1151:56:3;;;;;;;;;;;;;;;;;;;;;;1196:4;1190:3;;:10;;;;;;;;;;;;;;;;;;1151:56;520:2174;;5:158:-1;;101:6;95:13;86:22;;113:45;152:5;113:45;;;80:83;;;;;170:287;;297:2;285:9;276:7;272:23;268:32;265:2;;;313:1;310;303:12;265:2;348:1;365:76;433:7;424:6;413:9;409:22;365:76;;;355:86;;327:120;259:198;;;;;464:91;;526:24;544:5;526:24;;;515:35;;509:46;;;;562:103;;636:24;654:5;636:24;;;625:35;;619:46;;;;672:121;;745:42;738:5;734:54;723:65;;717:76;;;;800:141;881:36;911:5;881:36;;;874:5;871:47;861:2;;932:1;929;922:12;861:2;855:86;;520:2174:3;;;;;;;","deployedSourceMap":"520:2174:3:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;520:2174:3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1107:169:13;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;2403:1263:9;;;;;;;;;;;;;;;;:::i;:::-;;573:184:13;;;;;;;;;;;;;;;;:::i;:::-;;1721:953:10;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;1195:454:6;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;612:169:12;;;;;;;;;;;;;;;;:::i;:::-;;505:166:8;;;;;;;;;;;;;;;;:::i;:::-;;972:228:7;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;1892:231:3;;;;;;;;;;;;;;;;:::i;:::-;;4450:153:9;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;974:127:13;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;582:292:6;;;;;;;;;;;;;;;;:::i;:::-;;844:101:11;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;492:152;;;;;;;;;;;;;;;;:::i;:::-;;1206:286:7;;;;;;;;;;;;;;;;:::i;:::-;;4068:168:9;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;2326:366:3;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;4742:128:9;;;;;;;;;;;;;;;;:::i;:::-;;838:108:8;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;1023:133:12;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;681:132:7;;;;;;;;;;;;;;;;:::i;:::-;;858:226:10;;;;;;;;;;;;;;;;:::i;:::-;;1498:127:7;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;943:80:3;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;1107:169:13;1174:4;144:10;1212:17;;1197:32;;;:11;:32;;;;:72;;;;1233:36;1257:11;1233:23;:36::i;:::-;1197:72;1190:79;;1107:169;;;:::o;2403:1263:9:-;2481:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;2497:15:9;2515:1;2497:19;;2526:14;2543:1;2526:18;;2554:17;2581:18;2609:16;2701:30;;:::i;:::-;2734:18;2750:1;2734:4;;:15;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30:3:-1;22:6;14;1:33;99:1;93:3;85:6;81:16;74:27;137:4;133:9;126:4;121:3;117:14;113:30;106:37;;169:3;161:6;157:16;147:26;;2734:15:9;;;;;;;;:18;;;;:::i;:::-;2701:51;;2696:821;2755:11;:4;:9;:11::i;:::-;2696:821;;2811:1;2799:8;:13;;;2795:712;;;2843:4;:12;;;2832:23;;2880:11;:4;:9;:11::i;:::-;2873:18;;2947:4;2930:22;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;2930:22:9;;;2920:33;;;;;;2909:44;;2985:12;:4;:10;:12::i;:::-;2971:27;;2795:712;;;3037:20;3060:11;:4;:9;:11::i;:::-;3037:34;;3105:4;:12;;;3093:24;;:8;:24;;;;:49;;;;3122:20;3134:7;3122:4;:11;;:20;;;;:::i;:::-;3121:21;3093:49;3089:404;;;3166:88;3178:4;3184;3190:8;3200:4;;3166:88;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30:3:-1;22:6;14;1:33;99:1;93:3;85:6;81:16;74:27;137:4;133:9;126:4;121:3;117:14;113:30;106:37;;169:3;161:6;157:16;147:26;;3166:88:9;;;;;;3206:6;3228;3214:4;:11;;;:20;3252:1;3236:5;:12;:17;3166:11;:88::i;:::-;3287:4;:12;;;3276:23;;3330:4;:11;;;3321:20;;3370:7;3363:14;;3420:4;3410:15;;;;;;3399:26;;3461:12;:4;:10;:12::i;:::-;3447:27;;3089:404;2795:712;;2768:11;:4;:9;:11::i;:::-;2696:821;;;;3544:1;3530:4;:11;:15;3526:134;;;3561:88;3573:4;3579;3585:8;3595:4;;3561:88;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30:3:-1;22:6;14;1:33;99:1;93:3;85:6;81:16;74:27;137:4;133:9;126:4;121:3;117:14;113:30;106:37;;169:3;161:6;157:16;147:26;;3561:88:9;;;;;;3601:6;3623;3609:4;;:11;;:20;3647:1;3631:5;:12;:17;3561:11;:88::i;:::-;3526:134;400:1:5;;;;;2403:1263:9;;;;:::o;573:184:13:-;668:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;703:5:13;;684;:11;690:4;684:11;;;;;;;;;;;696:3;;684:16;;;;;;;;;;;;;;;;;;;;;:24;;;;;;;:::i;:::-;;741:3;;723:27;;;;;;;;;;;;;;;;735:4;723:27;746:3;;723:27;;;;;;;;;;;;;;;;573:184;;;;;;:::o;1721:953:10:-;1808:7;1827:19;1849:10;:16;1860:4;1849:16;;;;;;;;;;;:29;1866:11;1849:29;;;;;;;;;;;;;;;;;;;;;;;;;;;1827:51;;1914:1;1891:25;;:11;:25;;;1888:73;;1939:11;1932:18;;;;;1888:73;1971:9;1983:10;1988:4;1983;:10::i;:::-;1971:22;;2019:1;2006:15;;:1;:15;;;2003:62;;;2052:1;2037:17;;;;;;2003:62;2076:12;2090:23;2117:1;:12;;304:10;2183:17;;2130:71;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;2130:71:10;;;;;;;38:4:-1;29:7;25:18;67:10;61:17;96:58;199:8;192:4;186;182:15;179:29;167:10;160:49;0:215;;;2130:71:10;2117:85;;;;;;;;;;;;;;;;;;;;;;14:1:-1;21;16:31;;;;75:4;69:11;64:16;;144:4;140:9;133:4;115:16;111:27;107:43;104:1;100:51;94:4;87:65;169:16;166:1;159:27;225:16;222:1;215:4;212:1;208:12;193:49;7:242;;16:31;36:4;31:9;;7:242;;2075:127:10;;;;2216:7;2215:8;:34;;;;2247:2;2227:10;:17;:22;2215:34;:57;;;;2271:1;2253:19;;:10;2264:2;2253:14;;;;;;;;;;;;;;;;:19;;;;2215:57;2212:151;;;2350:1;2335:17;;;;;;;;2212:151;2397:1;:12;;2463:11;2410:65;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;2410:65:10;;;;;;;38:4:-1;29:7;25:18;67:10;61:17;96:58;199:8;192:4;186;182:15;179:29;167:10;160:49;0:215;;;2410:65:10;2397:79;;;;;;;;;;;;;;;;;;;;;;14:1:-1;21;16:31;;;;75:4;69:11;64:16;;144:4;140:9;133:4;115:16;111:27;107:43;104:1;100:51;94:4;87:65;169:16;166:1;159:27;225:16;222:1;215:4;212:1;208:12;193:49;7:242;;16:31;36:4;31:9;;7:242;;2373:103:10;;;;;;;;2490:7;2489:8;:34;;;;2521:2;2501:10;:17;:22;2489:34;:57;;;;2545:1;2527:19;;:10;2538:2;2527:14;;;;;;;;;;;;;;;;:19;;;;2489:57;2486:163;;;2636:1;2621:17;;;;;;;;2486:163;2666:1;2659:8;;;;;;1721:953;;;;;:::o;1195:454:6:-;1267:7;1276:12;1300:38;1341:4;:10;1346:4;1341:10;;;;;;;;;;;1300:51;;1367:19;1389:1;1367:23;;1362:249;1407:12;1392:11;:27;1362:249;;1490:1;1473:12;1459:11;:26;1458:33;;:67;;;;;1524:1;1495:6;:19;1502:11;1495:19;;;;;;;;;;;:26;;;;;;;;;;;;;;;;:30;1458:67;1454:147;;;1553:11;1566:6;:19;1573:11;1566:19;;;;;;;;;;;1545:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1454:147;1437:1;1421:17;;;;;1362:249;;;;1629:1;1632:9;;;;;;;;;;;;1621:21;;;;;;;;1195:454;;;;;;:::o;612:169:12:-;687:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;719:15:12;;;;;;;;729:1;719:15;;;;732:1;719:15;;;703:7;:13;711:4;703:13;;;;;;;;;;;:31;;;;;;;;;;;;;;;;;;;763:4;749:25;769:1;772;749:25;;;;;;;;;;;;;;;;612:169;;;;:::o;505:166:8:-;584:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;615:4:8;;600:6;:12;607:4;600:12;;;;;;;;;;;:19;;;;;;;:::i;:::-;;653:4;634:30;659:4;;634:30;;;;;;;;;;;;;;;;505:166;;;;:::o;972:228:7:-;1021:15;1048:14;1065:25;1070:4;261:2;1065:4;:25::i;:::-;1048:42;;1115:1;1103;:8;:13;1100:60;;;1147:1;1132:17;;;;;1100:60;1176:17;1191:1;1176:14;:17::i;:::-;1169:24;;;972:228;;;;:::o;1892:231:3:-;2029:12;1986:14;:20;2001:4;1986:20;;;;;;;;;;;:32;2007:10;1986:32;;;;;;;;;;;;;;;:40;2019:6;1986:40;;;;;;;;;;;;;;;;:55;;;;;;;;;;;;;;;;;;2095:6;2056:60;;2083:10;2056:60;;2077:4;2056:60;2103:12;2056:60;;;;;;;;;;;;;;;1892:231;;;:::o;4450:153:9:-;4522:4;4594:1;4546:16;:22;4563:4;4546:22;;;;;;;;;;;:38;4569:8;:14;4578:4;4569:14;;;;;;;;;;;;4546:38;;;;;;;;;;;:44;4585:4;4546:44;;;;;;;;;;;;;;;;;;;;;:49;;;;4538:58;;4450:153;;;;:::o;974:127:13:-;1046:13;1078:5;:11;1084:4;1078:11;;;;;;;;;;;1090:3;;1078:16;;;;;;;;;;;;;;;;;;;;;1071:23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;974:127;;;;;:::o;582:292:6:-;674:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;780:1:6;764:11;759:1;745:11;:15;744:31;743:38;735:47;;;;;;819:4;;793;:10;798:4;793:10;;;;;;;;;;;:23;804:11;793:23;;;;;;;;;;;:30;;;;;;;:::i;:::-;;855:11;849:4;838:29;;;;;;;;;;582:292;;;;;:::o;844:101:11:-;895:13;927:5;:11;933:4;927:11;;;;;;;;;;;920:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;844:101;;;:::o;492:152::-;565:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;595:4:11;;581:5;:11;587:4;581:11;;;;;;;;;;;:18;;;;;;;:::i;:::-;;626:4;614:23;632:4;;614:23;;;;;;;;;;;;;;;;492:152;;;;:::o;1206:286:7:-;1286:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;1322:4:7;1307:33;1328:8;1338:1;1307:33;;;;;;;;;;;;;;;;261:2;1353:8;:25;1350:96;;;1411:4;1399:36;1417:17;1432:1;1417:14;:17::i;:::-;1399:36;;;;;;;;;;;;;;;1350:96;1484:1;1455:10;:16;1466:4;1455:16;;;;;;;;;;;:26;1472:8;1455:26;;;;;;;;;;;:30;;;;;;;;;;;;:::i;:::-;;1206:286;;;;:::o;4068:168:9:-;4153:12;4184:7;:13;4192:4;4184:13;;;;;;;;;;;:29;4198:8;:14;4207:4;4198:14;;;;;;;;;;;;4184:29;;;;;;;;;;;:35;4214:4;4184:35;;;;;;;;;;;:45;4220:8;4184:45;;;;;;;;;;;;;;;4177:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4068:168;;;;;:::o;2326:366:3:-;2385:22;2441:4;;:11;;2429:24;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2419:34;;2467:6;2476:1;2467:10;;2463:199;2483:4;;:11;;2479:1;:15;2463:199;;;2516:12;2530:19;2561:4;2553:26;;2580:4;;2585:1;2580:7;;;;;;;;;;;;;43:11:-1;30:25;137:1;131:4;127:12;116:8;100:14;96:29;92:48;72:18;68:73;58:2;;155:1;152;145:12;58:2;188:18;178:8;174:33;162:45;;0:210;29:8;16:22;6:32;;69:4;59:8;55:19;43:31;;93:18;85:6;82:30;79:2;;;125:1;122;115:12;79:2;183:3;175:6;171:16;155:14;151:37;141:8;137:52;134:2;;;202:1;199;192:12;134:2;2553:35:3;;;;;;;;;;;;;;;;;;;;;;;14:1:-1;21;16:31;;;;75:4;69:11;64:16;;144:4;140:9;133:4;115:16;111:27;107:43;104:1;100:51;94:4;87:65;169:16;166:1;159:27;225:16;222:1;215:4;212:1;208:12;193:49;7:242;;16:31;36:4;31:9;;7:242;;2515:73:3;;;;2610:7;2602:16;;;;;;2645:6;2632:7;2640:1;2632:10;;;;;;;;;;;;;:19;;;;2463:199;;2496:3;;;;;;;2463:199;;;;2678:7;2671:14;;2326:366;;;;:::o;4742:128:9:-;4796:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;4812:8:9;:14;4821:4;4812:14;;;;;;;;;;;;:16;;;;;;;;;;;;;4858:4;4843:20;;;;;;;;;;4742:128;;:::o;838:108:8:-;896:12;927:6;:12;934:4;927:12;;;;;;;;;;;920:19;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;838:108;;;:::o;1023:133:12:-;1076:9;1087;1116:7;:13;1124:4;1116:13;;;;;;;;;;;:15;;;1133:7;:13;1141:4;1133:13;;;;;;;;;;;:15;;;1108:41;;;;1023:133;;;:::o;681:132:7:-;743:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;759:47:7;767:4;261:2;788:17;803:1;788:14;:17::i;:::-;759:7;:47::i;:::-;681:132;;;:::o;858:226:10:-;955:4;371:18:5;384:4;371:12;:18::i;:::-;363:27;;;;;;1003:11:10;971:10;:16;982:4;971:16;;;;;;;;;;;:29;988:11;971:29;;;;;;;;;;;;;;;;;;:43;;;;;;;;;;;;;;;;;;1052:11;1029:48;;;1046:4;1029:48;1065:11;1029:48;;;;;;;;;;;;;;;858:226;;;;:::o;1498:127:7:-;1561:12;1592:10;:16;1603:4;1592:16;;;;;;;;;;;:26;1609:8;1592:26;;;;;;;;;;;1585:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1498:127;;;;:::o;943:80:3:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;1162:171:12:-;1229:4;148:10;1267:19;;1252:34;;;:11;:34;;;;:74;;;;1290:36;1314:11;1290:23;:36::i;:::-;1252:74;1245:81;;1162:171;;;:::o;2129:191:3:-;2187:4;2203:13;2219:3;;;;;;;;;;;:9;;;2229:4;2219:15;;;;;;;;;;;;;;;;;;;;;;;;;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;2219:15:3;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;2219:15:3;;;;;;;101:4:-1;97:9;90:4;84;80:15;76:31;69:5;65:43;126:6;120:4;113:20;0:138;2219:15:3;;;;;;;;;2203:31;;2260:10;2251:19;;:5;:19;;;:62;;;;2274:14;:20;2289:4;2274:20;;;;;;;;;;;:27;2295:5;2274:27;;;;;;;;;;;;;;;:39;2302:10;2274:39;;;;;;;;;;;;;;;;;;;;;;;;;2251:62;2244:69;;;2129:191;;;:::o;2435:182:16:-;2510:21;;:::i;:::-;2554:4;2543:3;:8;;:15;;;;2585:6;2568:3;:14;;:23;;;;;2601:9;2606:3;2601:4;:9::i;:::-;2435:182;;;;:::o;2788:121::-;2848:4;2886;:9;;;:16;2871:4;:11;;;:31;;2864:38;;2788:121;;;:::o;3890:166::-;3950:12;3981:68;4001:4;:11;;;4014:34;4025:4;:9;;;4036:4;:11;;;4014:10;:34::i;:::-;3981:4;:9;;;:19;;:68;;;;;:::i;:::-;3974:75;;3890:166;;;:::o;4229:172::-;4290:12;4321:73;4341:4;:16;;;4377:4;:16;;;4359:4;:15;;;:34;4321:4;:9;;;:19;;:73;;;;;:::i;:::-;4314:80;;4229:172;;;:::o;4913:176:15:-;4990:4;5028:5;:12;5013:4;:11;:27;:69;;;;;5044:38;5051:4;5057:1;5060:5;5067:1;5070:4;:11;5044:6;:38::i;:::-;5013:69;5006:76;;4913:176;;;;:::o;5057:965:9:-;5275:15;5293:8;:14;5302:4;5293:14;;;;;;;;;;;;5275:32;;5317:16;5346:4;5336:15;;;;;;5317:34;;5361:19;5383:28;5398:6;5406:4;5383;:14;;:28;;;;;:::i;:::-;5361:50;;5425:12;5421:595;;;5510:1;5457:7;:13;5465:4;5457:13;;;;;;;;;;;:22;5471:7;5457:22;;;;;;;;;;;:32;5480:8;5457:32;;;;;;;;;;;:42;5490:8;5457:42;;;;;;;;;;;;;;;:49;;;;;;;;;;;;;;;;:54;5453:136;;5531:16;:22;5548:4;5531:22;;;;;;;;;;;:31;5554:7;5531:31;;;;;;;;;;;:41;5563:8;5531:41;;;;;;;;;;;;:43;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5453:136;5609:7;:13;5617:4;5609:13;;;;;;;;;;;:22;5623:7;5609:22;;;;;;;;;;;:32;5632:8;5609:32;;;;;;;;;;;:42;5642:8;5609:42;;;;;;;;;;;;;;;;5602:50;;;;:::i;:::-;5688:4;5671:38;5694:4;5700:8;5671:38;;;;;;;;;;;;;;;;5421:595;;;5797:1;5744:7;:13;5752:4;5744:13;;;;;;;;;;;:22;5758:7;5744:22;;;;;;;;;;;:32;5767:8;5744:32;;;;;;;;;;;:42;5777:8;5744:42;;;;;;;;;;;;;;;:49;;;;;;;;;;;;;;;;:54;5740:136;;;5818:16;:22;5835:4;5818:22;;;;;;;;;;;:31;5841:7;5818:31;;;;;;;;;;;:41;5850:8;5818:41;;;;;;;;;;;;:43;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5740:136;5934:6;5889:7;:13;5897:4;5889:13;;;;;;;;;;;:22;5903:7;5889:22;;;;;;;;;;;:32;5912:8;5889:32;;;;;;;;;;;:42;5922:8;5889:42;;;;;;;;;;;;;;;:51;;;;;;;;;;;;:::i;:::-;;5976:4;5959:46;5982:4;5988:8;5998:6;5959:46;;;;;;;;;;;;;;;;;5421:595;5057:965;;;;;;;;;;:::o;3032:682:16:-;3108:4;:15;;;3094:4;:11;;:29;;;;;3152:4;:9;;;:16;3137:4;:11;;;:31;3133:68;;3184:7;;3133:68;3236:8;3261:34;3272:4;:9;;;3283:4;:11;;;3261:10;:34::i;:::-;3247:4;:11;;;:48;3236:59;;3358:25;3379:3;3358:4;:9;;;:20;;:25;;;;:::i;:::-;3343:4;:12;;:40;;;;;;;;;;;3400:1;3393:8;;;;3424:25;3445:3;3424:4;:9;;;:20;;:25;;;;:::i;:::-;3411:4;:10;;:38;;;;;;;;;;;3466:1;3459:8;;;;3488:25;3509:3;3488:4;:9;;;:20;;:25;;;;:::i;:::-;3477:4;:8;;:36;;;;;;;;;;;3530:1;3523:8;;;;3568:16;3587:25;3608:3;3587:4;:9;;;:20;;:25;;;;:::i;:::-;3568:44;;;;3629:1;3622:8;;;;3659:3;3640:4;:16;;:22;;;;;3696:11;3690:3;:17;3672:4;:15;;:35;;;;;3032:682;;;;:::o;414:204:5:-;476:17;525:2;513:1;:8;:14;505:23;;;;;;598:2;593:3;589:12;583:2;580:1;576:10;570:17;566:36;561:41;;547:65;;;:::o;624:189::-;681:14;721:2;711:13;;;;;;;;;;;;;;;;;;;;;;;;;29:1:-1;21:6;17:14;116:4;104:10;96:6;87:34;147:4;139:6;135:17;125:27;;0:156;711:13:5;;;;707:17;;792:2;787:3;783:12;780:1;776:20;771:2;768:1;764:10;757:40;743:64;;;:::o;951:169:11:-;1018:4;144:10;1056:17;;1041:32;;;:11;:32;;;;:72;;;;1077:36;1101:11;1077:23;:36::i;:::-;1041:72;1034:79;;951:169;;;:::o;535:367:16:-;609:4;625:8;636:6;625:17;;652:215;659:4;652:215;;;692:4;:11;686:3;:17;679:25;;;;718:13;734:19;749:3;734:4;:14;;:19;;;;:::i;:::-;718:35;;;;785:1;774:8;:12;767:19;;;;816:1;804:8;:13;800:57;;;837:5;;;800:57;652:215;;;;889:6;883:3;:12;876:19;;;535:367;;;;:::o;8683:393:15:-;8766:12;8814:4;:11;8807:3;8798:6;:12;:27;;8790:36;;;;;;8837:16;8866:3;8856:14;;;;;;;;;;;;;;;;;;;;;;;;;29:1:-1;21:6;17:14;116:4;104:10;96:6;87:34;147:4;139:6;135:17;125:27;;0:156;8856:14:15;;;;8837:33;;8880:9;8899:8;8958:2;8953:3;8949:12;8941:20;;9000:6;8995:2;8989:4;8985:13;8981:26;8974:33;;9026:22;9033:4;9039:3;9044;9026:6;:22::i;:::-;9066:3;9059:10;;;;;8683:393;;;;;:::o;3277:209::-;3396:4;3448:31;3455:5;3462:11;3475:3;3448:6;:31::i;:::-;3419:25;3426:4;3432:6;3440:3;3419:6;:25::i;:::-;:60;3412:67;;3277:209;;;;;;;:::o;5697:223::-;5769:10;5810:4;:11;5805:1;5799:3;:7;:22;;5791:31;;;;;;5897:6;5890:3;5886:1;5880:4;5876:12;5872:22;5866:29;5862:42;5855:49;;5841:73;;;;:::o;6164:227::-;6236:10;6277:4;:11;6272:1;6266:3;:7;:22;;6258:31;;;;;;6364:10;6357:3;6353:1;6347:4;6343:12;6339:22;6333:29;6329:46;6322:53;;6308:77;;;;:::o;2680:174:10:-;2747:4;204:49;;;;;;;;;;;;;;2770:37;;;:11;:37;;;;:77;;;;2811:36;2835:11;2811:23;:36::i;:::-;2770:77;2763:84;;2680:174;;;:::o;5331:122:15:-;5402:9;5436:4;5441:3;5436:9;;;;;;;;;;;;;;;;5430:16;;5423:23;;5331:122;;;;:::o;7914:549::-;8034:165;8048:2;8041:3;:9;8034:165;;8123:3;8117:10;8111:4;8104:24;8163:2;8155:10;;;;8186:2;8179:9;;;;8059:2;8052:9;;;;8034:165;;;8241:9;8273:1;8266:3;8261:2;:8;8253:3;:17;:21;8241:33;;8342:4;8338:9;8332:3;8326:10;8322:26;8394:4;8387;8381:11;8377:22;8438:7;8428:8;8425:21;8419:4;8412:35;8293:164;;;;;;:::o;306:238::-;387:11;434:4;:11;427:3;418:6;:12;:27;;410:36;;;;;;524:3;515:6;510:2;504:4;500:13;496:26;486:42;479:49;;465:73;;;;;:::o;4876:175:9:-;4943:4;265:10;4981:23;;4966:38;;;:11;:38;;;;:78;;;;5008:36;5032:11;5008:23;:36::i;:::-;4966:78;4959:85;;4876:175;;;:::o;952:177:8:-;1019:4;159:10;1057:25;;1042:40;;;:11;:40;;;;:80;;;;1086:36;1110:11;1086:23;:36::i;:::-;1042:80;1035:87;;952:177;;;:::o;1631:208:7:-;1698:4;144:10;1736:17;;1721:32;;;:11;:32;;;;:71;;;;207:10;1772:20;;1757:35;;;:11;:35;;;;1721:71;:111;;;;1796:36;1820:11;1796:23;:36::i;:::-;1721:111;1714:118;;1631:208;;;:::o;1655:168:6:-;1722:4;142:10;1760:16;;1745:31;;;:11;:31;;;;:71;;;;1780:36;1804:11;1780:23;:36::i;:::-;1745:71;1738:78;;1655:168;;;:::o;114:129:5:-;181:4;97:10;219:17;;204:32;;;:11;:32;;;;197:39;;114:129;;;:::o;520:2174:3:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;5:130:-1:-;;85:6;72:20;63:29;;97:33;124:5;97:33;;;57:78;;;;;142:134;;226:6;220:13;211:22;;238:33;265:5;238:33;;;205:71;;;;;299:359;;;436:3;429:4;421:6;417:17;413:27;403:2;;454:1;451;444:12;403:2;487:6;474:20;464:30;;514:18;506:6;503:30;500:2;;;546:1;543;536:12;500:2;580:4;572:6;568:17;556:29;;631:3;623:4;615:6;611:17;601:8;597:32;594:41;591:2;;;648:1;645;638:12;591:2;396:262;;;;;;666:124;;743:6;730:20;721:29;;755:30;779:5;755:30;;;715:75;;;;;797:130;;877:6;864:20;855:29;;889:33;916:5;889:33;;;849:78;;;;;934:128;;1013:6;1000:20;991:29;;1025:32;1051:5;1025:32;;;985:77;;;;;1083:335;;;1197:3;1190:4;1182:6;1178:17;1174:27;1164:2;;1215:1;1212;1205:12;1164:2;1248:6;1235:20;1225:30;;1275:18;1267:6;1264:30;1261:2;;;1307:1;1304;1297:12;1261:2;1341:4;1333:6;1329:17;1317:29;;1391:3;1384;1376:6;1372:16;1362:8;1358:31;1355:40;1352:2;;;1408:1;1405;1398:12;1352:2;1157:261;;;;;;1427:440;;1528:3;1521:4;1513:6;1509:17;1505:27;1495:2;;1546:1;1543;1536:12;1495:2;1583:6;1570:20;1605:64;1620:48;1661:6;1620:48;;;1605:64;;;1596:73;;1689:6;1682:5;1675:21;1725:4;1717:6;1713:17;1758:4;1751:5;1747:16;1793:3;1784:6;1779:3;1775:16;1772:25;1769:2;;;1810:1;1807;1800:12;1769:2;1820:41;1854:6;1849:3;1844;1820:41;;;1488:379;;;;;;;;1890:336;;;2005:3;1998:4;1990:6;1986:17;1982:27;1972:2;;2023:1;2020;2013:12;1972:2;2056:6;2043:20;2033:30;;2083:18;2075:6;2072:30;2069:2;;;2115:1;2112;2105:12;2069:2;2149:4;2141:6;2137:17;2125:29;;2199:3;2192;2184:6;2180:16;2170:8;2166:31;2163:40;2160:2;;;2216:1;2213;2206:12;2160:2;1965:261;;;;;;2234:128;;2313:6;2300:20;2291:29;;2325:32;2351:5;2325:32;;;2285:77;;;;;2369:130;;2449:6;2436:20;2427:29;;2461:33;2488:5;2461:33;;;2421:78;;;;;2506:263;;2621:2;2609:9;2600:7;2596:23;2592:32;2589:2;;;2637:1;2634;2627:12;2589:2;2672:1;2689:64;2745:7;2736:6;2725:9;2721:22;2689:64;;;2679:74;;2651:108;2583:186;;;;;2776:411;;;2922:2;2910:9;2901:7;2897:23;2893:32;2890:2;;;2938:1;2935;2928:12;2890:2;3001:1;2990:9;2986:17;2973:31;3024:18;3016:6;3013:30;3010:2;;;3056:1;3053;3046:12;3010:2;3084:87;3163:7;3154:6;3143:9;3139:22;3084:87;;;3074:97;;;;2952:225;2884:303;;;;;;3194:241;;3298:2;3286:9;3277:7;3273:23;3269:32;3266:2;;;3314:1;3311;3304:12;3266:2;3349:1;3366:53;3411:7;3402:6;3391:9;3387:22;3366:53;;;3356:63;;3328:97;3260:175;;;;;3442:366;;;3563:2;3551:9;3542:7;3538:23;3534:32;3531:2;;;3579:1;3576;3569:12;3531:2;3614:1;3631:53;3676:7;3667:6;3656:9;3652:22;3631:53;;;3621:63;;3593:97;3721:2;3739:53;3784:7;3775:6;3764:9;3760:22;3739:53;;;3729:63;;3700:98;3525:283;;;;;;3815:491;;;;3953:2;3941:9;3932:7;3928:23;3924:32;3921:2;;;3969:1;3966;3959:12;3921:2;4004:1;4021:53;4066:7;4057:6;4046:9;4042:22;4021:53;;;4011:63;;3983:97;4111:2;4129:53;4174:7;4165:6;4154:9;4150:22;4129:53;;;4119:63;;4090:98;4219:2;4237:53;4282:7;4273:6;4262:9;4258:22;4237:53;;;4227:63;;4198:98;3915:391;;;;;;4313:485;;;;4448:2;4436:9;4427:7;4423:23;4419:32;4416:2;;;4464:1;4461;4454:12;4416:2;4499:1;4516:53;4561:7;4552:6;4541:9;4537:22;4516:53;;;4506:63;;4478:97;4606:2;4624:53;4669:7;4660:6;4649:9;4645:22;4624:53;;;4614:63;;4585:98;4714:2;4732:50;4774:7;4765:6;4754:9;4750:22;4732:50;;;4722:60;;4693:95;4410:388;;;;;;4805:366;;;4926:2;4914:9;4905:7;4901:23;4897:32;4894:2;;;4942:1;4939;4932:12;4894:2;4977:1;4994:53;5039:7;5030:6;5019:9;5015:22;4994:53;;;4984:63;;4956:97;5084:2;5102:53;5147:7;5138:6;5127:9;5123:22;5102:53;;;5092:63;;5063:98;4888:283;;;;;;5178:491;;;;5316:2;5304:9;5295:7;5291:23;5287:32;5284:2;;;5332:1;5329;5322:12;5284:2;5367:1;5384:53;5429:7;5420:6;5409:9;5405:22;5384:53;;;5374:63;;5346:97;5474:2;5492:53;5537:7;5528:6;5517:9;5513:22;5492:53;;;5482:63;;5453:98;5582:2;5600:53;5645:7;5636:6;5625:9;5621:22;5600:53;;;5590:63;;5561:98;5278:391;;;;;;5676:489;;;;5813:2;5801:9;5792:7;5788:23;5784:32;5781:2;;;5829:1;5826;5819:12;5781:2;5864:1;5881:53;5926:7;5917:6;5906:9;5902:22;5881:53;;;5871:63;;5843:97;5971:2;5989:53;6034:7;6025:6;6014:9;6010:22;5989:53;;;5979:63;;5950:98;6079:2;6097:52;6141:7;6132:6;6121:9;6117:22;6097:52;;;6087:62;;6058:97;5775:390;;;;;;6172:364;;;6292:2;6280:9;6271:7;6267:23;6263:32;6260:2;;;6308:1;6305;6298:12;6260:2;6343:1;6360:53;6405:7;6396:6;6385:9;6381:22;6360:53;;;6350:63;;6322:97;6450:2;6468:52;6512:7;6503:6;6492:9;6488:22;6468:52;;;6458:62;;6429:97;6254:282;;;;;;6543:489;;;;6680:2;6668:9;6659:7;6655:23;6651:32;6648:2;;;6696:1;6693;6686:12;6648:2;6731:1;6748:53;6793:7;6784:6;6773:9;6769:22;6748:53;;;6738:63;;6710:97;6838:2;6856:52;6900:7;6891:6;6880:9;6876:22;6856:52;;;6846:62;;6817:97;6945:2;6963:53;7008:7;6999:6;6988:9;6984:22;6963:53;;;6953:63;;6924:98;6642:390;;;;;;7039:490;;;;7179:2;7167:9;7158:7;7154:23;7150:32;7147:2;;;7195:1;7192;7185:12;7147:2;7230:1;7247:53;7292:7;7283:6;7272:9;7268:22;7247:53;;;7237:63;;7209:97;7365:2;7354:9;7350:18;7337:32;7389:18;7381:6;7378:30;7375:2;;;7421:1;7418;7411:12;7375:2;7449:64;7505:7;7496:6;7485:9;7481:22;7449:64;;;7439:74;;;;7316:203;7141:388;;;;;;7536:492;;;;7677:2;7665:9;7656:7;7652:23;7648:32;7645:2;;;7693:1;7690;7683:12;7645:2;7728:1;7745:53;7790:7;7781:6;7770:9;7766:22;7745:53;;;7735:63;;7707:97;7863:2;7852:9;7848:18;7835:32;7887:18;7879:6;7876:30;7873:2;;;7919:1;7916;7909:12;7873:2;7947:65;8004:7;7995:6;7984:9;7980:22;7947:65;;;7937:75;;;;7814:204;7639:389;;;;;;8035:743;;;;;;8213:2;8201:9;8192:7;8188:23;8184:32;8181:2;;;8229:1;8226;8219:12;8181:2;8264:1;8281:53;8326:7;8317:6;8306:9;8302:22;8281:53;;;8271:63;;8243:97;8399:2;8388:9;8384:18;8371:32;8423:18;8415:6;8412:30;8409:2;;;8455:1;8452;8445:12;8409:2;8483:65;8540:7;8531:6;8520:9;8516:22;8483:65;;;8473:75;;;;8350:204;8613:2;8602:9;8598:18;8585:32;8637:18;8629:6;8626:30;8623:2;;;8669:1;8666;8659:12;8623:2;8697:65;8754:7;8745:6;8734:9;8730:22;8697:65;;;8687:75;;;;8564:204;8175:603;;;;;;;;;8785:366;;;8906:2;8894:9;8885:7;8881:23;8877:32;8874:2;;;8922:1;8919;8912:12;8874:2;8957:1;8974:53;9019:7;9010:6;8999:9;8995:22;8974:53;;;8964:63;;8936:97;9064:2;9082:53;9127:7;9118:6;9107:9;9103:22;9082:53;;;9072:63;;9043:98;8868:283;;;;;;9158:615;;;;;9315:2;9303:9;9294:7;9290:23;9286:32;9283:2;;;9331:1;9328;9321:12;9283:2;9366:1;9383:53;9428:7;9419:6;9408:9;9404:22;9383:53;;;9373:63;;9345:97;9473:2;9491:53;9536:7;9527:6;9516:9;9512:22;9491:53;;;9481:63;;9452:98;9609:2;9598:9;9594:18;9581:32;9633:18;9625:6;9622:30;9619:2;;;9665:1;9662;9655:12;9619:2;9693:64;9749:7;9740:6;9729:9;9725:22;9693:64;;;9683:74;;;;9560:203;9277:496;;;;;;;;9780:595;;;;9927:2;9915:9;9906:7;9902:23;9898:32;9895:2;;;9943:1;9940;9933:12;9895:2;9978:1;9995:53;10040:7;10031:6;10020:9;10016:22;9995:53;;;9985:63;;9957:97;10085:2;10103:53;10148:7;10139:6;10128:9;10124:22;10103:53;;;10093:63;;10064:98;10221:2;10210:9;10206:18;10193:32;10245:18;10237:6;10234:30;10231:2;;;10277:1;10274;10267:12;10231:2;10297:62;10351:7;10342:6;10331:9;10327:22;10297:62;;;10287:72;;10172:193;9889:486;;;;;;10382:239;;10485:2;10473:9;10464:7;10460:23;10456:32;10453:2;;;10501:1;10498;10491:12;10453:2;10536:1;10553:52;10597:7;10588:6;10577:9;10573:22;10553:52;;;10543:62;;10515:96;10447:174;;;;;10629:177;;10740:60;10796:3;10788:6;10740:60;;;10726:74;;10719:87;;;;;10814:142;10905:45;10944:5;10905:45;;;10900:3;10893:58;10887:69;;;10963:137;11062:32;11088:5;11062:32;;;11057:3;11050:45;11044:56;;;11107:113;11190:24;11208:5;11190:24;;;11185:3;11178:37;11172:48;;;11254:888;;11409:59;11462:5;11409:59;;;11481:91;11565:6;11560:3;11481:91;;;11474:98;;11595:3;11637:4;11629:6;11625:17;11620:3;11616:27;11664:61;11719:5;11664:61;;;11745:7;11773:1;11758:345;11783:6;11780:1;11777:13;11758:345;;;11845:9;11839:4;11835:20;11830:3;11823:33;11890:6;11884:13;11912:74;11981:4;11966:13;11912:74;;;11904:82;;12003:65;12061:6;12003:65;;;11993:75;;12091:4;12086:3;12082:14;12075:21;;11815:288;11805:1;11802;11798:9;11793:14;;11758:345;;;11762:14;12116:4;12109:11;;12133:3;12126:10;;11388:754;;;;;;;;;;12150:104;12227:21;12242:5;12227:21;;;12222:3;12215:34;12209:45;;;12261:113;12344:24;12362:5;12344:24;;;12339:3;12332:37;12326:48;;;12381:110;12462:23;12479:5;12462:23;;;12457:3;12450:36;12444:47;;;12521:297;;12635:70;12698:6;12693:3;12635:70;;;12628:77;;12717:43;12753:6;12748:3;12741:5;12717:43;;;12782:29;12804:6;12782:29;;;12777:3;12773:39;12766:46;;12621:197;;;;;;12849:306;;12977:88;13058:6;13053:3;12977:88;;;12970:95;;13077:43;13113:6;13108:3;13101:5;13077:43;;;13142:6;13137:3;13133:16;13126:23;;12963:192;;;;;;13163:343;;13273:38;13305:5;13273:38;;;13323:70;13386:6;13381:3;13323:70;;;13316:77;;13398:52;13443:6;13438:3;13431:4;13424:5;13420:16;13398:52;;;13471:29;13493:6;13471:29;;;13466:3;13462:39;13455:46;;13253:253;;;;;;13513:356;;13641:38;13673:5;13641:38;;;13691:88;13772:6;13767:3;13691:88;;;13684:95;;13784:52;13829:6;13824:3;13817:4;13810:5;13806:16;13784:52;;;13857:6;13852:3;13848:16;13841:23;;13621:248;;;;;;13876:315;;13972:34;14000:5;13972:34;;;14018:60;14071:6;14066:3;14018:60;;;14011:67;;14083:52;14128:6;14123:3;14116:4;14109:5;14105:16;14083:52;;;14156:29;14178:6;14156:29;;;14151:3;14147:39;14140:46;;13952:239;;;;;;14223:300;;14339:71;14403:6;14398:3;14339:71;;;14332:78;;14422:43;14458:6;14453:3;14446:5;14422:43;;;14487:29;14509:6;14487:29;;;14482:3;14478:39;14471:46;;14325:198;;;;;;14556:313;;14690:89;14772:6;14767:3;14690:89;;;14683:96;;14791:43;14827:6;14822:3;14815:5;14791:43;;;14856:6;14851:3;14847:16;14840:23;;14676:193;;;;;;14877:347;;14989:39;15022:5;14989:39;;;15040:71;15104:6;15099:3;15040:71;;;15033:78;;15116:52;15161:6;15156:3;15149:4;15142:5;15138:16;15116:52;;;15189:29;15211:6;15189:29;;;15184:3;15180:39;15173:46;;14969:255;;;;;;15232:501;;15410:85;15492:2;15487:3;15410:85;;;15403:92;;15528:66;15524:1;15519:3;15515:11;15508:87;15629:66;15624:2;15619:3;15615:12;15608:88;15724:2;15719:3;15715:12;15708:19;;15396:337;;;;15741:110;15822:23;15839:5;15822:23;;;15817:3;15810:36;15804:47;;;15858:113;15941:24;15959:5;15941:24;;;15936:3;15929:37;15923:48;;;15978:274;;16128:99;16223:3;16214:6;16206;16128:99;;;16121:106;;16244:3;16237:10;;16109:143;;;;;;16259:262;;16403:93;16492:3;16483:6;16403:93;;;16396:100;;16513:3;16506:10;;16384:137;;;;;16528:286;;16684:105;16785:3;16776:6;16768;16684:105;;;16677:112;;16806:3;16799:10;;16665:149;;;;;;16821:372;;17020:148;17164:3;17020:148;;;17013:155;;17185:3;17178:10;;17001:192;;;;17200:213;;17318:2;17307:9;17303:18;17295:26;;17332:71;17400:1;17389:9;17385:17;17376:6;17332:71;;;17289:124;;;;;17420:229;;17546:2;17535:9;17531:18;17523:26;;17560:79;17636:1;17625:9;17621:17;17612:6;17560:79;;;17517:132;;;;;17656:245;;17790:2;17779:9;17775:18;17767:26;;17804:87;17888:1;17877:9;17873:17;17864:6;17804:87;;;17761:140;;;;;17908:381;;18086:2;18075:9;18071:18;18063:26;;18136:9;18130:4;18126:20;18122:1;18111:9;18107:17;18100:47;18161:118;18274:4;18265:6;18161:118;;;18153:126;;18057:232;;;;;18296:201;;18408:2;18397:9;18393:18;18385:26;;18422:65;18484:1;18473:9;18469:17;18460:6;18422:65;;;18379:118;;;;;18504:213;;18622:2;18611:9;18607:18;18599:26;;18636:71;18704:1;18693:9;18689:17;18680:6;18636:71;;;18593:124;;;;;18724:324;;18870:2;18859:9;18855:18;18847:26;;18884:71;18952:1;18941:9;18937:17;18928:6;18884:71;;;18966:72;19034:2;19023:9;19019:18;19010:6;18966:72;;;18841:207;;;;;;19055:209;;19171:2;19160:9;19156:18;19148:26;;19185:69;19251:1;19240:9;19236:17;19227:6;19185:69;;;19142:122;;;;;19271:317;;19417:2;19406:9;19402:18;19394:26;;19467:9;19461:4;19457:20;19453:1;19442:9;19438:17;19431:47;19492:86;19573:4;19564:6;19556;19492:86;;;19484:94;;19388:200;;;;;;19595:297;;19731:2;19720:9;19716:18;19708:26;;19781:9;19775:4;19771:20;19767:1;19756:9;19752:17;19745:47;19806:76;19877:4;19868:6;19806:76;;;19798:84;;19702:190;;;;;19899:404;;20061:2;20050:9;20046:18;20038:26;;20111:9;20105:4;20101:20;20097:1;20086:9;20082:17;20075:47;20136:76;20207:4;20198:6;20136:76;;;20128:84;;20223:70;20289:2;20278:9;20274:18;20265:6;20223:70;;;20032:271;;;;;;20310:599;;20518:2;20507:9;20503:18;20495:26;;20568:9;20562:4;20558:20;20554:1;20543:9;20539:17;20532:47;20593:76;20664:4;20655:6;20593:76;;;20585:84;;20680:70;20746:2;20735:9;20731:18;20722:6;20680:70;;;20798:9;20792:4;20788:20;20783:2;20772:9;20768:18;20761:48;20823:76;20894:4;20885:6;20823:76;;;20815:84;;20489:420;;;;;;;20916:321;;21064:2;21053:9;21049:18;21041:26;;21114:9;21108:4;21104:20;21100:1;21089:9;21085:17;21078:47;21139:88;21222:4;21213:6;21205;21139:88;;;21131:96;;21035:202;;;;;;21244:301;;21382:2;21371:9;21367:18;21359:26;;21432:9;21426:4;21422:20;21418:1;21407:9;21403:17;21396:47;21457:78;21530:4;21521:6;21457:78;;;21449:86;;21353:192;;;;;21552:408;;21716:2;21705:9;21701:18;21693:26;;21730:71;21798:1;21787:9;21783:17;21774:6;21730:71;;;21849:9;21843:4;21839:20;21834:2;21823:9;21819:18;21812:48;21874:76;21945:4;21936:6;21874:76;;;21866:84;;21687:273;;;;;;21967:256;;22029:2;22023:9;22013:19;;22067:4;22059:6;22055:17;22166:6;22154:10;22151:22;22130:18;22118:10;22115:34;22112:62;22109:2;;;22187:1;22184;22177:12;22109:2;22207:10;22203:2;22196:22;22007:216;;;;;22230:258;;22373:18;22365:6;22362:30;22359:2;;;22405:1;22402;22395:12;22359:2;22449:4;22445:9;22438:4;22430:6;22426:17;22422:33;22414:41;;22478:4;22472;22468:15;22460:23;;22296:192;;;;22498:128;;22613:4;22605:6;22601:17;22590:28;;22581:45;;;;22636:112;;22737:5;22731:12;22721:22;;22715:33;;;;22755:87;;22831:5;22825:12;22815:22;;22809:33;;;;22849:91;;22929:5;22923:12;22913:22;;22907:33;;;;22947:92;;23028:5;23022:12;23012:22;;23006:33;;;;23048:129;;23165:4;23157:6;23153:17;23142:28;;23134:43;;;;23187:183;;23322:6;23317:3;23310:19;23359:4;23354:3;23350:14;23335:29;;23303:67;;;;;23379:152;;23483:6;23478:3;23471:19;23520:4;23515:3;23511:14;23496:29;;23464:67;;;;;23540:162;;23654:6;23649:3;23642:19;23691:4;23686:3;23682:14;23667:29;;23635:67;;;;;23711:144;;23846:3;23831:18;;23824:31;;;;;23864:163;;23979:6;23974:3;23967:19;24016:4;24011:3;24007:14;23992:29;;23960:67;;;;;24036:145;;24172:3;24157:18;;24150:31;;;;;24189:91;;24251:24;24269:5;24251:24;;;24240:35;;24234:46;;;;24287:99;;24357:24;24375:5;24357:24;;;24346:35;;24340:46;;;;24393:85;;24466:5;24459:13;24452:21;24441:32;;24435:43;;;;24485:72;;24547:5;24536:16;;24530:27;;;;24564:144;;24636:66;24629:5;24625:78;24614:89;;24608:100;;;;24715:84;;24787:6;24780:5;24776:18;24765:29;;24759:40;;;;24806:121;;24879:42;24872:5;24868:54;24857:65;;24851:76;;;;24934:72;;24996:5;24985:16;;24979:27;;;;25013:129;;25100:37;25131:5;25100:37;;;25087:50;;25081:61;;;;25149:121;;25228:37;25259:5;25228:37;;;25215:50;;25209:61;;;;25277:108;;25356:24;25374:5;25356:24;;;25343:37;;25337:48;;;;25393:145;25474:6;25469:3;25464;25451:30;25530:1;25521:6;25516:3;25512:16;25505:27;25444:94;;;;25547:268;25612:1;25619:101;25633:6;25630:1;25627:13;25619:101;;;25709:1;25704:3;25700:11;25694:18;25690:1;25685:3;25681:11;25674:39;25655:2;25652:1;25648:10;25643:15;;25619:101;;;25735:6;25732:1;25729:13;25726:2;;;25800:1;25791:6;25786:3;25782:16;25775:27;25726:2;25596:219;;;;;25823:97;;25911:2;25907:7;25902:2;25895:5;25891:14;25887:28;25877:38;;25871:49;;;;25928:117;25997:24;26015:5;25997:24;;;25990:5;25987:35;25977:2;;26036:1;26033;26026:12;25977:2;25971:74;;26052:111;26118:21;26133:5;26118:21;;;26111:5;26108:32;26098:2;;26154:1;26151;26144:12;26098:2;26092:71;;26170:117;26239:24;26257:5;26239:24;;;26232:5;26229:35;26219:2;;26278:1;26275;26268:12;26219:2;26213:74;;26294:115;26362:23;26379:5;26362:23;;;26355:5;26352:34;26342:2;;26400:1;26397;26390:12;26342:2;26336:73;;26416:115;26484:23;26501:5;26484:23;;;26477:5;26474:34;26464:2;;26522:1;26519;26512:12;26464:2;26458:73;;26538:117;26607:24;26625:5;26607:24;;;26600:5;26597:35;26587:2;;26646:1;26643;26636:12;26587:2;26581:74;","source":"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\"@ensdomains/ens/contracts/ENS.sol\\";\\nimport \\"./profiles/ABIResolver.sol\\";\\nimport \\"./profiles/AddrResolver.sol\\";\\nimport \\"./profiles/ContentHashResolver.sol\\";\\nimport \\"./profiles/DNSResolver.sol\\";\\nimport \\"./profiles/InterfaceResolver.sol\\";\\nimport \\"./profiles/NameResolver.sol\\";\\nimport \\"./profiles/PubkeyResolver.sol\\";\\nimport \\"./profiles/TextResolver.sol\\";\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\\n    ENS ens;\\n\\n    /**\\n     * A mapping of authorisations. An address that is authorised for a name\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (node, owner, caller) => isAuthorised\\n     */\\n    mapping(bytes32=>mapping(address=>mapping(address=>bool))) public authorisations;\\n\\n    event AuthorisationChanged(bytes32 indexed node, address indexed owner, address indexed target, bool isAuthorised);\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n    }\\n\\n    /**\\n     * @dev Sets or clears an authorisation.\\n     * Authorisations are specific to the caller. Any account can set an authorisation\\n     * for any name, but the authorisation that is checked will be that of the\\n     * current owner of a name. Thus, transferring a name effectively clears any\\n     * existing authorisations, and new authorisations can be set in advance of\\n     * an ownership transfer if desired.\\n     *\\n     * @param node The name to change the authorisation on.\\n     * @param target The address that is to be authorised or deauthorised.\\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\\n     */\\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external {\\n        authorisations[node][msg.sender][target] = isAuthorised;\\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\\n    }\\n\\n    function isAuthorised(bytes32 node) internal view returns(bool) {\\n        address owner = ens.owner(node);\\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\\n    }\\n\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for(uint i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            require(success);\\n            results[i] = result;\\n        }\\n        return results;\\n    }\\n}\\n","sourcePath":"/home/user/Dropbox/projects/resolvers/contracts/PublicResolver.sol","ast":{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/PublicResolver.sol","exportedSymbols":{"PublicResolver":[353]},"id":354,"nodeType":"SourceUnit","nodes":[{"id":181,"literals":["solidity","^","0.5",".0"],"nodeType":"PragmaDirective","src":"0:23:3"},{"id":182,"literals":["experimental","ABIEncoderV2"],"nodeType":"PragmaDirective","src":"24:33:3"},{"absolutePath":"@ensdomains/ens/contracts/ENS.sol","file":"@ensdomains/ens/contracts/ENS.sol","id":183,"nodeType":"ImportDirective","scope":354,"sourceUnit":3783,"src":"59:43:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/ABIResolver.sol","file":"./profiles/ABIResolver.sol","id":184,"nodeType":"ImportDirective","scope":354,"sourceUnit":799,"src":"103:36:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/AddrResolver.sol","file":"./profiles/AddrResolver.sol","id":185,"nodeType":"ImportDirective","scope":354,"sourceUnit":958,"src":"140:37:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/ContentHashResolver.sol","file":"./profiles/ContentHashResolver.sol","id":186,"nodeType":"ImportDirective","scope":354,"sourceUnit":1028,"src":"178:44:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/DNSResolver.sol","file":"./profiles/DNSResolver.sol","id":187,"nodeType":"ImportDirective","scope":354,"sourceUnit":1459,"src":"223:36:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/InterfaceResolver.sol","file":"./profiles/InterfaceResolver.sol","id":188,"nodeType":"ImportDirective","scope":354,"sourceUnit":1646,"src":"260:42:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/NameResolver.sol","file":"./profiles/NameResolver.sol","id":189,"nodeType":"ImportDirective","scope":354,"sourceUnit":1716,"src":"303:37:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/PubkeyResolver.sol","file":"./profiles/PubkeyResolver.sol","id":190,"nodeType":"ImportDirective","scope":354,"sourceUnit":1807,"src":"341:39:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/TextResolver.sol","file":"./profiles/TextResolver.sol","id":191,"nodeType":"ImportDirective","scope":354,"sourceUnit":1890,"src":"381:37:3","symbolAliases":[],"unitAlias":""},{"baseContracts":[{"arguments":null,"baseName":{"contractScope":null,"id":192,"name":"ABIResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":798,"src":"547:11:3","typeDescriptions":{"typeIdentifier":"t_contract$_ABIResolver_$798","typeString":"contract ABIResolver"}},"id":193,"nodeType":"InheritanceSpecifier","src":"547:11:3"},{"arguments":null,"baseName":{"contractScope":null,"id":194,"name":"AddrResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":957,"src":"560:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_AddrResolver_$957","typeString":"contract AddrResolver"}},"id":195,"nodeType":"InheritanceSpecifier","src":"560:12:3"},{"arguments":null,"baseName":{"contractScope":null,"id":196,"name":"ContentHashResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1027,"src":"574:19:3","typeDescriptions":{"typeIdentifier":"t_contract$_ContentHashResolver_$1027","typeString":"contract ContentHashResolver"}},"id":197,"nodeType":"InheritanceSpecifier","src":"574:19:3"},{"arguments":null,"baseName":{"contractScope":null,"id":198,"name":"DNSResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1458,"src":"595:11:3","typeDescriptions":{"typeIdentifier":"t_contract$_DNSResolver_$1458","typeString":"contract DNSResolver"}},"id":199,"nodeType":"InheritanceSpecifier","src":"595:11:3"},{"arguments":null,"baseName":{"contractScope":null,"id":200,"name":"InterfaceResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1645,"src":"608:17:3","typeDescriptions":{"typeIdentifier":"t_contract$_InterfaceResolver_$1645","typeString":"contract InterfaceResolver"}},"id":201,"nodeType":"InheritanceSpecifier","src":"608:17:3"},{"arguments":null,"baseName":{"contractScope":null,"id":202,"name":"NameResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1715,"src":"627:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_NameResolver_$1715","typeString":"contract NameResolver"}},"id":203,"nodeType":"InheritanceSpecifier","src":"627:12:3"},{"arguments":null,"baseName":{"contractScope":null,"id":204,"name":"PubkeyResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1806,"src":"641:14:3","typeDescriptions":{"typeIdentifier":"t_contract$_PubkeyResolver_$1806","typeString":"contract PubkeyResolver"}},"id":205,"nodeType":"InheritanceSpecifier","src":"641:14:3"},{"arguments":null,"baseName":{"contractScope":null,"id":206,"name":"TextResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1889,"src":"657:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_TextResolver_$1889","typeString":"contract TextResolver"}},"id":207,"nodeType":"InheritanceSpecifier","src":"657:12:3"}],"contractDependencies":[662,798,957,1027,1458,1645,1715,1806,1889],"contractKind":"contract","documentation":"A simple resolver anyone can use; only allows the owner of a node to set its\\naddress.","fullyImplemented":true,"id":353,"linearizedBaseContracts":[353,1889,1806,1715,1645,1458,1027,957,798,662],"name":"PublicResolver","nodeType":"ContractDefinition","nodes":[{"constant":false,"id":209,"name":"ens","nodeType":"VariableDeclaration","scope":353,"src":"676:7:3","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":208,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":3782,"src":"676:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"value":null,"visibility":"internal"},{"constant":false,"id":217,"name":"authorisations","nodeType":"VariableDeclaration","scope":353,"src":"943:80:3","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"},"typeName":{"id":216,"keyType":{"id":210,"name":"bytes32","nodeType":"ElementaryTypeName","src":"951:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Mapping","src":"943:58:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"},"valueType":{"id":215,"keyType":{"id":211,"name":"address","nodeType":"ElementaryTypeName","src":"968:7:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"960:40:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"},"valueType":{"id":214,"keyType":{"id":212,"name":"address","nodeType":"ElementaryTypeName","src":"985:7:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"977:22:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"},"valueType":{"id":213,"name":"bool","nodeType":"ElementaryTypeName","src":"994:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}}}},"value":null,"visibility":"public"},{"anonymous":false,"documentation":null,"id":227,"name":"AuthorisationChanged","nodeType":"EventDefinition","parameters":{"id":226,"nodeType":"ParameterList","parameters":[{"constant":false,"id":219,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":227,"src":"1057:20:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":218,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1057:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":221,"indexed":true,"name":"owner","nodeType":"VariableDeclaration","scope":227,"src":"1079:21:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":220,"name":"address","nodeType":"ElementaryTypeName","src":"1079:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":223,"indexed":true,"name":"target","nodeType":"VariableDeclaration","scope":227,"src":"1102:22:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":222,"name":"address","nodeType":"ElementaryTypeName","src":"1102:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":225,"indexed":false,"name":"isAuthorised","nodeType":"VariableDeclaration","scope":227,"src":"1126:17:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":224,"name":"bool","nodeType":"ElementaryTypeName","src":"1126:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1056:88:3"},"src":"1030:115:3"},{"body":{"id":236,"nodeType":"Block","src":"1180:27:3","statements":[{"expression":{"argumentTypes":null,"id":234,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":232,"name":"ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":209,"src":"1190:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":233,"name":"_ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":229,"src":"1196:4:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"src":"1190:10:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"id":235,"nodeType":"ExpressionStatement","src":"1190:10:3"}]},"documentation":null,"id":237,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nodeType":"FunctionDefinition","parameters":{"id":230,"nodeType":"ParameterList","parameters":[{"constant":false,"id":229,"name":"_ens","nodeType":"VariableDeclaration","scope":237,"src":"1163:8:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":228,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":3782,"src":"1163:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"value":null,"visibility":"internal"}],"src":"1162:10:3"},"returnParameters":{"id":231,"nodeType":"ParameterList","parameters":[],"src":"1180:0:3"},"scope":353,"src":"1151:56:3","stateMutability":"nonpayable","superFunction":null,"visibility":"public"},{"body":{"id":265,"nodeType":"Block","src":"1976:147:3","statements":[{"expression":{"argumentTypes":null,"id":255,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":246,"name":"authorisations","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":217,"src":"1986:14:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"}},"id":251,"indexExpression":{"argumentTypes":null,"id":247,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":239,"src":"2001:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1986:20:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":252,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":248,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2007:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":249,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2007:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1986:32:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":253,"indexExpression":{"argumentTypes":null,"id":250,"name":"target","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":241,"src":"2019:6:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1986:40:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":254,"name":"isAuthorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":243,"src":"2029:12:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"1986:55:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":256,"nodeType":"ExpressionStatement","src":"1986:55:3"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":258,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":239,"src":"2077:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"expression":{"argumentTypes":null,"id":259,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2083:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":260,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2083:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},{"argumentTypes":null,"id":261,"name":"target","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":241,"src":"2095:6:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"argumentTypes":null,"id":262,"name":"isAuthorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":243,"src":"2103:12:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address_payable","typeString":"address payable"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bool","typeString":"bool"}],"id":257,"name":"AuthorisationChanged","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":227,"src":"2056:20:3","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_address_$_t_address_$_t_bool_$returns$__$","typeString":"function (bytes32,address,address,bool)"}},"id":263,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2056:60:3","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":264,"nodeType":"EmitStatement","src":"2051:65:3"}]},"documentation":"@dev Sets or clears an authorisation.\\nAuthorisations are specific to the caller. Any account can set an authorisation\\nfor any name, but the authorisation that is checked will be that of the\\ncurrent owner of a name. Thus, transferring a name effectively clears any\\nexisting authorisations, and new authorisations can be set in advance of\\nan ownership transfer if desired.\\n     * @param node The name to change the authorisation on.\\n@param target The address that is to be authorised or deauthorised.\\n@param isAuthorised True if the address should be authorised, or false if it should be deauthorised.","id":266,"implemented":true,"kind":"function","modifiers":[],"name":"setAuthorisation","nodeType":"FunctionDefinition","parameters":{"id":244,"nodeType":"ParameterList","parameters":[{"constant":false,"id":239,"name":"node","nodeType":"VariableDeclaration","scope":266,"src":"1918:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":238,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1918:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":241,"name":"target","nodeType":"VariableDeclaration","scope":266,"src":"1932:14:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":240,"name":"address","nodeType":"ElementaryTypeName","src":"1932:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":243,"name":"isAuthorised","nodeType":"VariableDeclaration","scope":266,"src":"1948:17:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":242,"name":"bool","nodeType":"ElementaryTypeName","src":"1948:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1917:49:3"},"returnParameters":{"id":245,"nodeType":"ParameterList","parameters":[],"src":"1976:0:3"},"scope":353,"src":"1892:231:3","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":{"id":294,"nodeType":"Block","src":"2193:127:3","statements":[{"assignments":[274],"declarations":[{"constant":false,"id":274,"name":"owner","nodeType":"VariableDeclaration","scope":294,"src":"2203:13:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":273,"name":"address","nodeType":"ElementaryTypeName","src":"2203:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"id":279,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":277,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":268,"src":"2229:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":275,"name":"ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":209,"src":"2219:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"id":276,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":3767,"src":"2219:9:3","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view external returns (address)"}},"id":278,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2219:15:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"2203:31:3"},{"expression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":292,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":283,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":280,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":274,"src":"2251:5:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":281,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2260:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":282,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2260:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"2251:19:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":284,"name":"authorisations","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":217,"src":"2274:14:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"}},"id":286,"indexExpression":{"argumentTypes":null,"id":285,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":268,"src":"2289:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:20:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":288,"indexExpression":{"argumentTypes":null,"id":287,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":274,"src":"2295:5:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:27:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":291,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":289,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2302:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":290,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2302:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:39:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"2251:62:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":272,"id":293,"nodeType":"Return","src":"2244:69:3"}]},"documentation":null,"id":295,"implemented":true,"kind":"function","modifiers":[],"name":"isAuthorised","nodeType":"FunctionDefinition","parameters":{"id":269,"nodeType":"ParameterList","parameters":[{"constant":false,"id":268,"name":"node","nodeType":"VariableDeclaration","scope":295,"src":"2151:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":267,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2151:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"2150:14:3"},"returnParameters":{"id":272,"nodeType":"ParameterList","parameters":[{"constant":false,"id":271,"name":"","nodeType":"VariableDeclaration","scope":295,"src":"2187:4:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":270,"name":"bool","nodeType":"ElementaryTypeName","src":"2187:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"2186:6:3"},"scope":353,"src":"2129:191:3","stateMutability":"view","superFunction":617,"visibility":"internal"},{"body":{"id":351,"nodeType":"Block","src":"2409:283:3","statements":[{"expression":{"argumentTypes":null,"id":311,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":304,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2419:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"expression":{"argumentTypes":null,"id":308,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2441:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":309,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"length","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2441:11:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":307,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"2429:11:3","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes_memory_$dyn_memory_$","typeString":"function (uint256) pure returns (bytes memory[] memory)"},"typeName":{"baseType":{"id":305,"name":"bytes","nodeType":"ElementaryTypeName","src":"2433:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":306,"length":null,"nodeType":"ArrayTypeName","src":"2433:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}}},"id":310,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2429:24:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory","typeString":"bytes memory[] memory"}},"src":"2419:34:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"id":312,"nodeType":"ExpressionStatement","src":"2419:34:3"},{"body":{"id":347,"nodeType":"Block","src":"2501:161:3","statements":[{"assignments":[325,327],"declarations":[{"constant":false,"id":325,"name":"success","nodeType":"VariableDeclaration","scope":347,"src":"2516:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":324,"name":"bool","nodeType":"ElementaryTypeName","src":"2516:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"},{"constant":false,"id":327,"name":"result","nodeType":"VariableDeclaration","scope":347,"src":"2530:19:3","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":326,"name":"bytes","nodeType":"ElementaryTypeName","src":"2530:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"value":null,"visibility":"internal"}],"id":336,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":332,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2580:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":334,"indexExpression":{"argumentTypes":null,"id":333,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2585:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2580:7:3","typeDescriptions":{"typeIdentifier":"t_bytes_calldata","typeString":"bytes calldata"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_calldata","typeString":"bytes calldata"}],"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":329,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4185,"src":"2561:4:3","typeDescriptions":{"typeIdentifier":"t_contract$_PublicResolver_$353","typeString":"contract PublicResolver"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_PublicResolver_$353","typeString":"contract PublicResolver"}],"id":328,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2553:7:3","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":330,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2553:13:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":331,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"delegatecall","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2553:26:3","typeDescriptions":{"typeIdentifier":"t_function_baredelegatecall_nonpayable$_t_bytes_memory_ptr_$returns$_t_bool_$_t_bytes_memory_ptr_$","typeString":"function (bytes memory) returns (bool,bytes memory)"}},"id":335,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2553:35:3","typeDescriptions":{"typeIdentifier":"t_tuple$_t_bool_$_t_bytes_memory_ptr_$","typeString":"tuple(bool,bytes memory)"}},"nodeType":"VariableDeclarationStatement","src":"2515:73:3"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":338,"name":"success","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":325,"src":"2610:7:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"}],"id":337,"name":"require","nodeType":"Identifier","overloadedDeclarations":[4136,4137],"referencedDeclaration":4136,"src":"2602:7:3","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$returns$__$","typeString":"function (bool) pure"}},"id":339,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2602:16:3","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":340,"nodeType":"ExpressionStatement","src":"2602:16:3"},{"expression":{"argumentTypes":null,"id":345,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":341,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2632:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"id":343,"indexExpression":{"argumentTypes":null,"id":342,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2640:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"2632:10:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory","typeString":"bytes memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":344,"name":"result","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":327,"src":"2645:6:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"src":"2632:19:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory","typeString":"bytes memory"}},"id":346,"nodeType":"ExpressionStatement","src":"2632:19:3"}]},"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":320,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":317,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2479:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":318,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2483:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":319,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"length","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2483:11:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"2479:15:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":348,"initializationExpression":{"assignments":[314],"declarations":[{"constant":false,"id":314,"name":"i","nodeType":"VariableDeclaration","scope":348,"src":"2467:6:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":313,"name":"uint","nodeType":"ElementaryTypeName","src":"2467:4:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"value":null,"visibility":"internal"}],"id":316,"initialValue":{"argumentTypes":null,"hexValue":"30","id":315,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2476:1:3","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"2467:10:3"},"loopExpression":{"expression":{"argumentTypes":null,"id":322,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"2496:3:3","subExpression":{"argumentTypes":null,"id":321,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2496:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":323,"nodeType":"ExpressionStatement","src":"2496:3:3"},"nodeType":"ForStatement","src":"2463:199:3"},{"expression":{"argumentTypes":null,"id":349,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2678:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"functionReturnParameters":303,"id":350,"nodeType":"Return","src":"2671:14:3"}]},"documentation":null,"id":352,"implemented":true,"kind":"function","modifiers":[],"name":"multicall","nodeType":"FunctionDefinition","parameters":{"id":299,"nodeType":"ParameterList","parameters":[{"constant":false,"id":298,"name":"data","nodeType":"VariableDeclaration","scope":352,"src":"2345:21:3","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":296,"name":"bytes","nodeType":"ElementaryTypeName","src":"2345:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":297,"length":null,"nodeType":"ArrayTypeName","src":"2345:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"value":null,"visibility":"internal"}],"src":"2344:23:3"},"returnParameters":{"id":303,"nodeType":"ParameterList","parameters":[{"constant":false,"id":302,"name":"results","nodeType":"VariableDeclaration","scope":352,"src":"2385:22:3","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":300,"name":"bytes","nodeType":"ElementaryTypeName","src":"2385:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":301,"length":null,"nodeType":"ArrayTypeName","src":"2385:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"value":null,"visibility":"internal"}],"src":"2384:24:3"},"scope":353,"src":"2326:366:3","stateMutability":"nonpayable","superFunction":null,"visibility":"external"}],"scope":354,"src":"520:2174:3"}],"src":"0:2695:3"},"legacyAST":{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/PublicResolver.sol","exportedSymbols":{"PublicResolver":[353]},"id":354,"nodeType":"SourceUnit","nodes":[{"id":181,"literals":["solidity","^","0.5",".0"],"nodeType":"PragmaDirective","src":"0:23:3"},{"id":182,"literals":["experimental","ABIEncoderV2"],"nodeType":"PragmaDirective","src":"24:33:3"},{"absolutePath":"@ensdomains/ens/contracts/ENS.sol","file":"@ensdomains/ens/contracts/ENS.sol","id":183,"nodeType":"ImportDirective","scope":354,"sourceUnit":3783,"src":"59:43:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/ABIResolver.sol","file":"./profiles/ABIResolver.sol","id":184,"nodeType":"ImportDirective","scope":354,"sourceUnit":799,"src":"103:36:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/AddrResolver.sol","file":"./profiles/AddrResolver.sol","id":185,"nodeType":"ImportDirective","scope":354,"sourceUnit":958,"src":"140:37:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/ContentHashResolver.sol","file":"./profiles/ContentHashResolver.sol","id":186,"nodeType":"ImportDirective","scope":354,"sourceUnit":1028,"src":"178:44:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/DNSResolver.sol","file":"./profiles/DNSResolver.sol","id":187,"nodeType":"ImportDirective","scope":354,"sourceUnit":1459,"src":"223:36:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/InterfaceResolver.sol","file":"./profiles/InterfaceResolver.sol","id":188,"nodeType":"ImportDirective","scope":354,"sourceUnit":1646,"src":"260:42:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/NameResolver.sol","file":"./profiles/NameResolver.sol","id":189,"nodeType":"ImportDirective","scope":354,"sourceUnit":1716,"src":"303:37:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/PubkeyResolver.sol","file":"./profiles/PubkeyResolver.sol","id":190,"nodeType":"ImportDirective","scope":354,"sourceUnit":1807,"src":"341:39:3","symbolAliases":[],"unitAlias":""},{"absolutePath":"/home/user/Dropbox/projects/resolvers/contracts/profiles/TextResolver.sol","file":"./profiles/TextResolver.sol","id":191,"nodeType":"ImportDirective","scope":354,"sourceUnit":1890,"src":"381:37:3","symbolAliases":[],"unitAlias":""},{"baseContracts":[{"arguments":null,"baseName":{"contractScope":null,"id":192,"name":"ABIResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":798,"src":"547:11:3","typeDescriptions":{"typeIdentifier":"t_contract$_ABIResolver_$798","typeString":"contract ABIResolver"}},"id":193,"nodeType":"InheritanceSpecifier","src":"547:11:3"},{"arguments":null,"baseName":{"contractScope":null,"id":194,"name":"AddrResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":957,"src":"560:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_AddrResolver_$957","typeString":"contract AddrResolver"}},"id":195,"nodeType":"InheritanceSpecifier","src":"560:12:3"},{"arguments":null,"baseName":{"contractScope":null,"id":196,"name":"ContentHashResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1027,"src":"574:19:3","typeDescriptions":{"typeIdentifier":"t_contract$_ContentHashResolver_$1027","typeString":"contract ContentHashResolver"}},"id":197,"nodeType":"InheritanceSpecifier","src":"574:19:3"},{"arguments":null,"baseName":{"contractScope":null,"id":198,"name":"DNSResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1458,"src":"595:11:3","typeDescriptions":{"typeIdentifier":"t_contract$_DNSResolver_$1458","typeString":"contract DNSResolver"}},"id":199,"nodeType":"InheritanceSpecifier","src":"595:11:3"},{"arguments":null,"baseName":{"contractScope":null,"id":200,"name":"InterfaceResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1645,"src":"608:17:3","typeDescriptions":{"typeIdentifier":"t_contract$_InterfaceResolver_$1645","typeString":"contract InterfaceResolver"}},"id":201,"nodeType":"InheritanceSpecifier","src":"608:17:3"},{"arguments":null,"baseName":{"contractScope":null,"id":202,"name":"NameResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1715,"src":"627:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_NameResolver_$1715","typeString":"contract NameResolver"}},"id":203,"nodeType":"InheritanceSpecifier","src":"627:12:3"},{"arguments":null,"baseName":{"contractScope":null,"id":204,"name":"PubkeyResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1806,"src":"641:14:3","typeDescriptions":{"typeIdentifier":"t_contract$_PubkeyResolver_$1806","typeString":"contract PubkeyResolver"}},"id":205,"nodeType":"InheritanceSpecifier","src":"641:14:3"},{"arguments":null,"baseName":{"contractScope":null,"id":206,"name":"TextResolver","nodeType":"UserDefinedTypeName","referencedDeclaration":1889,"src":"657:12:3","typeDescriptions":{"typeIdentifier":"t_contract$_TextResolver_$1889","typeString":"contract TextResolver"}},"id":207,"nodeType":"InheritanceSpecifier","src":"657:12:3"}],"contractDependencies":[662,798,957,1027,1458,1645,1715,1806,1889],"contractKind":"contract","documentation":"A simple resolver anyone can use; only allows the owner of a node to set its\\naddress.","fullyImplemented":true,"id":353,"linearizedBaseContracts":[353,1889,1806,1715,1645,1458,1027,957,798,662],"name":"PublicResolver","nodeType":"ContractDefinition","nodes":[{"constant":false,"id":209,"name":"ens","nodeType":"VariableDeclaration","scope":353,"src":"676:7:3","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":208,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":3782,"src":"676:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"value":null,"visibility":"internal"},{"constant":false,"id":217,"name":"authorisations","nodeType":"VariableDeclaration","scope":353,"src":"943:80:3","stateVariable":true,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"},"typeName":{"id":216,"keyType":{"id":210,"name":"bytes32","nodeType":"ElementaryTypeName","src":"951:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"Mapping","src":"943:58:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"},"valueType":{"id":215,"keyType":{"id":211,"name":"address","nodeType":"ElementaryTypeName","src":"968:7:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"960:40:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"},"valueType":{"id":214,"keyType":{"id":212,"name":"address","nodeType":"ElementaryTypeName","src":"985:7:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"Mapping","src":"977:22:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"},"valueType":{"id":213,"name":"bool","nodeType":"ElementaryTypeName","src":"994:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}}}},"value":null,"visibility":"public"},{"anonymous":false,"documentation":null,"id":227,"name":"AuthorisationChanged","nodeType":"EventDefinition","parameters":{"id":226,"nodeType":"ParameterList","parameters":[{"constant":false,"id":219,"indexed":true,"name":"node","nodeType":"VariableDeclaration","scope":227,"src":"1057:20:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":218,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1057:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":221,"indexed":true,"name":"owner","nodeType":"VariableDeclaration","scope":227,"src":"1079:21:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":220,"name":"address","nodeType":"ElementaryTypeName","src":"1079:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":223,"indexed":true,"name":"target","nodeType":"VariableDeclaration","scope":227,"src":"1102:22:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":222,"name":"address","nodeType":"ElementaryTypeName","src":"1102:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":225,"indexed":false,"name":"isAuthorised","nodeType":"VariableDeclaration","scope":227,"src":"1126:17:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":224,"name":"bool","nodeType":"ElementaryTypeName","src":"1126:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1056:88:3"},"src":"1030:115:3"},{"body":{"id":236,"nodeType":"Block","src":"1180:27:3","statements":[{"expression":{"argumentTypes":null,"id":234,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":232,"name":"ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":209,"src":"1190:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":233,"name":"_ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":229,"src":"1196:4:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"src":"1190:10:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"id":235,"nodeType":"ExpressionStatement","src":"1190:10:3"}]},"documentation":null,"id":237,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nodeType":"FunctionDefinition","parameters":{"id":230,"nodeType":"ParameterList","parameters":[{"constant":false,"id":229,"name":"_ens","nodeType":"VariableDeclaration","scope":237,"src":"1163:8:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"},"typeName":{"contractScope":null,"id":228,"name":"ENS","nodeType":"UserDefinedTypeName","referencedDeclaration":3782,"src":"1163:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"value":null,"visibility":"internal"}],"src":"1162:10:3"},"returnParameters":{"id":231,"nodeType":"ParameterList","parameters":[],"src":"1180:0:3"},"scope":353,"src":"1151:56:3","stateMutability":"nonpayable","superFunction":null,"visibility":"public"},{"body":{"id":265,"nodeType":"Block","src":"1976:147:3","statements":[{"expression":{"argumentTypes":null,"id":255,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":246,"name":"authorisations","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":217,"src":"1986:14:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"}},"id":251,"indexExpression":{"argumentTypes":null,"id":247,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":239,"src":"2001:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1986:20:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":252,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":248,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2007:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":249,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2007:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"1986:32:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":253,"indexExpression":{"argumentTypes":null,"id":250,"name":"target","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":241,"src":"2019:6:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"1986:40:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":254,"name":"isAuthorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":243,"src":"2029:12:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"1986:55:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":256,"nodeType":"ExpressionStatement","src":"1986:55:3"},{"eventCall":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":258,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":239,"src":"2077:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"argumentTypes":null,"expression":{"argumentTypes":null,"id":259,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2083:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":260,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2083:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},{"argumentTypes":null,"id":261,"name":"target","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":241,"src":"2095:6:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"argumentTypes":null,"id":262,"name":"isAuthorised","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":243,"src":"2103:12:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address_payable","typeString":"address payable"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bool","typeString":"bool"}],"id":257,"name":"AuthorisationChanged","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":227,"src":"2056:20:3","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_bytes32_$_t_address_$_t_address_$_t_bool_$returns$__$","typeString":"function (bytes32,address,address,bool)"}},"id":263,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2056:60:3","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":264,"nodeType":"EmitStatement","src":"2051:65:3"}]},"documentation":"@dev Sets or clears an authorisation.\\nAuthorisations are specific to the caller. Any account can set an authorisation\\nfor any name, but the authorisation that is checked will be that of the\\ncurrent owner of a name. Thus, transferring a name effectively clears any\\nexisting authorisations, and new authorisations can be set in advance of\\nan ownership transfer if desired.\\n     * @param node The name to change the authorisation on.\\n@param target The address that is to be authorised or deauthorised.\\n@param isAuthorised True if the address should be authorised, or false if it should be deauthorised.","id":266,"implemented":true,"kind":"function","modifiers":[],"name":"setAuthorisation","nodeType":"FunctionDefinition","parameters":{"id":244,"nodeType":"ParameterList","parameters":[{"constant":false,"id":239,"name":"node","nodeType":"VariableDeclaration","scope":266,"src":"1918:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":238,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1918:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"},{"constant":false,"id":241,"name":"target","nodeType":"VariableDeclaration","scope":266,"src":"1932:14:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":240,"name":"address","nodeType":"ElementaryTypeName","src":"1932:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"},{"constant":false,"id":243,"name":"isAuthorised","nodeType":"VariableDeclaration","scope":266,"src":"1948:17:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":242,"name":"bool","nodeType":"ElementaryTypeName","src":"1948:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"1917:49:3"},"returnParameters":{"id":245,"nodeType":"ParameterList","parameters":[],"src":"1976:0:3"},"scope":353,"src":"1892:231:3","stateMutability":"nonpayable","superFunction":null,"visibility":"external"},{"body":{"id":294,"nodeType":"Block","src":"2193:127:3","statements":[{"assignments":[274],"declarations":[{"constant":false,"id":274,"name":"owner","nodeType":"VariableDeclaration","scope":294,"src":"2203:13:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":273,"name":"address","nodeType":"ElementaryTypeName","src":"2203:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"value":null,"visibility":"internal"}],"id":279,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":277,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":268,"src":"2229:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"expression":{"argumentTypes":null,"id":275,"name":"ens","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":209,"src":"2219:3:3","typeDescriptions":{"typeIdentifier":"t_contract$_ENS_$3782","typeString":"contract ENS"}},"id":276,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"owner","nodeType":"MemberAccess","referencedDeclaration":3767,"src":"2219:9:3","typeDescriptions":{"typeIdentifier":"t_function_external_view$_t_bytes32_$returns$_t_address_$","typeString":"function (bytes32) view external returns (address)"}},"id":278,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2219:15:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"2203:31:3"},{"expression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":292,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":283,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":280,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":274,"src":"2251:5:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":281,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2260:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":282,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2260:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"src":"2251:19:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":284,"name":"authorisations","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":217,"src":"2274:14:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_bytes32_$_t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$_$","typeString":"mapping(bytes32 => mapping(address => mapping(address => bool)))"}},"id":286,"indexExpression":{"argumentTypes":null,"id":285,"name":"node","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":268,"src":"2289:4:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:20:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_mapping$_t_address_$_t_bool_$_$","typeString":"mapping(address => mapping(address => bool))"}},"id":288,"indexExpression":{"argumentTypes":null,"id":287,"name":"owner","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":274,"src":"2295:5:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:27:3","typeDescriptions":{"typeIdentifier":"t_mapping$_t_address_$_t_bool_$","typeString":"mapping(address => bool)"}},"id":291,"indexExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":289,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4133,"src":"2302:3:3","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":290,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"sender","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2302:10:3","typeDescriptions":{"typeIdentifier":"t_address_payable","typeString":"address payable"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2274:39:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"2251:62:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":272,"id":293,"nodeType":"Return","src":"2244:69:3"}]},"documentation":null,"id":295,"implemented":true,"kind":"function","modifiers":[],"name":"isAuthorised","nodeType":"FunctionDefinition","parameters":{"id":269,"nodeType":"ParameterList","parameters":[{"constant":false,"id":268,"name":"node","nodeType":"VariableDeclaration","scope":295,"src":"2151:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":267,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2151:7:3","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":null,"visibility":"internal"}],"src":"2150:14:3"},"returnParameters":{"id":272,"nodeType":"ParameterList","parameters":[{"constant":false,"id":271,"name":"","nodeType":"VariableDeclaration","scope":295,"src":"2187:4:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":270,"name":"bool","nodeType":"ElementaryTypeName","src":"2187:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"}],"src":"2186:6:3"},"scope":353,"src":"2129:191:3","stateMutability":"view","superFunction":617,"visibility":"internal"},{"body":{"id":351,"nodeType":"Block","src":"2409:283:3","statements":[{"expression":{"argumentTypes":null,"id":311,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"id":304,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2419:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"expression":{"argumentTypes":null,"id":308,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2441:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":309,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"length","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2441:11:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint256","typeString":"uint256"}],"id":307,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"2429:11:3","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes_memory_$dyn_memory_$","typeString":"function (uint256) pure returns (bytes memory[] memory)"},"typeName":{"baseType":{"id":305,"name":"bytes","nodeType":"ElementaryTypeName","src":"2433:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":306,"length":null,"nodeType":"ArrayTypeName","src":"2433:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}}},"id":310,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2429:24:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory","typeString":"bytes memory[] memory"}},"src":"2419:34:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"id":312,"nodeType":"ExpressionStatement","src":"2419:34:3"},{"body":{"id":347,"nodeType":"Block","src":"2501:161:3","statements":[{"assignments":[325,327],"declarations":[{"constant":false,"id":325,"name":"success","nodeType":"VariableDeclaration","scope":347,"src":"2516:12:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":324,"name":"bool","nodeType":"ElementaryTypeName","src":"2516:4:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"value":null,"visibility":"internal"},{"constant":false,"id":327,"name":"result","nodeType":"VariableDeclaration","scope":347,"src":"2530:19:3","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":326,"name":"bytes","nodeType":"ElementaryTypeName","src":"2530:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"value":null,"visibility":"internal"}],"id":336,"initialValue":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":332,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2580:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":334,"indexExpression":{"argumentTypes":null,"id":333,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2585:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"IndexAccess","src":"2580:7:3","typeDescriptions":{"typeIdentifier":"t_bytes_calldata","typeString":"bytes calldata"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_calldata","typeString":"bytes calldata"}],"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":329,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4185,"src":"2561:4:3","typeDescriptions":{"typeIdentifier":"t_contract$_PublicResolver_$353","typeString":"contract PublicResolver"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_PublicResolver_$353","typeString":"contract PublicResolver"}],"id":328,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2553:7:3","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":"address"},"id":330,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2553:13:3","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":331,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"delegatecall","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2553:26:3","typeDescriptions":{"typeIdentifier":"t_function_baredelegatecall_nonpayable$_t_bytes_memory_ptr_$returns$_t_bool_$_t_bytes_memory_ptr_$","typeString":"function (bytes memory) returns (bool,bytes memory)"}},"id":335,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2553:35:3","typeDescriptions":{"typeIdentifier":"t_tuple$_t_bool_$_t_bytes_memory_ptr_$","typeString":"tuple(bool,bytes memory)"}},"nodeType":"VariableDeclarationStatement","src":"2515:73:3"},{"expression":{"argumentTypes":null,"arguments":[{"argumentTypes":null,"id":338,"name":"success","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":325,"src":"2610:7:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"}],"id":337,"name":"require","nodeType":"Identifier","overloadedDeclarations":[4136,4137],"referencedDeclaration":4136,"src":"2602:7:3","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$returns$__$","typeString":"function (bool) pure"}},"id":339,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"names":[],"nodeType":"FunctionCall","src":"2602:16:3","typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":340,"nodeType":"ExpressionStatement","src":"2602:16:3"},{"expression":{"argumentTypes":null,"id":345,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftHandSide":{"argumentTypes":null,"baseExpression":{"argumentTypes":null,"id":341,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2632:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"id":343,"indexExpression":{"argumentTypes":null,"id":342,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2640:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":true,"nodeType":"IndexAccess","src":"2632:10:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory","typeString":"bytes memory"}},"nodeType":"Assignment","operator":"=","rightHandSide":{"argumentTypes":null,"id":344,"name":"result","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":327,"src":"2645:6:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"src":"2632:19:3","typeDescriptions":{"typeIdentifier":"t_bytes_memory","typeString":"bytes memory"}},"id":346,"nodeType":"ExpressionStatement","src":"2632:19:3"}]},"condition":{"argumentTypes":null,"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":320,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"argumentTypes":null,"id":317,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2479:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"argumentTypes":null,"expression":{"argumentTypes":null,"id":318,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":298,"src":"2483:4:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes calldata[] calldata"}},"id":319,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberName":"length","nodeType":"MemberAccess","referencedDeclaration":null,"src":"2483:11:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"src":"2479:15:3","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":348,"initializationExpression":{"assignments":[314],"declarations":[{"constant":false,"id":314,"name":"i","nodeType":"VariableDeclaration","scope":348,"src":"2467:6:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":313,"name":"uint","nodeType":"ElementaryTypeName","src":"2467:4:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"value":null,"visibility":"internal"}],"id":316,"initialValue":{"argumentTypes":null,"hexValue":"30","id":315,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2476:1:3","subdenomination":null,"typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"},"nodeType":"VariableDeclarationStatement","src":"2467:10:3"},"loopExpression":{"expression":{"argumentTypes":null,"id":322,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"++","prefix":false,"src":"2496:3:3","subExpression":{"argumentTypes":null,"id":321,"name":"i","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":314,"src":"2496:1:3","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":323,"nodeType":"ExpressionStatement","src":"2496:3:3"},"nodeType":"ForStatement","src":"2463:199:3"},{"expression":{"argumentTypes":null,"id":349,"name":"results","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":302,"src":"2678:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},"functionReturnParameters":303,"id":350,"nodeType":"Return","src":"2671:14:3"}]},"documentation":null,"id":352,"implemented":true,"kind":"function","modifiers":[],"name":"multicall","nodeType":"FunctionDefinition","parameters":{"id":299,"nodeType":"ParameterList","parameters":[{"constant":false,"id":298,"name":"data","nodeType":"VariableDeclaration","scope":352,"src":"2345:21:3","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_$dyn_calldata_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":296,"name":"bytes","nodeType":"ElementaryTypeName","src":"2345:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":297,"length":null,"nodeType":"ArrayTypeName","src":"2345:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"value":null,"visibility":"internal"}],"src":"2344:23:3"},"returnParameters":{"id":303,"nodeType":"ParameterList","parameters":[{"constant":false,"id":302,"name":"results","nodeType":"VariableDeclaration","scope":352,"src":"2385:22:3","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":300,"name":"bytes","nodeType":"ElementaryTypeName","src":"2385:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":301,"length":null,"nodeType":"ArrayTypeName","src":"2385:7:3","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"value":null,"visibility":"internal"}],"src":"2384:24:3"},"scope":353,"src":"2326:366:3","stateMutability":"nonpayable","superFunction":null,"visibility":"external"}],"scope":354,"src":"520:2174:3"}],"src":"0:2695:3"},"compiler":{"name":"solc","version":"0.5.8+commit.23d335f2.Emscripten.clang"},"networks":{},"schemaVersion":"3.0.16","updatedAt":"2020-02-10T18:46:21.022Z","devdoc":{"methods":{"ABI(bytes32,uint256)":{"params":{"contentTypes":"A bitwise OR of the ABI formats accepted by the caller.","node":"The ENS node to query"},"return":"contentType The content type of the return valuedata The ABI data"},"addr(bytes32)":{"params":{"node":"The ENS node to query."},"return":"The associated address."},"clearDNSZone(bytes32)":{"params":{"node":"the namehash of the node for which to clear the zone"}},"contenthash(bytes32)":{"params":{"node":"The ENS node to query."},"return":"The associated contenthash."},"dnsRecord(bytes32,bytes32,uint16)":{"params":{"name":"the keccak-256 hash of the fully-qualified name for which to fetch the record","node":"the namehash of the node for which to fetch the record","resource":"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types"},"return":"the DNS record in wire format if present, otherwise empty"},"hasDNSRecords(bytes32,bytes32)":{"params":{"name":"the namehash of the node for which to check the records","node":"the namehash of the node for which to check the records"}},"interfaceImplementer(bytes32,bytes4)":{"params":{"interfaceID":"The EIP 168 interface ID to check for.","node":"The ENS node to query."},"return":"The address that implements this interface, or 0 if the interface is unsupported."},"name(bytes32)":{"params":{"node":"The ENS node to query."},"return":"The associated name."},"pubkey(bytes32)":{"params":{"node":"The ENS node to query"},"return":"x, y the X and Y coordinates of the curve point for the public key."},"setABI(bytes32,uint256,bytes)":{"params":{"contentType":"The content type of the ABI","data":"The ABI data.","node":"The node to update."}},"setAddr(bytes32,address)":{"params":{"a":"The address to set.","node":"The node to update."}},"setAuthorisation(bytes32,address,bool)":{"details":"Sets or clears an authorisation. Authorisations are specific to the caller. Any account can set an authorisation for any name, but the authorisation that is checked will be that of the current owner of a name. Thus, transferring a name effectively clears any existing authorisations, and new authorisations can be set in advance of an ownership transfer if desired.","params":{"isAuthorised":"True if the address should be authorised, or false if it should be deauthorised.","node":"The name to change the authorisation on.","target":"The address that is to be authorised or deauthorised."}},"setContenthash(bytes32,bytes)":{"params":{"hash":"The contenthash to set","node":"The node to update."}},"setDNSRecords(bytes32,bytes)":{"params":{"data":"the DNS wire format records to set","node":"the namehash of the node for which to set the records"}},"setInterface(bytes32,bytes4,address)":{"params":{"implementer":"The address of a contract that implements this interface for this node.","interfaceID":"The EIP 168 interface ID.","node":"The node to update."}},"setName(bytes32,string)":{"params":{"name":"The name to set.","node":"The node to update."}},"setPubkey(bytes32,bytes32,bytes32)":{"params":{"node":"The ENS node to query","x":"the X coordinate of the curve point for the public key.","y":"the Y coordinate of the curve point for the public key."}},"setText(bytes32,string,string)":{"params":{"key":"The key to set.","node":"The node to update.","value":"The text data value to set."}},"text(bytes32,string)":{"params":{"key":"The text data key to query.","node":"The ENS node to query."},"return":"The associated text data."}}},"userdoc":{"methods":{"ABI(bytes32,uint256)":{"notice":"Returns the ABI associated with an ENS node. Defined in EIP205."},"addr(bytes32)":{"notice":"Returns the address associated with an ENS node."},"clearDNSZone(bytes32)":{"notice":"Clear all information for a DNS zone."},"contenthash(bytes32)":{"notice":"Returns the contenthash associated with an ENS node."},"dnsRecord(bytes32,bytes32,uint16)":{"notice":"Obtain a DNS record."},"hasDNSRecords(bytes32,bytes32)":{"notice":"Check if a given node has records."},"interfaceImplementer(bytes32,bytes4)":{"notice":"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP168 and returns `true` for the specified interfaceID, its address will be returned."},"name(bytes32)":{"notice":"Returns the name associated with an ENS node, for reverse records. Defined in EIP181."},"pubkey(bytes32)":{"notice":"Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619."},"setABI(bytes32,uint256,bytes)":{"notice":"Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string."},"setAddr(bytes32,address)":{"notice":"Sets the address associated with an ENS node. May only be called by the owner of that node in the ENS registry."},"setContenthash(bytes32,bytes)":{"notice":"Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry."},"setDNSRecords(bytes32,bytes)":{"notice":"Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:    a.example.com IN A 1.2.3.4    a.example.com IN A 5.6.7.8    www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:    a.example.com IN A 1.2.3.4    www.example.com IN CNAME a.example.com.    a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first."},"setInterface(bytes32,bytes4,address)":{"notice":"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support."},"setName(bytes32,string)":{"notice":"Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry."},"setPubkey(bytes32,bytes32,bytes32)":{"notice":"Sets the SECP256k1 public key associated with an ENS node."},"setText(bytes32,string,string)":{"notice":"Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry."},"text(bytes32,string)":{"notice":"Returns the text data associated with an ENS node and key."}},"notice":"A simple resolver anyone can use; only allows the owner of a node to set its address."}}');

/***/ })

};
;
//# sourceMappingURL=459.bundled.js.map