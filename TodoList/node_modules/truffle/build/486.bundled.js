#!/usr/bin/env node

exports.id = 486;
exports.ids = [486];
exports.modules = {

/***/ 115021:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 115021;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 118967:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 118967;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 327073:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 327073;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 641912:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 641912;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 522539:
/***/ ((module) => {

const options = {
  network: {
    option: "--network <name>",
    description:
      "Specify the network to use. Network name must exist in the configuration."
  },
  config: {
    option: "--config <file>",
    description:
      "Specify configuration file to be used. The default is truffle-config.js"
  },
  quiet: {
    option: "--quiet",
    description: "Suppress excess logging output."
  }
};
 module.exports = options;


/***/ }),

/***/ 651017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TaskError = __webpack_require__(699079);
const yargs = __webpack_require__(564968);
const { bundled, core } = (__webpack_require__(64146).info)();
const OS = __webpack_require__(822037);
const analytics = __webpack_require__(795614);
const { extractFlags } = __webpack_require__(54708); // Contains utility methods
const commandOptions = __webpack_require__(522539);
const debugModule = __webpack_require__(615158);
const debug = debugModule("core:command:run");

class Command {
  constructor(commands) {
    this.commands = commands;

    let args = yargs();

    Object.keys(this.commands).forEach(command => {
      args = args.command(this.commands[command].meta);
    });

    this.args = args;
  }

  getCommand(inputStrings, noAliases) {
    const argv = this.args.parse(inputStrings);

    if (argv._.length === 0) {
      return null;
    }

    const firstInputString = argv._[0];
    let chosenCommand = null;

    // If the command wasn't specified directly, go through a process
    // for inferring the command.
    if (this.commands[firstInputString]) {
      chosenCommand = firstInputString;
    } else if (noAliases !== true) {
      let currentLength = 1;
      const availableCommandNames = Object.keys(this.commands);

      // Loop through each letter of the input until we find a command
      // that uniquely matches.
      while (currentLength <= firstInputString.length) {
        // Gather all possible commands that match with the current length
        const possibleCommands = availableCommandNames.filter(
          possibleCommand => {
            return (
              possibleCommand.substring(0, currentLength) ===
              firstInputString.substring(0, currentLength)
            );
          }
        );

        // Did we find only one command that matches? If so, use that one.
        if (possibleCommands.length === 1) {
          chosenCommand = possibleCommands[0];
          break;
        }

        currentLength += 1;
      }
    }

    if (chosenCommand == null) {
      return null;
    }

    const command = this.commands[chosenCommand];

    return {
      name: chosenCommand,
      argv,
      command
    };
  }

  async run(inputStrings, options) {
    const result = this.getCommand(inputStrings, options.noAliases);

    try {
      // migrate Truffle data to the new location if necessary
      const configMigration = __webpack_require__(199043);
      await configMigration.migrateTruffleDataIfNecessary();
    } catch (error) {
      debug("Truffle data migration failed: %o", error);
    }

    if (result == null) {
      throw new TaskError(
        "Cannot find command based on input: " + JSON.stringify(inputStrings)
      );
    }

    if (typeof result.command.meta.help === "function") {
      result.command.meta.help = await result.command.meta.help(options);
    }

    const argv = result.argv;

    // Remove the task name itself.
    if (argv._) argv._.shift();

    // We don't need this.
    delete argv["$0"];

    // Some options might throw if options is a Config object. If so, let's ignore those options.
    const clone = {};
    Object.keys(options).forEach(key => {
      try {
        clone[key] = options[key];
      } catch (e) {
        // Do nothing with values that throw.
      }
    });

    // while in `console` & `develop`, input is passed as a string, not as an array
    if (!Array.isArray(inputStrings)) inputStrings = inputStrings.split(" ");
    // Method `extractFlags(args)` : Extracts the `--option` flags from arguments
    const inputOptions = extractFlags(inputStrings);

    //adding allowed global options as enumerated in each command
    const allowedGlobalOptions = result.command.meta.help.allowedGlobalOptions
      .filter(tag => tag in commandOptions)
      .map(tag => commandOptions[tag]);

    const allValidOptions = [
      ...result.command.meta.help.options,
      ...allowedGlobalOptions
    ];

    const validOptions = allValidOptions.reduce((a, item) => {
      // we split the options off from the arguments
      // and then we split to handle options of the form --<something>|-<s>
      let options = item.option.split(" ")[0].split("|");
      return [
        ...a,
        ...options.filter(
          option => option.startsWith("--") || option.startsWith("-")
        )
      ];
    }, []);

    let invalidOptions = inputOptions.filter(
      opt => !validOptions.includes(opt)
    );

    // TODO: Remove exception for 'truffle run' when plugin options support added.
    if (invalidOptions.length > 0 && result.name !== "run") {
      if (options.logger) {
        const log = options.logger.log || options.logger.debug;
        log(
          "> Warning: possible unsupported (undocumented in help) command line option(s): " +
            invalidOptions
        );
      }
    }

    const newOptions = Object.assign({}, clone, argv);

    analytics.send({
      command: result.name ? result.name : "other",
      args: result.argv._,
      version: bundled || "(unbundled) " + core
    });

    const unhandledRejections = new Map();

    process.on("unhandledRejection", (reason, promise) => {
      unhandledRejections.set(promise, reason);
    });

    process.on("rejectionHandled", promise => {
      unhandledRejections.delete(promise);
    });

    process.on("exit", _ => {
      const log = options.logger
        ? options.logger.log || options.logger.debug
        : console.log;
      if (unhandledRejections.size) {
        log("UnhandledRejections detected");
        unhandledRejections.forEach((reason, promise) => {
          log(promise, reason);
        });
      }
    });

    return await result.command.run(newOptions);
  }

  displayGeneralHelp() {
    this.args
      .usage(
        "Truffle v" +
          (bundled || core) +
          " - a development framework for Ethereum" +
          OS.EOL +
          OS.EOL +
          "Usage: truffle <command> [options]"
      )
      .epilog("See more at http://trufflesuite.com/docs")
      .showHelp();
  }
}

module.exports = Command;


/***/ }),

/***/ 523525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(158327),
  meta: __webpack_require__(462571)
};


/***/ }),

/***/ 462571:
/***/ ((module) => {

module.exports = {
  command: "build",
  description: "Execute build pipeline (if configuration present)",
  builder: {},
  help: {
    usage: "truffle build",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 158327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const OS = __webpack_require__(822037);
  const colors = __webpack_require__(183196);
  const deprecationMessage = colors.yellow(
    `> The build command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}> See ` +
      `https://github.com/trufflesuite/truffle/issues/3226 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(120553);
  const Build = __webpack_require__(160627);
  const config = Config.detect(options);

  return await Build.build(config);
};


/***/ }),

/***/ 914033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(938666),
  meta: __webpack_require__(553051)
};


/***/ }),

/***/ 553051:
/***/ ((module) => {

module.exports = {
  command: "compile",
  description: "Compile contract source files",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    compiler: {
      type: "string",
      default: null
    },
    list: {
      type: "string"
    },
    help: {
      type: "boolean",
      default: "false"
    }
  },
  help: {
    usage:
      "truffle compile [<source1> <source2>...] [--list <filter>] [--all] [--quiet]",
    options: [
      {
        option: "--all",
        description:
          "Compile all contracts instead of only the contracts changed since last compile."
      },
      {
        option: "--list <filter>",
        description:
          "List all recent stable releases from solc-bin.  If filter is specified then it will display only " +
          "that\n                    type of release or docker tags. The filter parameter must be one of the following: " +
          "prereleases,\n                    releases, latestRelease or docker."
      },
      {
        option: "--compiler <compiler-name>",
        description:
          "Specify a single compiler to use (e.g. `--compiler=solc`). Specify `none` to skip compilation."
      },
      {
        option: "--save-intermediate <output-file>",
        internal: true,
        description:
          "Save the raw compiler results into <output-file>, overwriting any existing content."
      }
    ],
    allowedGlobalOptions: ["config", "quiet"]
  }
};


/***/ }),

/***/ 938666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);

module.exports = async function (options) {
  const TruffleError = __webpack_require__(673321);
  const WorkflowCompile = __webpack_require__(577135);
  const Config = __webpack_require__(120553);
  const config = Config.detect(options);

  if (config.list !== undefined) {
    return await listVersions(config);
  }

  if (
    options.saveIntermediate === true ||
    (typeof options.saveIntermediate === "string" &&
      options.saveIntermediate.trim() === "")
  ) {
    // user asked to save the intermediate compilation results
    // but didn't provide the file to save the results to
    throw new TruffleError(
      "You must provide a file to save compilation results to."
    );
  }

  if (config._ && config._.length > 0) {
    // set paths based on command-line inputs, transforming to absolute
    // paths where appropriate
    config.paths = config._.map(specifiedPath => {
      // convert relative paths to absolute paths based on whether
      // the naive absolute path exists on disk
      //
      // NOTE in case of collision where the specified path refers to some
      // non-FS source (e.g. `truffle/Assert.sol`) and where that specified
      // path corresponds to an existing file relative to the working dir.,
      // this selects the latter as priority over the former.

      const absolutePath = path.resolve(
        config.working_directory,
        specifiedPath
      );

      // i.e., pass the absolutePath if it's a real file, otherwise just
      // pass whatever was specified.
      if (fse.existsSync(absolutePath)) {
        return absolutePath;
      } else {
        return specifiedPath;
      }
    });
  }

  const compilationOutput = await WorkflowCompile.compile(config);
  if (options.saveIntermediate) {
    // Get the filename the user provided to save the compilation results to
    const compilationOutputFile = path.resolve(options.saveIntermediate);

    await fse.writeFile(
      compilationOutputFile,
      JSON.stringify(compilationOutput),
      { encoding: "utf8" }
    );
  }

  const result = await WorkflowCompile.save(config, compilationOutput);
  if (config.db && config.db.enabled) {
    await WorkflowCompile.assignNames(config, result);
  }
};

const listVersions = async function (options) {
  const { CompilerSupplier } = __webpack_require__(4273);
  const { asyncTake } = __webpack_require__(484248);

  const supplier = new CompilerSupplier({
    solcConfig: {
      ...options.compilers.solc,
      // HACK to force use of the VersionRange or Docker strategy
      // as implemented, Docker requires a version to be specified, and so
      // we can't simply remove this field entirely.
      version: "0.5.16",
      docker: options.list === "docker"
    },
    events: options.events
  });

  const log = options.logger.log;
  options.list = options.list.length ? options.list : "releases";

  const { latestRelease, releases, prereleases } = await supplier.list();
  if (options.list === "latestRelease") {
    log(JSON.stringify(latestRelease, null, " "));
    return;
  }

  const allVersions = options.list === "prereleases" ? prereleases : releases;
  const versions = options.all ? allVersions : asyncTake(10, allVersions);

  if (options.all && options.list === "docker") {
    log(
      "Warning: using `--all` with `--list=docker` is very slow and makes " +
        "many HTTP requests."
    );
    log(
      "You may instead want to browse tags on the web here: " +
        "https://hub.docker.com/r/ethereum/solc/tags/"
    );
  }

  const tags = [];
  // use `for await` because Docker strategy returns AsyncIterableIterators
  for await (const version of versions) {
    tags.push(version);
  }

  // Docker tags are best browsed via their own web UI
  if (options.list === "docker" && !options.all) {
    tags.push("See more at: hub.docker.com/r/ethereum/solc/tags/");
  }

  log(JSON.stringify(tags, null, " "));
  return;
};


/***/ }),

/***/ 674445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(783523),
  meta: __webpack_require__(624722)
};


/***/ }),

/***/ 624722:
/***/ ((module) => {

module.exports = {
  command: "config",
  description: "Set user-level configuration options",
  help: {
    usage:
      "truffle config [--enable-analytics|--disable-analytics] [<list>] [[<get|set> <key>] [<value-for-set>]]",
    options: [
      {
        option: "--enable-analytics",
        description: "Enable Truffle to send usage data to Google Analytics."
      },
      {
        option: "--disable-analytics",
        description:
          "Disable Truffle's ability to send usage data to Google Analytics."
      },
      {
        option: "get",
        description: "Get a Truffle config option value."
      },
      {
        option: "set",
        description: "Set a Truffle config option value."
      },
      {
        option: "list",
        description: "List all Truffle config values."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {
    _: {
      type: "string"
    }
  }
};


/***/ }),

/***/ 783523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const userLevelSettings = ["analytics"];
/**
 * run config commands to get/set/list Truffle config options
 * @param {Object} options
 **/
module.exports = async function (options) {
  const googleAnalytics = __webpack_require__(902860);
  const Config = __webpack_require__(120553);
  const OS = __webpack_require__(822037);

  let command;
  if (options.enableAnalytics || options.disableAnalytics) {
    // TODO: Deprecate the --(en|dis)able-analytics flag in favor of `set analytics true`
    command = {
      set: true,
      userLevel: true,
      key: "analytics",
      value: options.enableAnalytics || false
    };
    const message =
      `> WARNING: The --enable-analytics and ` +
      `--disable-analytics flags have been deprecated.${OS.EOL}> Please ` +
      `use 'truffle config set analytics <boolean>'.`;
    console.warn(OS.EOL + message + OS.EOL);
  } else {
    command = parse(options._);
  }

  if (command === null) {
    return await googleAnalytics.setUserConfigViaPrompt();
  } else if (command.userLevel) {
    switch (command.key) {
      case "analytics": {
        if (command.set) {
          googleAnalytics.setAnalytics(command.value);
        } else {
          options.logger.log(googleAnalytics.getAnalytics());
        }
        break;
      }
    }

    return;
  } else if (command.list) {
    options.logger.log("Truffle config values");
    options.logger.log(`analytics = ${googleAnalytics.getAnalytics()}`);
  } else {
    const config = Config.detect(options);

    if (command.set) {
      options.logger.log(
        "Setting project-level parameters is not supported yet."
      );
      // TODO: add support for writing project-level settings to the truffle config file
      // config[command.key] = command.value;
    } else {
      options.logger.log(config[command.key]);
    }
    return;
  }
};

const parse = function (args) {
  if (args.length === 0) {
    return null;
  }

  let option = args[0];

  if (typeof option !== "string") {
    // invalid option
    throw new Error(`Invalid config option "${option}"`);
  }
  option = option.toLowerCase();

  let set = false;
  let list = false;
  let key = args[1];
  let value = args[2];

  switch (option) {
    case "get": {
      set = false;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      break;
    }
    case "set": {
      set = true;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      if (typeof value !== "string" || value === "") {
        // invalid value
        throw new Error("Must provide a <value-for-set>");
      }

      switch (value.toLowerCase()) {
        case "null": {
          value = null;
          break;
        }
        case "undefined": {
          value = undefined;
          break;
        }
        case "true": {
          value = true;
          break;
        }
        case "false": {
          value = false;
          break;
        }
        default: {
          // check if number, otherwise leave as string
          const float = parseFloat(value);
          if (!isNaN(float) && value === float.toString()) {
            value = float;
          }
          break;
        }
      }

      break;
    }
    case "list": {
      list = true;
      break;
    }
    default: {
      if (
        option !== "--enable-analytics" &&
        option !== "--disable-analytics" &&
        option !== ""
      ) {
        // TODO: Deprecate the --(en|dis)able-analytics flag in favor for `enable analytics`
        // invalid command!
        throw new Error(`Invalid config option "${option}"`);
      } else {
        // we should not have gotten here
        return null;
      }
    }
  }

  return {
    set,
    list,
    userLevel: userLevelSettings.includes(key),
    key,
    value
  };
};


/***/ }),

/***/ 789923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(369909),
  meta: __webpack_require__(721288)
};


/***/ }),

/***/ 721288:
/***/ ((module) => {

module.exports = {
  command: "console",
  description:
    "Run a console with contract abstractions and commands available",
  builder: {},
  help: {
    usage: "truffle console [--verbose-rpc] [--require|-r <file>]",
    options: [
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 369909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Console = __webpack_require__(968303);
  const { Environment } = __webpack_require__(376765);

  const config = Config.detect(options);

  const commands = __webpack_require__(591559);
  const excluded = new Set(["console", "init", "watch", "develop"]);

  const consoleCommands = Object.keys(commands).reduce((acc, name) => {
    return !excluded.has(name)
      ? Object.assign(acc, { [name]: commands[name] })
      : acc;
  }, {});

  await Environment.detect(config);
  const c = new Console(consoleCommands, config.with({ noAliases: true }));
  return await c.start();
};


/***/ }),

/***/ 942957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(659442),
  meta: __webpack_require__(646038)
};


/***/ }),

/***/ 646038:
/***/ ((module) => {

module.exports = {
  command: "create",
  description: "Helper to create new contracts, migrations and tests",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    force: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle create <artifact_type> <ArtifactName>",
    options: [
      {
        option: "<artifact_type>",
        description:
          "Create a new artifact where artifact_type is one of the following: " +
          "contract, migration,\n                    test or all. The new artifact is created " +
          "along with one (or all) of the following\n                    files: `contracts/ArtifactName.sol`, " +
          "`migrations/####_artifact_name.js` or\n                    `tests/artifact_name.js`. (required)"
      },
      {
        option: "<ArtifactName>",
        description: "Name of new artifact. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 659442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const ConfigurationError = __webpack_require__(48937);
  const create = __webpack_require__(789664);

  const config = Config.detect(options);

  let type = config.type;

  if (type == null && config._.length > 0) {
    type = config._[0];
  }

  let name = config.name;

  if (name == null && config._.length > 1) {
    name = config._[1];
  }

  if (type == null) {
    throw new ConfigurationError(
      "Please specify the type of item to create. Example: truffle create contract MyContract"
    );
  }

  if (name == null) {
    throw new ConfigurationError(
      "Please specify the name of item to create. Example: truffle create contract MyContract"
    );
  }

  if (!/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {
    throw new ConfigurationError(
      `The name ${name} is invalid. Please enter a valid name using alpha-numeric characters.`
    );
  }

  const fn = create[type];

  const destinations = {
    contract: config.contracts_directory,
    migration: config.migrations_directory,
    test: config.test_directory
  };

  if (type === "all") {
    for (const key of Object.keys(destinations)) {
      await create[key](destinations[key], name, options);
    }
    return;
  } else if (fn == null) {
    throw new ConfigurationError(`Cannot find creation type: ${type}`);
  } else {
    return create[type](destinations[type], name, options);
  }
};


/***/ }),

/***/ 659602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(344556),
  meta: __webpack_require__(399608)
};


/***/ }),

/***/ 399608:
/***/ ((module) => {

module.exports = {
  command: "dashboard",
  description:
    "Start Truffle Dashboard to sign development transactions using browser wallet",
  builder: {
    port: {
      describe: "Specify the port to start the dashboard and RPC endpoint on",
      type: "number"
    },
    host: {
      describe: "Specify the host to start the dashboard and RPC endpoint on",
      type: "string"
    },
    verbose: {
      describe: "Display debug logs for the dashboard server and message bus",
      type: "boolean"
    }
  },
  help: {
    usage: "truffle dashboard [--port <number>] [--host <string>] [--verbose]",
    options: [
      {
        option: "--port <number>",
        description: "Start the dashboard and RPC endpoint on a specific port."
      },
      {
        option: "--host <string>",
        description: "Start the dashboard and RPC endpoint on a specific host."
      },
      {
        option: "--verbose",
        description:
          "Log debug information from the Dashboard server and message bus."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 344556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const { DashboardServer } = __webpack_require__(897722);
  const address = __webpack_require__(494849);

  const config = detectConfigOrDefault(options);

  const port = options.port || config.dashboard.port;
  const host = options.host || config.dashboard.host;
  const verbose = options.verbose || config.dashboard.verbose;
  const rpc = true;

  const dashboardServerOptions = { port, host, verbose, rpc };
  const dashboardServer = new DashboardServer(dashboardServerOptions);
  await dashboardServer.start();

  if (host === "0.0.0.0") {
    // Regex taken from react-scripts to check that the address is a private IP, otherwise we discard it
    // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
    let lanAddress =
      /^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(address.ip())
        ? address.ip()
        : undefined;

    console.log(`Truffle Dashboard running at http://localhost:${port}`);
    lanAddress &&
      console.log(`                             http://${lanAddress}:${port}`);

    console.log(
      `DashboardProvider RPC endpoint running at http://localhost:${port}/rpc`
    );
    lanAddress &&
      console.log(
        `                                          http://${lanAddress}:${port}/rpc`
      );
  } else {
    console.log(`Truffle Dashboard running at http://${host}:${port}`);
    console.log(
      `DashboardProvider RPC endpoint running at http://${host}:${port}/rpc`
    );
  }

  // ensure that `await`-ing this method never resolves. (we want to keep
  // the console open until it exits on its own)
  return new Promise(() => {});
};


/***/ }),

/***/ 206758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(750823),
  meta: __webpack_require__(779062)
};


/***/ }),

/***/ 779062:
/***/ ((module) => {

module.exports = {
  command: "query",
  description: "Query @truffle/db",
  builder: {},
  help: {
    usage: "truffle db query <query>",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 750823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(120553);
  const { getTruffleDb } = __webpack_require__(570972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { connect } = Db;

  const config = Config.detect(argv);
  const [_, query] = config._;

  if (!query) {
    throw new Error(
      "Query not provided. Please run `truffle db query <query>`"
    );
  }

  const db = connect(config.db);

  const result = await db.execute(query, {});
  console.log(JSON.stringify(result, null, 2));
};


/***/ }),

/***/ 243405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(12233),
  meta: __webpack_require__(111297)
};


/***/ }),

/***/ 111297:
/***/ ((module) => {

module.exports = {
  command: "serve",
  description: "Start Truffle's GraphQL UI playground",
  builder: {},
  help: {
    usage: "truffle db serve",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 12233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(120553);
  const { getTruffleDb } = __webpack_require__(570972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { serve } = Db;

  const config = Config.detect(argv);
  const port = (config.db && config.db.port) || 4444;
  const host = (config.db && config.db.host) || "127.0.0.1";

  const { url } = await serve(config.db).listen({ host, port });

  console.log(`ðŸš€ Playground listening at ${url}`);
  console.log(`â„¹  Press Ctrl-C to exit`);

  await new Promise(() => {});
};


/***/ }),

/***/ 149797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(416487),
  meta: __webpack_require__(150111)
};


/***/ }),

/***/ 150111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);
const serveCommand = __webpack_require__(243405);
const queryCommand = __webpack_require__(206758);

const usage =
  "truffle db <sub-command> [options]" +
  OS.EOL +
  "  Available sub-commands: " +
  OS.EOL +
  "                serve \tStart the GraphQL server";

module.exports = {
  command: "db",
  description: "Database interface commands",
  builder: function (yargs) {
    return yargs
      .command({
        ...serveCommand.run,
        ...serveCommand.meta
      })
      .demandCommand();
  },

  subCommands: {
    serve: {
      help: serveCommand.help,
      description: serveCommand.meta
    },
    query: {
      help: queryCommand.help,
      description: queryCommand.meta
    }
  },

  help: {
    usage,
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 416487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const serveCommand = __webpack_require__(243405);
const queryCommand = __webpack_require__(206758);

module.exports = async function (args) {
  const [subCommand] = args._;
  switch (subCommand) {
    case "serve":
      await serveCommand.run(args);
      break;

    case "query":
      await queryCommand.run(args);
      break;

    default:
      console.log(`Unknown command: ${subCommand}`);
  }
};


/***/ }),

/***/ 476463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(30999),
  meta: __webpack_require__(542285),
  mergeConfigNetwork: __webpack_require__(266856),
  loadConfig: __webpack_require__(19246)
};


/***/ }),

/***/ 19246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function (options) {
  const Config = __webpack_require__(120553);
  const TruffleError = __webpack_require__(673321);
  const mergeConfigNetwork = __webpack_require__(266856);

  let config;
  try {
    config = Config.detect(options);
    config = mergeConfigNetwork(config, options);
  } catch (error) {
    if (error instanceof TruffleError && options.url) {
      config = Config.default();
      config = mergeConfigNetwork(config, options);
      // in case config file is not detected (exception thrown) AND url is provided in the options,
      // We use default config and set compileNone to true. Since there are is no config files and url is provided,
      // It is assumed that truffle debug is being used for analysis and debugging and that there is nothing to compile.
      // E.g. analysing/debugging a single transaction of an external project
      config.compileNone = true;
      config.configFileSkipped = true;
    } else {
      throw error;
    }
  }

  return config;
};


/***/ }),

/***/ 266856:
/***/ ((module) => {

module.exports = function (config, options) {
  if (options.url) {
    const inlineConfigNetwork = "inline_config";
    config.networks[inlineConfigNetwork] = {
      url: options.url,
      network_id: "*"
    };
    config.network = inlineConfigNetwork;
  }
  config.merge(options);
  return config;
};


/***/ }),

/***/ 542285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);

module.exports = {
  command: "debug",
  description: "Interactively debug any transaction on the blockchain",
  builder: {
    "url": {
      describe: "Use specified URL for provider",
      type: "string"
    },
    "_": {
      type: "string"
    },
    "fetch-external": {
      describe: "Allow debugging of external contracts",
      alias: "x",
      type: "boolean",
      default: false
    },
    "compile-tests": {
      describe: "Allow debugging of Solidity test contracts",
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Force debugger to compile all contracts for extra safety",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Force debugger to skip compilation (dangerous!)",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage:
      "truffle debug [<transaction_hash>] [--fetch-external|-x]" +
      OS.EOL +
      "                             [--network <network>|--url <provider_url>]" +
      OS.EOL +
      "                             [--compile-tests|--compile-all|--compile-none]",
    options: [
      {
        option: "<transaction_hash>",
        description:
          "Transaction ID to use for debugging.  Mandatory if --fetch-external is passed."
      },
      {
        option: "--fetch-external|-x",
        description:
          "Allows debugging of external contracts with verified sources."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--url",
        description:
          "Connects to a specified provider given via URL, ignoring networks in config. This option allows using the debugger outside of a Truffle project."
      },
      {
        option: "--compile-tests",
        description:
          "Allows debugging of Solidity test contracts from the test directory.  Implies --compile-all."
      },
      {
        option: "--compile-all",
        description:
          "Forces the debugger to recompile all contracts even if it detects that it can use the artifacts."
      },
      {
        option: "--compile-none",
        description:
          "Forces the debugger to use artifacts even if it detects a problem.  Dangerous; may cause errors."
      }
    ],
    allowedGlobalOptions: ["config"]
    //although network is an allowed global option, it isn't listed here because listing it here would cause
    //it to be tacked on to the end of usage, which would prevent us from doing the thing above where we
    //combine its usage instructions with url to show that they're mutually exclusive.  so as a workaround
    //we've excluded network from here, and added it manually above.
  }
};


/***/ }),

/***/ 30999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { promisify } = __webpack_require__(473837);
  const debugModule = __webpack_require__(615158);
  const loadConfig = __webpack_require__(19246);
  const debug = debugModule("lib:commands:debug");

  const { Environment } = __webpack_require__(376765);
  const { CLIDebugger } = __webpack_require__(209941);

  if (options.url && options.network) {
    throw new Error("Url and Network options should not be specified together");
  }

  let config = loadConfig(options);

  await Environment.detect(config);

  const txHash = config._[0]; //may be undefined
  if (config.fetchExternal && txHash === undefined) {
    throw new Error(
      "Fetch-external mode requires a specific transaction to debug"
    );
  }
  if (config.compileTests) {
    config.compileAll = true;
  }
  if (config.compileAll && config.compileNone) {
    throw new Error("Incompatible options passed regarding what to compile");
  }
  const interpreter = await new CLIDebugger(config, { txHash }).run();
  return await promisify(interpreter.start.bind(interpreter))();
};


/***/ }),

/***/ 8230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(301527),
  meta: __webpack_require__(772041)
};


/***/ }),

/***/ 772041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const migrate = __webpack_require__(601827);

module.exports = {
  command: "deploy",
  description: "(alias for migrate)",
  builder: migrate.builder,
  help: {
    usage:
      "truffle deploy [--reset] [-f <number>] [--compile-all] [--verbose-rpc]",
    options: migrate.meta.help.options,
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 301527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const runMigrate = __webpack_require__(152423);

module.exports = runMigrate;


/***/ }),

/***/ 355114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(927970),
  meta: __webpack_require__(314957)
};


/***/ }),

/***/ 314957:
/***/ ((module) => {

module.exports = {
  command: "develop",
  description: "Open a console with a local development blockchain",
  builder: {
    log: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle develop [--log] [--require|-r <file>]",
    options: [
      {
        option: `--log`,
        description:
          `Start/Connect to a Truffle develop session and log all ` +
          `rpc activity. You will\n                    need to open a ` +
          `different Truffle develop or console session to interact via the repl.`
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    allowedGlobalOptions: ["config"]
  }
};


/***/ }),

/***/ 927970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const emoji = __webpack_require__(858445);
const mnemonicInfo = __webpack_require__(225603);
const {
  configureManagedGanache,
  getFirstDefinedValue
} = __webpack_require__(87088);

const runConsole = async (config, ganacheOptions) => {
  const Console = __webpack_require__(968303);
  const { Environment } = __webpack_require__(376765);

  const commands = __webpack_require__(591559);
  const excluded = new Set(["console", "develop", "unbox", "init"]);

  const consoleCommands = Object.keys(commands).reduce((acc, name) => {
    return !excluded.has(name)
      ? Object.assign(acc, { [name]: commands[name] })
      : acc;
  }, {});

  await Environment.develop(config, ganacheOptions);
  const c = new Console(consoleCommands, config.with({ noAliases: true }));
  c.on("exit", () => process.exit());
  return await c.start();
};

module.exports = async options => {
  const { Develop } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);

  const config = Config.detect(options);
  const customConfig = config.networks.develop || {};

  const numberOfAccounts = getFirstDefinedValue(
    customConfig.accounts,
    customConfig.total_accounts,
    10 // Use as default number of accounts
  );
  const { mnemonic, accounts, privateKeys } =
    mnemonicInfo.getAccountsInfo(numberOfAccounts);

  const onMissing = () => "**";

  const warning =
    ":warning:  Important :warning:  : " +
    "This mnemonic was created for you by Truffle. It is not secure.\n" +
    "Ensure you do not use it on production blockchains, or else you risk losing funds.";

  const ipcOptions = { log: options.log };
  const ganacheOptions = configureManagedGanache(
    config,
    customConfig,
    mnemonic
  );

  const { started } = await Develop.connectOrStart(ipcOptions, ganacheOptions);
  const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

  if (started) {
    config.logger.log(`Truffle Develop started at ${url}`);
    config.logger.log();

    config.logger.log(`Accounts:`);
    accounts.forEach((acct, idx) => config.logger.log(`(${idx}) ${acct}`));
    config.logger.log();

    config.logger.log(`Private Keys:`);
    privateKeys.forEach((key, idx) => config.logger.log(`(${idx}) ${key}`));
    config.logger.log();

    config.logger.log(`Mnemonic: ${mnemonic}`);
    config.logger.log();
    config.logger.log(emoji.emojify(warning, onMissing));
    config.logger.log();
  } else {
    config.logger.log(
      `Connected to existing Truffle Develop session at ${url}`
    );
    config.logger.log();
  }

  if (options.log) {
    // leave the process open so that logging can take place
    return new Promise(() => {});
  }
  return await runConsole(config, ganacheOptions);
};


/***/ }),

/***/ 241400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(22888),
  meta: __webpack_require__(781483)
};


/***/ }),

/***/ 781483:
/***/ ((module) => {

module.exports = {
  command: "exec",
  description: "Execute a JS module within this Truffle environment",
  builder: {
    file: {
      type: "string"
    },
    c: {
      type: "boolean",
      default: false
    },
    compile: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle exec <script.js> [--compile]",
    options: [
      {
        option: "<script.js>",
        description:
          "JavaScript file to be executed. Can include path information if the script" +
          " does not exist in the current\n                    directory. (required)"
      },
      {
        option: "--compile",
        description: "Compile contracts before executing the script."
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 22888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const WorkflowCompile = __webpack_require__(577135);
  const ConfigurationError = __webpack_require__(48937);
  const Require = __webpack_require__(868992);
  const { Environment } = __webpack_require__(376765);
  const path = __webpack_require__(371017);
  const OS = __webpack_require__(822037);
  const { promisify } = __webpack_require__(473837);

  const config = Config.detect(options);

  let file = options.file;

  if (file == null && options._.length > 0) {
    file = options._[0];
  }

  if (file == null) {
    throw new ConfigurationError(
      "Please specify a file, passing the path of the script you'd like the run. Note that all scripts *must* call process.exit() when finished."
    );
  }

  if (path.isAbsolute(file) === false) {
    file = path.join(process.cwd(), file);
  }

  await Environment.detect(config);
  if (config.networkHint !== false) {
    config.logger.log("Using network '" + config.network + "'." + OS.EOL);
  }

  // `--compile`
  let compilationOutput;
  if (options.c || options.compile) {
    compilationOutput = await WorkflowCompile.compile(config);
  }
  // save artifacts if compilation took place
  if (compilationOutput) {
    await WorkflowCompile.save(config, compilationOutput);
  }
  return await promisify(Require.exec.bind(Require))(config.with({ file }));
};


/***/ }),

/***/ 463979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (selectedCommand, subCommand, options) {
  const commands = __webpack_require__(591559);
  const commandOptions = __webpack_require__(522539);

  let commandHelp, commandDescription;

  const chosenCommand = commands[selectedCommand];

  if (subCommand && chosenCommand.subCommands[subCommand]) {
    commandHelp = chosenCommand.subCommands[subCommand].meta.help;
    commandDescription = chosenCommand.subCommands[subCommand].meta.description;
  } else {
    commandHelp = chosenCommand.meta.help;
    commandDescription = chosenCommand.meta.description;
  }

  if (typeof commandHelp === "function") {
    commandHelp = await commandHelp(options);
  }

  const allowedGlobalOptions = commandHelp.allowedGlobalOptions
    .filter(tag => tag in commandOptions)
    .map(tag => commandOptions[tag]);
  const validOptionsUsage = allowedGlobalOptions
    .map(({ option }) => `[${option}]`)
    .join(" ");

  const commandHelpUsage = commandHelp.usage + " " + validOptionsUsage;

  console.log(`\n  Usage:        ${commandHelpUsage}`);
  console.log(`  Description:  ${commandDescription}`);

  if (commandHelp.options.length > 0) {
    const allValidOptions = [...commandHelp.options, ...allowedGlobalOptions];

    console.log(`  Options: `);
    for (const option of allValidOptions) {
      if (option.internal) {
        continue;
      }

      console.log(`                ${option.option}`);
      console.log(`                    ${option.description}`);
    }
  }
  console.log("");
};


/***/ }),

/***/ 867340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(909546),
  meta: __webpack_require__(634914),
  displayCommandHelp: __webpack_require__(463979)
};


/***/ }),

/***/ 634914:
/***/ ((module) => {

module.exports = {
  command: "help",
  description:
    "List all commands or provide information about a specific command",
  help: {
    usage: "truffle help [<command>]",
    options: [
      {
        option: "<command>",
        description: "Name of the command to display information for."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {}
};


/***/ }),

/***/ 909546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const displayCommandHelp = __webpack_require__(463979);
  const commands = __webpack_require__(591559);
  if (options._.length === 0) {
    await displayCommandHelp("help", options);
    return;
  }
  const selectedCommand = options._[0];
  const subCommand = options._[1];

  if (commands[selectedCommand]) {
    await displayCommandHelp(selectedCommand, subCommand, options);
    return;
  } else {
    console.log(`\n  Cannot find the given command '${selectedCommand}'`);
    console.log("  Please ensure your command is one of the following: ");
    Object.keys(commands)
      .sort()
      .forEach(command => console.log(`      ${command}`));
    console.log("");
    return;
  }
};


/***/ }),

/***/ 344062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);
const { promptOverwrites } = __webpack_require__(169751);

const copyFiles = async (destination, options) => {
  fse.ensureDirSync(destination);
  const { force, logger, events } = options;
  const sourcePath = path.join(__dirname, "initSource");
  const projectFiles = fse.readdirSync(sourcePath).filter(
    filename => !filename.endsWith(".eslintrc.json") //exclude .eslintrc.json
  );
  const destinationContents = fse.readdirSync(destination);

  const newContents = projectFiles.filter(
    filename => !destinationContents.includes(filename)
  );

  const contentCollisions = projectFiles.filter(filename =>
    destinationContents.includes(filename)
  );

  let shouldCopy;
  if (force) {
    shouldCopy = projectFiles;
  } else {
    const overwriteContents = await promptOverwrites(contentCollisions, logger);
    shouldCopy = [...newContents, ...overwriteContents];
  }

  await events.emit("init:copyingProjectFiles", {
    destinationPath: destination,
  });
  for (const file of shouldCopy) {
    fse.copySync(path.join(sourcePath, file), path.join(destination, file));
  }
};

module.exports = { copyFiles };


/***/ }),

/***/ 429287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(97509),
  meta: __webpack_require__(383193)
};


/***/ }),

/***/ 383193:
/***/ ((module) => {

module.exports = {
  command: "init",
  description: "Initialize new and empty Ethereum project",
  builder: {},
  help: {
    usage: "truffle init [--force]",
    options: [
      {
        option: "--force",
        description:
          "Initialize project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 169751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(655674);
const inquirer = __webpack_require__(496062);

const promptOverwrites = async (contentCollisions, logger = console) => {
  const overwriteContents = [];

  for (const file of contentCollisions) {
    logger.log(`${file} already exists in this directory...`);
    const overwriting = [
      {
        type: "confirm",
        name: "overwrite",
        message: `Overwrite ${file}?`,
        default: false,
      },
    ];

    const { overwrite } = await inquirer.prompt(overwriting);
    if (overwrite) {
      fse.removeSync(file);
      overwriteContents.push(file);
    }
  }

  return overwriteContents;
};

module.exports = { promptOverwrites };


/***/ }),

/***/ 97509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { copyFiles } = __webpack_require__(344062);
  const fse = __webpack_require__(655674);
  const Config = __webpack_require__(120553);
  const config = Config.default();

  let destinationPath;
  if (options._ && options._.length > 0) {
    destinationPath = options._[0];
    fse.ensureDirSync(destinationPath);
  } else {
    destinationPath = config.working_directory;
  }

  const { events } = config;
  events.emit("init:start");

  try {
    await copyFiles(destinationPath, config);
    await events.emit("init:succeed");
  } catch (error) {
    await events.emit("init:fail", { error });
    throw error;
  }
  return;
};


/***/ }),

/***/ 270447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(308515),
  meta: __webpack_require__(472545)
};


/***/ }),

/***/ 472545:
/***/ ((module) => {

module.exports = {
  command: "install",
  description: "Install a package from the Ethereum Package Registry",
  builder: {},
  help: {
    usage: "truffle install <package_name>[@<version>]",
    options: [
      {
        option: "package_name",
        description:
          "Name of the package as listed in the Ethereum Package Registry. (required)"
      },
      {
        option: "<@version>",
        description:
          "When specified, will install a specific version of the package, otherwise " +
          "will install\n                    the latest version."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 308515:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Package = __webpack_require__(883513);

  if (options._ && options._.length > 0) options.packages = options._;

  const config = Config.detect(options);
  return await Package.install(config);
};


/***/ }),

/***/ 883292:
/***/ ((module) => {

module.exports = function (config, options) {
  // Source: ethereum.stackexchange.com/questions/17051
  const networkWhitelist = [
    1, // Mainnet (ETH & ETC)
    2, // Morden (ETC)
    3, // Ropsten
    4, // Rinkeby
    5, // Goerli
    8, // Ubiq
    42, // Kovan (Parity)
    77, // Sokol
    99, // Core

    7762959, // Musiccoin
    61717561 // Aquachain
  ];

  let dryRunOnly, skipDryRun;
  const networkSettingsInConfig = config.networks[config.network];
  if (networkSettingsInConfig) {
    dryRunOnly =
      options.dryRun === true ||
      networkSettingsInConfig.dryRun === true ||
      networkSettingsInConfig["dry-run"] === true;
    skipDryRun =
      options.skipDryRun === true ||
      networkSettingsInConfig.skipDryRun === true ||
      networkSettingsInConfig["skip-dry-run"] === true;
  } else {
    dryRunOnly = options.dryRun === true;
    skipDryRun = options.skipDryRun === true;
  }
  const production =
    networkWhitelist.includes(parseInt(config.network_id)) || config.production;
  const dryRunAndMigrations = production && !skipDryRun;
  return { dryRunOnly, dryRunAndMigrations };
};


/***/ }),

/***/ 601827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(152423),
  meta: __webpack_require__(88226),
  runMigrations: __webpack_require__(853983),
  setUpDryRunEnvironmentThenRunMigrations: __webpack_require__(643687),
  determineDryRunSettings: __webpack_require__(883292),
  prepareConfigForRealMigrations: __webpack_require__(97374)
};


/***/ }),

/***/ 88226:
/***/ ((module) => {

module.exports = {
  command: "migrate",
  description: "Run migrations to deploy contracts",
  builder: {
    "reset": {
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Recompile all contracts",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Do not compile contracts",
      type: "boolean",
      default: false
    },
    "dry-run": {
      describe: "Run migrations against an in-memory fork, for testing",
      type: "boolean",
      default: false
    },
    "skip-dry-run": {
      describe: "Skip the test or 'dry run' migrations",
      type: "boolean",
      default: false
    },
    "f": {
      describe: "Specify a migration number to run from",
      type: "number"
    },
    "to": {
      describe: "Specify a migration number to run to",
      type: "number"
    },
    "interactive": {
      describe: "Manually authorize deployments after seeing a preview",
      type: "boolean",
      default: false
    },
    "describe-json": {
      describe: "Adds extra verbosity to the status of an ongoing migration",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage:
      "truffle migrate [--reset] [--f <number>] [--to <number>]\n" +
      "                                " + // spacing to align with previous line
      "[--compile-all] [--compile-none] [--verbose-rpc] [--interactive]\n" +
      "                                " + // spacing to align with previous line
      "[--skip-dry-run] [--describe-json] [--dry-run]",
    options: [
      {
        option: "--reset",
        description:
          "Run all migrations from the beginning, instead of running from the last " +
          "completed migration."
      },
      {
        option: "--f <number>",
        description:
          "Run contracts from a specific migration. The number refers to the prefix of " +
          "the migration file."
      },
      {
        option: "--to <number>",
        description:
          "Run contracts to a specific migration. The number refers to the prefix of the migration file."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need to " +
          "be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before migrating."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--interactive",
        description:
          "Prompt to confirm that the user wants to proceed after the dry run."
      },
      {
        option: "--dry-run",
        description: "Only perform a test or 'dry run' migration."
      },
      {
        option: "--skip-dry-run",
        description: "Do not run a test or 'dry run' migration."
      },
      {
        option: "--describe-json",
        description:
          "Adds extra verbosity to the status of an ongoing migration"
      }
    ],
    allowedGlobalOptions: ["network", "config", "quiet"]
  }
};


/***/ }),

/***/ 97374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (buildDir, options) {
  const Artifactor = __webpack_require__(529463);
  const { Resolver } = __webpack_require__(648511);
  const Migrate = __webpack_require__(523459);
  const { Environment } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);

  let accept = true;

  if (options.interactive) {
    accept = await Migrate.promptToAcceptDryRun();
  }

  if (accept) {
    const config = Config.detect(options);

    config.contracts_build_directory = buildDir;
    config.artifactor = new Artifactor(buildDir);
    config.resolver = new Resolver(config);

    try {
      await Environment.detect(config);
    } catch (error) {
      throw new Error(error);
    }

    config.dryRun = false;
    return {
      preparedConfig: config,
      proceed: true
    };
  } else {
    return { proceed: false };
  }
};


/***/ }),

/***/ 152423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const WorkflowCompile = __webpack_require__(577135);
  const { Environment } = __webpack_require__(376765);
  const Config = __webpack_require__(120553);
  const determineDryRunSettings = __webpack_require__(883292);
  const prepareConfigForRealMigrations = __webpack_require__(97374);
  const runMigrations = __webpack_require__(853983);
  const setUpDryRunEnvironmentThenRunMigrations = __webpack_require__(643687);
  const tmp = __webpack_require__(336276);
  tmp.setGracefulCleanup();

  const config = Config.detect(options);
  if (config.compileNone || config["compile-none"]) {
    config.compiler = "none";
  }

  const result = await WorkflowCompile.compileAndSave(config);
  await WorkflowCompile.assignNames(config, result);
  await Environment.detect(config);

  const { dryRunOnly, dryRunAndMigrations } = determineDryRunSettings(
    config,
    options
  );

  if (dryRunOnly) {
    config.dryRun = true;
    await setUpDryRunEnvironmentThenRunMigrations(config);
  } else if (dryRunAndMigrations) {
    const currentBuild = config.contracts_build_directory;
    config.dryRun = true;

    await setUpDryRunEnvironmentThenRunMigrations(config);

    const { preparedConfig, proceed } = await prepareConfigForRealMigrations(
      currentBuild,
      options
    );
    if (proceed) await runMigrations(preparedConfig);
  } else {
    await runMigrations(config);
  }
};


/***/ }),

/***/ 853983:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Migrate = __webpack_require__(523459);

module.exports = async function (config) {
  if (config.f) {
    return await Migrate.runFrom(config.f, config);
  } else {
    const needsMigrating = await Migrate.needsMigrating(config);

    if (needsMigrating) {
      return await Migrate.run(config);
    } else {
      config.logger.log("Network up to date.");
    }
  }
};


/***/ }),

/***/ 643687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Environment } = __webpack_require__(376765);
const Artifactor = __webpack_require__(529463);

const { Resolver } = __webpack_require__(648511);
const fse = __webpack_require__(655674);

const tmp = __webpack_require__(336276);
tmp.setGracefulCleanup();
const runMigrations = __webpack_require__(853983);

module.exports = async function (config) {
  await Environment.fork(config, {
    logging: {
      quiet: true
    },
    // we need to tell Ganache to not unlock any accounts so that only
    // user's accounts are unlocked since this will be a dry run
    wallet: {
      totalAccounts: 0
    }
  });
  // Copy artifacts to a temporary directory
  const temporaryDirectory = tmp.dirSync({
    unsafeCleanup: true,
    prefix: "migrate-dry-run-"
  }).name;

  fse.copySync(config.contracts_build_directory, temporaryDirectory);

  config.contracts_build_directory = temporaryDirectory;
  // Note: Create a new artifactor and resolver with the updated config.
  // This is because the contracts_build_directory changed.
  // Ideally we could architect them to be reactive of the config changes.
  config.artifactor = new Artifactor(temporaryDirectory);
  config.resolver = new Resolver(config);

  return await runMigrations(config);
};


/***/ }),

/***/ 399706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(213018),
  meta: __webpack_require__(741873)
};


/***/ }),

/***/ 741873:
/***/ ((module) => {

module.exports = {
  command: "networks",
  description: "Show addresses for deployed contracts on each network",
  builder: {
    clean: {
      describe:
        "Remove network artifacts that don't belong to any configuration",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle networks [--clean]",
    options: [
      {
        option: "--clean",
        description:
          "Remove all network artifacts that aren't associated with a named network."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 213018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Networks = __webpack_require__(478979);

  const config = Config.detect(options);

  if (options.clean) {
    return await Networks.clean(config);
  }
  return await Networks.display(config);
};


/***/ }),

/***/ 853017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(334122),
  meta: __webpack_require__(719518)
};


/***/ }),

/***/ 719518:
/***/ ((module) => {

module.exports = {
  command: "obtain",
  description: "Fetch and cache a specified compiler",
  help: {
    usage: "truffle obtain [--solc <version>]",
    options: [
      {
        option: "--solc <version>",
        description: `Download and cache a version of the solc compiler. (required)`
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 334122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const SUPPORTED_COMPILERS = ["--solc"];
  const Config = __webpack_require__(120553);
  const config = Config.default().with(options);

  config.events.emit("obtain:start");

  if (options.solc) {
    return await downloadAndCacheSolc({ config, options });
  }

  const message =
    `You have specified a compiler that is unsupported by ` +
    `Truffle.\nYou must specify one of the following ` +
    `compilers as well as a version as arguments: ` +
    `${SUPPORTED_COMPILERS.join(", ")}\nSee 'truffle help ` +
    `obtain' for more information and usage.`;
  throw new Error(message);
};

const downloadAndCacheSolc = async ({ config, options }) => {
  const { CompilerSupplier } = __webpack_require__(4273);
  const semver = __webpack_require__(627029);
  const { events } = config;

  const version = options.solc;
  if (!version || !semver.validRange(version)) {
    const message =
      `You must specify a valid solc version to download` +
      `You specified: "${version}".`;
    throw new Error(message);
  }

  try {
    const supplier = new CompilerSupplier({
      events,
      solcConfig: {
        ...config.compilers.solc,
        version
      }
    });
    const { solc } = await supplier.load();
    events.emit("obtain:succeed", {
      compiler: {
        version: solc.version(),
        name: "Solidity"
      }
    });
    return;
  } catch (error) {
    events.emit("obtain:fail");
    return;
  }
};


/***/ }),

/***/ 448829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(186295),
  meta: __webpack_require__(103697)
};


/***/ }),

/***/ 103697:
/***/ ((module) => {

module.exports = {
  command: "opcode",
  description: "Print the compiled opcodes for a given contract",
  builder: {
    all: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle opcode <contract_name>",
    options: [
      {
        option: "<contract_name>",
        description:
          "Name of the contract to print opcodes for. Must be a contract name, not a file name. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 186295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const TruffleError = __webpack_require__(673321);
  const WorkflowCompile = __webpack_require__(577135);
  const CodeUtils = __webpack_require__(908135);
  const { Conversion } = __webpack_require__(20102);

  if (options._.length === 0) {
    throw new TruffleError("Please specify a contract name.");
  }

  const config = Config.detect(options);
  await WorkflowCompile.compileAndSave(config);
  const contractName = options._[0];
  let Contract;
  try {
    Contract = config.resolver.require(contractName);
  } catch (e) {
    throw new TruffleError(
      'Cannot find compiled contract with name "' + contractName + '"'
    );
  }

  let bytecode = Contract.deployedBytecode;
  let numInstructions = Contract.deployedSourceMap.split(";").length;

  if (options.creation) {
    bytecode = Contract.bytecode;
    numInstructions = Contract.sourceMap.split(";").length;
  }
  const opcodes = CodeUtils.parseCode(bytecode, numInstructions);

  if (opcodes.length === 0) {
    console.log(
      "Contract has no bytecode. Please check to make sure it's not an `abstract contract` or an `interface`."
    );
    return;
  }

  const lastPCByteLength = Conversion.toBytes(
    opcodes[opcodes.length - 1].pc
  ).byteLength;

  opcodes.forEach(opcode => {
    console.log(
      Conversion.toHexString(opcode.pc, lastPCByteLength) + ":",
      opcode.name,
      opcode.pushData || ""
    );
  });
};


/***/ }),

/***/ 796112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(322954),
  meta: __webpack_require__(639175)
};


/***/ }),

/***/ 639175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  command: "preserve",
  description:
    "Save data to decentralized storage platforms like IPFS and Filecoin",
  help: async options => {
    const TruffleError = __webpack_require__(673321);
    const { Plugins } = __webpack_require__(342113);
    const { getConfig } = __webpack_require__(361914);
    const semver = __webpack_require__(627029);

    if (!semver.satisfies(process.version, ">=12")) {
      throw new TruffleError(
        `The current version of Node (${process.version}) does not support \`truffle preserve\`, please update to Node >=12`
      );
    }

    const config = getConfig(options);

    const recipes = Plugins.listAllRecipes(config);

    // If a recipe does not define a tag, it is not an end-user recipe
    const recipeFlags = recipes
      .filter(recipe => recipe.tag !== undefined)
      .map(recipe => ({
        option: `--${recipe.tag}`,
        description: recipe.loadRecipe().help
      }));

    const flags = [
      {
        option: "--environment",
        description:
          "Environment name, as defined in truffle-config `environments` object"
      },
      ...recipeFlags
    ];

    return {
      usage:
        "truffle preserve [--environment=<environment>] <target-path>... --<recipe-tag>",
      options: flags,
      allowedGlobalOptions: []
    };
  }
};


/***/ }),

/***/ 361914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(120553);

const defaultPlugins = [
  "@truffle/preserve-fs",
  "@truffle/preserve-to-ipfs",
  "@truffle/preserve-to-filecoin",
  "@truffle/preserve-to-buckets"
];

const getConfig = options => {
  let config;
  try {
    config = Config.detect(options);
  } catch (_) {
    config = Config.default().with(options);
  }

  config.plugins = [...(config.plugins || []), ...defaultPlugins];

  return config;
};

const constructRecipes = (plugins, environment) => {
  return plugins.map(plugin => {
    const options = (environment || {})[plugin.tag] || {};
    const Recipe = plugin.loadRecipe();
    const recipe = new Recipe(options);
    return recipe;
  });
};

module.exports = {
  getConfig,
  constructRecipes
};


/***/ }),

/***/ 322954:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async options => {
  const TruffleError = __webpack_require__(673321);
  const { Plugins } = __webpack_require__(342113);
  const { getConfig, constructRecipes } = __webpack_require__(361914);
  const { preserve, ConsoleReporter } = __webpack_require__(805810);
  const semver = __webpack_require__(627029);

  if (!semver.satisfies(process.version, ">=12")) {
    throw new TruffleError(
      `The current version of Node (${process.version}) does not support \`truffle preserve\`, please update to Node >=12`
    );
  }

  const config = getConfig(options);

  const environments = config.environments || {};

  if (config.environment && !(config.environment in environments)) {
    throw new TruffleError(
      `Unknown environment: ${config.environment}. Check your truffle-config.js?`
    );
  }

  const plugins = Plugins.listAllRecipes(config);
  const environment = environments[config.environment || "development"];
  const recipes = constructRecipes(plugins, environment);

  // check for tag in options (instead of config, for maybe extra safety)
  const recipePlugin = plugins.find(plugin => plugin.tag in options);

  if (!recipePlugin) {
    throw new TruffleError("No (valid) recipe specified");
  }

  const [recipe] = constructRecipes([recipePlugin], environment);

  if (config._.length === 0) {
    throw new TruffleError("No preserve target specified");
  }

  for (const path of config._) {
    config.logger.log();
    const message = `Preserving target: ${path}`;
    config.logger.log(message);
    config.logger.log("=".repeat(message.length));

    const reporter = new ConsoleReporter({ console: config.logger });

    // The specified path and the truffle config are passed as initial inputs
    // that can be used by any recipe.
    const inputs = { path, config };

    await reporter.report(
      preserve({
        recipes,
        request: { recipe, inputs }
      })
    );

    config.logger.log();
  }
};


/***/ }),

/***/ 388023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(822986),
  meta: __webpack_require__(939662)
};


/***/ }),

/***/ 939662:
/***/ ((module) => {

module.exports = {
  command: "publish",
  description: "Publish a package to the Ethereum Package Registry",
  builder: {},
  help: {
    usage: "truffle publish",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 822986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const Package = __webpack_require__(883513);

  const config = Config.detect(options);
  return await Package.publish(config);
};


/***/ }),

/***/ 443736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(673321);

const checkPluginConfig = ({ plugins }) => {
  if (!plugins) {
    throw new TruffleError(
      "\nError: No plugins detected in the configuration file.\n"
    );
  }

  if (!Array.isArray(plugins) || plugins.length === 0) {
    throw new TruffleError("\nError: Plugins configured incorrectly.\n");
  }
};

module.exports = {
  checkPluginConfig
};


/***/ }),

/***/ 190512:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(14864),
  meta: __webpack_require__(952068),
  runHandler: __webpack_require__(77928)
};


/***/ }),

/***/ 952068:
/***/ ((module) => {

module.exports = {
  command: "run",
  description: "Run a third-party command",
  builder: {},
  help: {
    usage: "truffle run [<command>]",
    options: [
      {
        option: "<command>",
        description: "Name of the third-party command to run."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 14864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async options => {
  const Run = __webpack_require__(77928);
  const { promisify } = __webpack_require__(473837);
  const Config = __webpack_require__(120553);
  const { checkPluginConfig } = __webpack_require__(443736);
  const config = Config.detect(options);

  if (options._.length === 0) {
    const { displayCommandHelp } = __webpack_require__(867340);
    await displayCommandHelp("run");
    return;
  }

  const customCommand = options._[0];

  checkPluginConfig(config);

  return await promisify(Run.run.bind(Run))(customCommand, config);
};


/***/ }),

/***/ 77928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Plugins } = __webpack_require__(342113);
const TruffleError = __webpack_require__(673321);

const Run = {
  // executes command or throws user helpful error
  run(customCommand, config, done) {
    const [foundPlugin] = Plugins.findPluginsForCommand(config, customCommand);

    if (!foundPlugin) {
      throw new TruffleError(
        `\nError: "${customCommand}" command not supported by any currently configured plugins. Please make sure:
  â€“ plugins are correctly configured in truffle-config.js
  â€“ the plugin supporting the command you want to use is installed\n`
      );
    }

    // Will throw an error if loading fails, indicating misconfiguration
    const runCommand = foundPlugin.loadCommand(customCommand);

    const commandResult = runCommand(config, done);
    if (commandResult && typeof commandResult.then === "function") {
      commandResult.then(() => done()).catch(err => done(err));
    }
  }
};

module.exports = Run;


/***/ }),

/***/ 193622:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const copyArtifactsToTempDir = async config => {
  const fse = __webpack_require__(655674);
  const OS = __webpack_require__(822037);
  const tmp = __webpack_require__(336276);
  tmp.setGracefulCleanup();

  // Copy all the built files over to a temporary directory, because we
  // don't want to save any tests artifacts. Only do this if the build directory
  // exists.
  const temporaryDirectory = tmp.dirSync({
    unsafeCleanup: true,
    prefix: "test-"
  }).name;
  try {
    fse.statSync(config.contracts_build_directory);
  } catch (_error) {
    return { temporaryDirectory };
  }

  fse.copySync(config.contracts_build_directory, temporaryDirectory);

  if (config.runnerOutputOnly !== true) {
    config.logger.log("Using network '" + config.network + "'." + OS.EOL);
  }
  return { temporaryDirectory };
};

module.exports = {
  copyArtifactsToTempDir
};


/***/ }),

/***/ 613799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const determineTestFilesToRun = ({ inputFile, inputArgs = [], config }) => {
  const path = __webpack_require__(371017);
  const fs = __webpack_require__(657147);
  const glob = __webpack_require__(312884);
  let filesToRun = [];

  if (inputFile) {
    filesToRun.push(inputFile);
  } else if (inputArgs.length > 0) {
    inputArgs.forEach(inputArg => filesToRun.push(inputArg));
  }

  if (filesToRun.length === 0) {
    const directoryContents = glob.sync(
      `${config.test_directory}${path.sep}**${path.sep}*`
    );
    filesToRun =
      directoryContents.filter(item => fs.statSync(item).isFile()) || [];
  }
  return filesToRun.filter(file => {
    return file.match(config.test_file_extension_regexp) !== null;
  });
};

module.exports = {
  determineTestFilesToRun
};


/***/ }),

/***/ 86067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(446394),
  meta: __webpack_require__(43059)
};


/***/ }),

/***/ 43059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);

module.exports = {
  command: "test",
  description: "Run JavaScript and Solidity tests",
  builder: {
    "show-events": {
      describe: "Show all test logs",
      type: "boolean",
      default: false
    },
    "compile-all-debug": {
      describe: "Compile in debug mode",
      type: "boolean",
      default: false
    },
    "debug": {
      describe: "Enable in-test debugging",
      type: "boolean",
      default: false
    },
    "debug-global": {
      describe: "Specify debug global function name",
      default: "debug"
    },
    "runner-output-only": {
      describe: "Suppress all output except for test runner output.",
      type: "boolean",
      default: false
    },
    "bail": {
      alias: "b",
      describe: "Bail after first test failure",
      type: "boolean",
      default: false
    },
    "stacktrace": {
      alias: "t",
      describe: "Produce Solidity stacktraces",
      type: "boolean",
      default: false
    },
    "stacktrace-extra": {
      describe: "Produce Solidity stacktraces and compile in debug mode",
      type: "boolean",
      default: false
    },
    "reporter": {
      alias: "r",
      describe: "Specify the type of mocha reporter",
      default: undefined
    }
  },
  help: {
    usage:
      `truffle test [<test_file>] [--compile-all[-debug]] [--compile-none] ` +
      `[--migrate-none] ` +
      `[--network <name>]${OS.EOL}                             ` +
      `[--verbose-rpc] [--show-events] [--debug] ` +
      `[--debug-global <identifier>] [--bail|-b]${OS.EOL}                      ` +
      `       [--stacktrace[-extra]] [--grep|-g <regex>] ` +
      `[--reporter|-r <name>] `,
    options: [
      {
        option: "<test_file>",
        description:
          "Name of the test file to be run. Can include path information if the file " +
          "does not exist in the\n                    current directory."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need " +
          "to be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before running the tests"
      },
      {
        option: "--compile-all-debug",
        description:
          "Compile all contracts and do so in debug mode for extra revert info.  May " +
          "cause errors on large\n                    contracts."
      },
      {
        option: "--migrate-none",
        description: "Do not migrate any contracts before running the tests."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--show-events",
        description: "Log all contract events."
      },
      {
        option: "--debug",
        description:
          "Provides global debug() function for in-test debugging. " +
          "JS tests only; implies --compile-all."
      },
      {
        option: "--debug-global <identifier>",
        description:
          'Specify global identifier for debug function. Default: "debug"'
      },
      {
        option: "--runner-output-only",
        description: "Suppress all output except for test runner output."
      },
      {
        option: "--bail|-b",
        description: "Bail after first test failure."
      },
      {
        option: "--stacktrace",
        description:
          "Allows for mixed JS/Solidity stacktraces when a Truffle Contract transaction " +
          "or deployment\n                    reverts.  Does not apply to calls or gas estimates.  " +
          "Implies --compile-all.  Experimental.  Alias: -t"
      },
      {
        option: "--stacktrace-extra",
        description: "Shortcut for --stacktrace --compile-all-debug."
      },
      {
        option: "--grep|-g",
        description:
          'Use mocha\'s "grep" option while running tests. This ' +
          "option only runs tests that match the supplied regex/string."
      },
      {
        option: "--reporter|-r <name>",
        description:
          "Specify the type of mocha reporter to use during testing. Default: 'spec'"
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 955472:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const prepareConfigAndRunTests = ({ config, temporaryDirectory, files }) => {
  const Artifactor = __webpack_require__(529463);
  const Test = __webpack_require__(952422);
  // Set a new artifactor; don't rely on the one created by Environments.
  // TODO: Make the test artifactor configurable.
  config.artifactor = new Artifactor(temporaryDirectory);

  const testConfig = config.with({
    test_files: files,
    contracts_build_directory: temporaryDirectory
  });
  return Test.run(testConfig);
};

module.exports = {
  prepareConfigAndRunTests
};


/***/ }),

/***/ 446394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parseCommandLineFlags = options => {
  // parse out command line flags to merge in to the config
  const grep = options.grep || options.g;
  const bail = options.bail || options.b;
  const reporter = options.reporter || options.r;

  /**
   * Reporter value passed on the command line has precedence over a reporter value in the config.
   * If neither exist, then nothing is passed to mocha and it uses its default reporter type "spec".
   * Note: It is important that reporter be completely omitted, and not be set to undefined!
   * As setting it to undefined will ignore the reporter value specified in the config.
   */
  return reporter === undefined
    ? { mocha: { grep, bail } }
    : { mocha: { grep, bail, reporter } };
};

module.exports = async function (options) {
  const Config = __webpack_require__(120553);
  const { Environment, Develop } = __webpack_require__(376765);
  const { copyArtifactsToTempDir } = __webpack_require__(193622);
  const { determineTestFilesToRun } = __webpack_require__(613799);
  const { prepareConfigAndRunTests } = __webpack_require__(955472);
  const { configureManagedGanache } = __webpack_require__(87088);

  const optionsToMerge = parseCommandLineFlags(options);
  const config = Config.detect(options).merge(optionsToMerge);

  // if "development" exists, default to using that for testing
  if (!config.network && config.networks.development) {
    config.network = "development";
  }

  if (!config.network) {
    config.network = "test";
  } else {
    await Environment.detect(config);
  }

  // Start managed ganache network
  async function startGanacheAndRunTests(ipcOptions, ganacheOptions, config) {
    const { disconnect } = await Develop.connectOrStart(
      ipcOptions,
      ganacheOptions
    );
    const ipcDisconnect = disconnect;
    await Environment.develop(config, ganacheOptions);
    const { temporaryDirectory } = await copyArtifactsToTempDir(config);
    const numberOfFailures = await prepareConfigAndRunTests({
      config,
      files,
      temporaryDirectory
    });
    ipcDisconnect();
    return numberOfFailures;
  }

  if (config.stacktraceExtra) {
    config.stacktrace = true;
    config.compileAllDebug = true;
  }
  // enables in-test debug() interrupt, or stacktraces, forcing compileAll
  if (config.debug || config.stacktrace || config.compileAllDebug) {
    config.compileAll = true;
  }

  const { file } = options;
  const inputArgs = options._;
  const files = determineTestFilesToRun({
    config,
    inputArgs,
    inputFile: file
  });

  const configuredNetwork = config.networks[config.network];
  const testNetworkDefinedAndUsed =
    configuredNetwork && config.network === "test";
  const noProviderHostOrUrlConfigured =
    configuredNetwork &&
    !configuredNetwork.provider &&
    !configuredNetwork.host &&
    !configuredNetwork.url;
  let numberOfFailures;

  if (
    (testNetworkDefinedAndUsed && noProviderHostOrUrlConfigured) ||
    !configuredNetwork
  ) {
    const defaultPort = await __webpack_require__(715959)();
    const defaultMnemonic =
      "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat";
    // configuredNetwork will spread only when it is defined and ignored when undefined
    const managedNetworkOptions = {
      port: defaultPort,
      ...configuredNetwork
    };

    const mnemonic = managedNetworkOptions.mnemonic || defaultMnemonic;
    const ganacheOptions = configureManagedGanache(
      config,
      managedNetworkOptions,
      mnemonic
    );

    const ipcOptions = { network: "test" };
    numberOfFailures = await startGanacheAndRunTests(
      ipcOptions,
      ganacheOptions,
      config
    );
  } else {
    // Use unmanaged network with user specified config if provider, host or url exists
    await Environment.detect(config);
    const { temporaryDirectory } = await copyArtifactsToTempDir(config);
    numberOfFailures = await prepareConfigAndRunTests({
      config,
      files,
      temporaryDirectory
    });
  }
  return numberOfFailures;
};


/***/ }),

/***/ 72995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(591283),
  meta: __webpack_require__(474292)
};


/***/ }),

/***/ 474292:
/***/ ((module) => {

module.exports = {
  command: "unbox",
  description: "Download a Truffle Box, a pre-built Truffle project",
  builder: {},
  help: {
    usage: "truffle unbox [<box_name>] [destination] [--force]",
    options: [
      {
        option: "destination",
        description:
          "Path to the directory in which you would like " +
          "to unbox the project files. If destination is\n                  " +
          "  not provided, this defaults to the current directory."
      },
      {
        option: "<box_name>",
        description:
          "Name of the truffle box. If no box_name is specified, a default " +
          "truffle box will be downloaded."
      },
      {
        option: "--force",
        description:
          "Unbox project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 591283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const normalizeDestination = (destination, workingDirectory) => {
  if (!destination) {
    return workingDirectory;
  }
  const path = __webpack_require__(371017);
  if (path.isAbsolute(destination)) return destination;
  return path.join(workingDirectory, destination);
};

module.exports = async options => {
  const Config = __webpack_require__(120553);
  const { default: Box } = __webpack_require__(221579);
  const fse = __webpack_require__(655674);

  const config = Config.default().with({ logger: console });
  // we merge in the options so that options passed on the command line
  // (for example --quiet) make it to the EventManager
  config.merge(options);

  let [url, destination] = options._;

  const normalizedDestination = normalizeDestination(
    destination,
    config.working_directory
  );

  fse.ensureDirSync(normalizedDestination);

  const unboxOptions = Object.assign({}, options, { logger: config.logger });

  config.events.emit("unbox:start");

  const boxConfig = await Box.unbox(
    url,
    normalizedDestination,
    unboxOptions,
    config
  );
  await config.events.emit("unbox:succeed", { boxConfig });
};


/***/ }),

/***/ 669037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(887365),
  meta: __webpack_require__(974770)
};


/***/ }),

/***/ 974770:
/***/ ((module) => {

module.exports = {
  command: "version",
  description: "Show version number and exit",
  builder: {},
  help: {
    usage: "truffle version",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 887365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const version = __webpack_require__(64146);
  const { logger } = options;

  const config = detectConfigOrDefault(options);

  version.logAll(logger, config);
  return;
};


/***/ }),

/***/ 536563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(915088),
  meta: __webpack_require__(847766)
};


/***/ }),

/***/ 847766:
/***/ ((module) => {

module.exports = {
  command: "watch",
  description:
    "Watch filesystem for changes and rebuild the project automatically",
  builder: {},
  help: {
    usage: "truffle watch",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 915088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(183196);
const commandExistsSync = (__webpack_require__(905497).sync);

module.exports = async function (options) {
  const OS = __webpack_require__(822037);
  const deprecationMessage = colors.yellow(
    `> The watch command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}` +
      `> See https://github.com/trufflesuite/truffle/issues/3227 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(120553);
  const sane = __webpack_require__(252817);
  const path = __webpack_require__(371017);

  const config = Config.detect(options);

  const watchOptions = {
    ignored: [
      "build/**/**",
      /[/\\]\./ // Ignore files prefixed with .
    ]
  };
  // Certain large codebases have trouble with the watch command.
  // Installing watchman resolves some of these issues.
  if (commandExistsSync("watchman")) {
    watchOptions.watchman = true;
  } else {
    config.logger.log(
      "If you have trouble using watch, try installing watchman."
    );
  }

  const watchCallback = filePath => {
    const displayPath = path.join(
      "./",
      filePath.replace(config.working_directory, "")
    );
    config.logger.log(colors.cyan(">> File " + displayPath + " changed."));

    build(config);
  };

  const watcher = sane(config.working_directory, watchOptions);
  watcher.on("change", watchCallback);
  watcher.on("add", watchCallback);
  watcher.on("delete", watchCallback);

  config.logger.log(colors.green("Watching for a change in project files..."));
  return new Promise(() => {});
};

const build = config => {
  const Build = __webpack_require__(523525);

  config.logger.log("Rebuilding...");

  Build.build(config, function (error) {
    printSummary(config, error);
  });
};

const printSummary = (config, error) => {
  if (error) {
    const TruffleError = __webpack_require__(673321);
    if (error instanceof TruffleError) {
      console.log(error.message);
    } else {
      // Bubble up all other unexpected errors.
      console.log(error.stack || error.toString());
    }
  } else {
    config.logger.log(
      colors.green("Completed without errors on " + new Date().toString())
    );
  }
};


/***/ }),

/***/ 199043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(822037);
const path = __webpack_require__(371017);
const fse = __webpack_require__(655674);
const Conf = __webpack_require__(719658);
const TruffleConfig = __webpack_require__(120553);
const debugModule = __webpack_require__(615158);
const debug = debugModule("core:config-migration");

const CURRENT_CONFIG_VERSION = 1;

module.exports = {
  oldTruffleDataDirectory: path.join(OS.homedir(), ".config", "truffle"),

  needsMigrated: function () {
    const conf = new Conf({ projectName: "truffle" });
    if (conf.get("version") === CURRENT_CONFIG_VERSION) return false;
    const oldConfig = path.join(this.oldTruffleDataDirectory, "config.json");
    if (fse.existsSync(oldConfig) && oldConfig !== conf.path) {
      // we are on Windows or a Mac
      return true;
    } else {
      // we are on Linux or previous config doesn't exist and we don't need to
      // perform a migration - current version set to designates success
      conf.set("version", CURRENT_CONFIG_VERSION);
      return false;
    }
  },

  migrateTruffleDataIfNecessary: async function () {
    if (!this.needsMigrated()) return;
    debug("Truffle files need to be migrated");
    const conf = this.migrateGlobalConfig();
    debug("successfully migrated global config");
    const folders = ["compilers", ".db"];
    for (const folder of folders) {
      await this.migrateFolder(folder);
      debug("successfully migrated folder: %o", folder);
    }
    // set version to current only after migration is complete to designate success
    conf.set("version", CURRENT_CONFIG_VERSION);
  },

  migrateGlobalConfig: function () {
    const conf = new Conf({ projectName: "truffle" });
    const oldSettings = __webpack_require__(518727)(path.join(
      this.oldTruffleDataDirectory,
      "config.json"
    ));
    for (const key in oldSettings) {
      conf.set(key, oldSettings[key]);
    }
    return conf;
  },

  migrateFolder: async function (folderName) {
    const targetPath = path.join(this.oldTruffleDataDirectory, folderName);
    // use conf to determine the new Truffle folder as it uses OS-appropriate locations
    const conf = new Conf({ projectName: "truffle" });
    const destinationPath = path.join(TruffleConfig.getTruffleDataDirectory(), folderName);
    if (fse.existsSync(targetPath)) {
      fse.copySync(targetPath, destinationPath);
    }
  }
};


/***/ }),

/***/ 87088:
/***/ ((module) => {

function resolveNetworkId(network_id) {
  // Use default network_id if "*" is defined in config
  if (network_id === "*") {
    return Date.now();
  }

  const parsedNetworkId = parseInt(network_id, 10);
  if (isNaN(parsedNetworkId)) {
    const error =
      `The network id specified in the truffle config ` +
      `(${network_id}) is not valid. Please properly configure the network id as an integer value.`;
    throw new Error(error);
  }

  return parsedNetworkId;
}

// This function returns the first defined argument value
const getFirstDefinedValue = (...values) =>
  values.find(value => value !== undefined);

function configureManagedGanache(config, networkConfig, mnemonic) {
  const host = getFirstDefinedValue(
    networkConfig.host,
    "127.0.0.1" // Use as default host
  );

  const port = getFirstDefinedValue(
    networkConfig.port,
    9545 // Use as default port
  );

  const network_id = getFirstDefinedValue(
    networkConfig.network_id,
    5777 // Use as default network_id
  );
  const resolvedNetworkId = resolveNetworkId(network_id);

  const total_accounts = getFirstDefinedValue(
    networkConfig.accounts,
    networkConfig.total_accounts,
    10 // Use as default number of accounts
  );

  const default_balance_ether = getFirstDefinedValue(
    networkConfig.defaultEtherBalance,
    networkConfig.default_balance_ether,
    100 // Use as default ether balance for each account
  );

  const blockTime = getFirstDefinedValue(
    networkConfig.blockTime,
    0 // Use as default block time
  );

  const gasLimit = getFirstDefinedValue(
    networkConfig.gasLimit,
    0x6691b7 // Use as default gasLimit
  );

  const gasPrice = getFirstDefinedValue(
    networkConfig.gasPrice,
    0x77359400 // Use default gas price 2000000000 wei
  );

  const genesisTime = getFirstDefinedValue(
    // Higher precedence is given to the networkConfig.time or networkConfig.genesis_time
    networkConfig.time,
    networkConfig.genesis_time,
    config.time,
    config.genesis_time
  );

  const fork = networkConfig.fork;
  const hardfork = networkConfig.hardfork;

  const ganacheOptions = {
    host,
    port,
    network_id: resolvedNetworkId,
    total_accounts,
    default_balance_ether,
    blockTime,
    fork,
    hardfork,
    mnemonic,
    gasLimit,
    gasPrice,
    time: genesisTime,
    miner: {
      instamine: "strict"
    }
  };

  return ganacheOptions;
}

module.exports = { configureManagedGanache, getFirstDefinedValue };


/***/ }),

/***/ 968303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const repl = __webpack_require__(438102);
const Command = __webpack_require__(651017);
const provision = __webpack_require__(207702);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(936339);
const contract = __webpack_require__(378883);
const vm = __webpack_require__(626144);
const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const fse = __webpack_require__(655674);
const path = __webpack_require__(371017);
const EventEmitter = __webpack_require__(582361);
const spawnSync = (__webpack_require__(532081).spawnSync);
const Require = __webpack_require__(868992);
const debug = __webpack_require__(615158)("console");

const processInput = input => {
  const inputComponents = input.trim().split(" ");
  if (inputComponents.length === 0) return input;

  if (inputComponents[0] === "truffle") {
    return inputComponents.slice(1).join(" ");
  }
  return input.trim();
};

class Console extends EventEmitter {
  constructor(tasks, options) {
    super();
    EventEmitter.call(this);

    expect.options(options, [
      "working_directory",
      "contracts_directory",
      "contracts_build_directory",
      "migrations_directory",
      "networks",
      "network",
      "network_id",
      "provider",
      "resolver",
      "build_directory"
    ]);

    this.options = options;

    this.command = new Command(tasks);

    this.repl = null;

    this.interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    this.web3 = new Web3Shim({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
  }

  async start() {
    try {
      // start the repl with an empty prompt and show a proper one when
      // the repl has set up its context and is ready to accept input
      this.repl = repl.start({
        prompt: "",
        eval: this.interpret.bind(this)
      });

      // Get and set Truffle and User Globals
      const truffleAndUserGlobals = await this.calculateTruffleAndUserGlobals();
      Object.entries(truffleAndUserGlobals).forEach(([key, value]) => {
        this.repl.context[key] = value;
      });

      // repl is ready - set and display prompt
      this.repl.setPrompt("truffle(" + this.options.network + ")> ");
      this.repl.displayPrompt();

      // hydrate the environment with the user's contracts
      this.provision();

      this.repl.on("exit", () => {
        process.exit();
      });

      // ensure that `await`-ing this method never resolves. (we want to keep
      // the console open until it exits on its own)
      return new Promise(() => {});
    } catch (error) {
      this.options.logger.log(
        "Unexpected error setting up the environment or provisioning " +
          "contracts while instantiating the console."
      );
      this.options.logger.log(error.stack || error.message || error);
    }
  }

  getUserDefinedGlobals({ accounts, interfaceAdapter, web3 }) {
    // exit if feature should be disabled
    if (this.options["require-none"]) return;

    // exit if no hydrate options are set
    if (
      (!this.options.console || !this.options.console.require) &&
      !this.options.require &&
      !this.options.r
    )
      return;

    const addToContext = (context, userData, namespace) => {
      for (const key in userData) {
        if (namespace) {
          if (typeof context[namespace] === "undefined") {
            context[namespace] = {};
          }
          context[namespace][key] = userData[key];
        } else {
          context[key] = userData[key];
        }
      }
    };
    const errorMessage =
      "You must specify the console.require property as " +
      "either a string or an array. If you specify an array, its members " +
      "must be paths or objects containing at least a `path` property.";

    const requireValue =
      this.options.r || this.options.require || this.options.console.require;

    // Require allows us to inject Truffle variables into the script's scope
    const requireOptions = {
      context: {
        accounts,
        interfaceAdapter,
        web3
      }
    };
    const userGlobals = {};
    if (typeof requireValue === "string") {
      requireOptions.file = requireValue;
      addToContext(userGlobals, Require.file(requireOptions));
    } else if (Array.isArray(requireValue)) {
      this.options.console.require.forEach(item => {
        if (typeof item === "string") {
          requireOptions.file = item;
          addToContext(userGlobals, Require.file(requireOptions));
        } else if (typeof item === "object" && item.path) {
          requireOptions.file = item.path;
          addToContext(userGlobals, Require.file(requireOptions), item.as);
        } else {
          throw new Error(errorMessage);
        }
      });
    } else {
      throw new Error(errorMessage);
    }
    return userGlobals;
  }

  async calculateTruffleAndUserGlobals() {
    let accounts;
    try {
      accounts = await this.interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }

    const userGlobals = this.getUserDefinedGlobals({
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts
    });

    const truffleGlobals = {
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts
    };

    // we insert user variables first so as to not clobber Truffle's
    return {
      ...userGlobals,
      ...truffleGlobals
    };
  }

  provision() {
    let files;
    try {
      const unfilteredFiles = fse.readdirSync(
        this.options.contracts_build_directory
      );
      files = unfilteredFiles.filter(file => file.endsWith(".json"));
    } catch (error) {
      // Error reading the build directory? Must mean it doesn't exist or we don't have access to it.
      // Couldn't provision the contracts if we wanted. It's possible we're hiding very rare FS
      // errors, but that's better than showing the user error messages that will be "build folder
      // doesn't exist" 99.9% of the time.
    }

    let jsonBlobs = [];
    files = files || [];

    files.forEach(file => {
      try {
        const body = fse.readFileSync(
          path.join(this.options.contracts_build_directory, file),
          "utf8"
        );
        jsonBlobs.push(JSON.parse(body));
      } catch (error) {
        throw new Error(`Error parsing or reading ${file}: ${error.message}`);
      }
    });

    const abstractions = jsonBlobs.map(json => {
      const abstraction = contract(json);
      provision(abstraction, this.options);
      return abstraction;
    });

    this.resetContractsInConsoleContext(abstractions);
    return abstractions;
  }

  resetContractsInConsoleContext(abstractions) {
    abstractions = abstractions || [];

    const contextVars = {};

    abstractions.forEach(abstraction => {
      contextVars[abstraction.contract_name] = abstraction;
    });

    // make sure the repl gets the new contracts in its context
    Object.keys(contextVars || {}).forEach(key => {
      this.repl.context[key] = contextVars[key];
    });
  }

  runSpawn(inputStrings, options) {
    let childPath;
    /* eslint-disable no-undef */
    if (true) {
      childPath = path.join(__dirname, "consoleChild.bundled.js");
    } else {}

    // stderr is piped here because we don't need to repeatedly see the parent
    // errors/warnings in child process - specifically the error re: having
    // multiple config files
    const spawnOptions = { stdio: ["inherit", "inherit", "pipe"] };
    const settings = ["config", "network"]
      .filter(setting => options[setting])
      .map(setting => `--${setting} ${options[setting]}`)
      .join(" ");

    const spawnInput = `${settings} -- ${inputStrings}`;

    const spawnResult = spawnSync(
      "node",
      ["--no-deprecation", childPath, spawnInput],
      spawnOptions
    );

    if (spawnResult.stderr) {
      // Theoretically stderr can contain multiple errors.
      // So let's just print it instead of throwing through
      // the error handling mechanism. Bad call?
      debug(spawnResult.stderr.toString());
    }

    // re-provision to ensure any changes are available in the repl
    this.provision();

    //display prompt when child repl process is finished
    this.repl.displayPrompt();
  }

  interpret(input, context, filename, callback) {
    const processedInput = processInput(input);
    if (
      this.command.getCommand(processedInput, this.options.noAliases) != null
    ) {
      try {
        this.runSpawn(processedInput, this.options);
      } catch (error) {
        // Perform error handling ourselves.
        if (error instanceof TruffleError) {
          console.log(error.message);
        } else {
          // Bubble up all other unexpected errors.
          console.log(error.stack || error.toString());
        }
        return callback();
      }

      // Reprovision after each command as it may change contracts.
      try {
        this.provision();
        return callback();
      } catch (error) {
        // Don't pass abstractions to the callback if they're there or else
        // they'll get printed in the repl.
        return callback(error);
      }
    }

    // Much of the following code is from here, though spruced up:
    // https://github.com/nfcampos/await-outside

    /*
    - allow whitespace before everything else
    - optionally capture `var|let|const <varname> = `
      - varname only matches if it starts with a-Z or _ or $
        and if contains only those chars or numbers
      - this is overly restrictive but is easier to maintain
    - capture `await <anything that follows it>`
    */
    let includesAwait =
      /^\s*((?:(?:var|const|let)\s+)?[a-zA-Z_$][0-9a-zA-Z_$]*\s*=\s*)?(\(?\s*await[\s\S]*)/;

    const match = processedInput.match(includesAwait);
    let source = processedInput;
    let assignment = null;

    // If our code includes an await, add special processing to ensure it's evaluated properly.
    if (match) {
      let assign = match[1];

      const expression =
        match[2] && match[2].endsWith(";")
          ? // strip off trailing ";" to prevent the expression below from erroring
            match[2].slice(0, -1)
          : match[2];

      const RESULT = "__await_outside_result";

      // Wrap the await inside an async function.
      // Strange indentation keeps column offset correct in stack traces
      source = `(async function() { try { ${
        assign ? `global.${RESULT} =` : "return"
      } (
  ${expression.trim()}
  ); } catch(e) { global.ERROR = e; throw e; } }())`;

      assignment = assign
        ? `${assign.trim()} global.${RESULT}; void delete global.${RESULT};`
        : null;
    }

    const runScript = script => {
      const options = {
        displayErrors: true,
        breakOnSigint: true,
        filename: filename
      };

      vm.createContext(context);
      return script.runInContext(context, options);
    };

    let script;
    try {
      const options = { displayErrors: true, lineOffset: -1 };
      script = vm.createScript(source, options);
    } catch (error) {
      // If syntax error, or similar, bail.
      return callback(error);
    }

    // Ensure our script returns a promise whether we're using an
    // async function or not. If our script is an async function,
    // this will ensure the console waits until that await is finished.
    Promise.resolve(runScript(script))
      .then(value => {
        // If there's an assignment to run, run that.
        if (assignment) return runScript(vm.createScript(assignment));
        return value;
      })
      .then(value => {
        // All good? Return the value (e.g., eval'd script or assignment)
        callback(null, value);
      })
      .catch(callback);
  }
}

module.exports = Console;


/***/ }),

/***/ 209941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { CLIDebugger } = __webpack_require__(900458);

module.exports = {
  CLIDebugger
};


/***/ }),

/***/ 48937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TruffleError = __webpack_require__(673321);

class ConfigurationError extends TruffleError {
  constructor(message) {
    super(message);
  }
}

module.exports = ConfigurationError;


/***/ }),

/***/ 699079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TruffleError = __webpack_require__(673321);

class TaskError extends TruffleError {
  constructor(message) {
    super(message);
  }
}

module.exports = TaskError;


/***/ }),

/***/ 225603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module mnemonic;
 * @requires module:@truffle/config
 * @requires module:seedrandom
 * @requires module:ethereum-cryptography
 * @requires module:ethereumjs-wallet/hdkey
 * @requires module:crypto
 */

const Config = __webpack_require__(120553);
const defaultUserConfig = Config.getUserConfig();
const {
  entropyToMnemonic,
  mnemonicToSeedSync
} = __webpack_require__(389211);
const { wordlist } = __webpack_require__(648732);
const { hdkey } = __webpack_require__(938427);
const crypto = __webpack_require__(706113);

const mnemonic = {
  /**
   * gets user-level mnemonic from user config, and if missing generates a new mnemonic
   * @returns {String} mnemonic
   */
  getOrGenerateMnemonic: function () {
    let mnemonic;
    const userMnemonicExists = defaultUserConfig.get("mnemonic");
    if (!userMnemonicExists) {
      mnemonic = entropyToMnemonic(crypto.randomBytes(16), wordlist);
      defaultUserConfig.set({ mnemonic: mnemonic });
    } else {
      mnemonic = userMnemonicExists;
    }

    return mnemonic;
  },

  /**
   * gets accounts object using mnemonic
   * @param {String}
   * @returns {Object} mnemonicObject
   */
  getAccountsInfo: function (numAddresses) {
    let mnemonic = this.getOrGenerateMnemonic();
    let accounts = [];
    let privateKeys = [];

    let hdwallet = hdkey.fromMasterSeed(
      Buffer.from(mnemonicToSeedSync(mnemonic))
    );
    let addressIndex = 0;
    let walletHdpath = "m/44'/60'/0'/0/";

    for (let i = addressIndex; i < addressIndex + numAddresses; i++) {
      let wallet = hdwallet.derivePath(walletHdpath + i).getWallet();
      let addr = "0x" + wallet.getAddress().toString("hex");
      let privKey = wallet.getPrivateKey().toString("hex");
      accounts.push(addr);
      privateKeys.push(privKey);
    }

    return {
      mnemonic,
      accounts,
      privateKeys
    };
  }
};

module.exports = mnemonic;


/***/ }),

/***/ 902860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module googleAnalytics;
 * @requires module:@truffle/config
 * @requires module:universal-analytics
 * @requires module:uuid
 * @requires module:inquirer
 * @requires module:../version
 */

const Config = __webpack_require__(120553);
const userConfig = Config.getUserConfig();
const ua = __webpack_require__(340387);
const uuid = __webpack_require__(171171);

const inquirer = __webpack_require__(496062);

const version = (__webpack_require__(64146).info)();

//set truffleAnalyticsId depending on whether version is bundled
const truffleAnalyticsId = version.bundle ? "UA-83874933-6" : "UA-83874933-7";

const analyticsInquiry = [
  {
    type: "list",
    name: "analyticsInquiry",
    message:
      "Would you like to enable analytics for your Truffle projects? Doing so will allow us to make sure Truffle is working as expected and help us address any bugs more efficiently.",
    choices: ["Yes, enable analytics", "No, do not enable analytics"]
  }
];
const analyticsDisable = [
  {
    type: "confirm",
    name: "analyticsDisable",
    message: "Analytics are currently enabled. Would you like to disable them?",
    default: false
  }
];
const analyticsEnable = [
  {
    type: "confirm",
    name: "analyticsEnable",
    message: "Analytics are currently disabled. Would you like to enable them?",
    default: false
  }
];

const googleAnalytics = {
  /**
   * set user-level unique id
   */
  setUserId: function() {
    if (!userConfig.get("uniqueId")) {
      let userId = uuid();
      userConfig.set({ uniqueId: userId });
    }
  },
  /**
   * get user-level options for analytics
   * @param {Object} userConfig
   * @returns {bool}
   */
  getAnalytics: function() {
    return userConfig.get("enableAnalytics");
  },
  /**
   * set user-level options for analytics
   * @param {bool} analyticsBool
   * @param {Object} userConfig
   */
  setAnalytics: function(analyticsBool) {
    if (analyticsBool === true) {
      this.setUserId();
      console.log('Analytics enabled');
      userConfig.set({
        enableAnalytics: true,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else if (analyticsBool === false) {
      console.log('Analytics disabled');
      userConfig.set({
        enableAnalytics: false,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else {
      const message =
        `Error setting config option.` +
        `\n> You must set the 'analytics' option to either 'true' ` +
        `or 'false'. \n> The value you provided was ${analyticsBool}.`;
      throw new Error(message);
    }
    return true;
  },
  /**
   * prompt user to determine values for user-level analytics config options
   * @param {Object} userConfig
   */
  setUserConfigViaPrompt: async function() {
    if (!userConfig.get("analyticsSet") && process.stdin.isTTY === true) {
      let answer = await inquirer.prompt(analyticsInquiry);
      if (answer.analyticsInquiry === analyticsInquiry[0].choices[0]) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    } else if (
      userConfig.get("analyticsSet") &&
      userConfig.get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsDisable);
      if (answer.analyticsDisable) {
        this.setAnalytics(false);
      } else {
        this.setAnalytics(true);
      }
    } else if (
      userConfig.get("analyticsSet") &&
      !userConfig.get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsEnable);
      if (answer.analyticsEnable) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    }
    return true;
  },
  /**
   * check user-level config to see if user has enabled analytics
   * @returns {bool}
   */
  checkIfAnalyticsEnabled: function() {
    if (userConfig.get("enableAnalytics")) {
      return true;
    } else {
      return false;
    }
  },

  /**
   * set data that will be the same in future calls
   * @returns {Object} visitor
   */
  setPersistentAnalyticsData: function() {
    if (this.checkIfAnalyticsEnabled() === true) {
      let userId = userConfig.get("uniqueId");
      let visitor = ua(truffleAnalyticsId, { cid: userId });
      return visitor;
    }
  },

  /**
   * send event to Google Analytics
   * @param {Object}
   */
  // eslint-disable-next-line no-unused-vars
  sendAnalyticsEvent: function(eventObject, callback) {
    let visitor = this.setPersistentAnalyticsData();
    let sendObject = {};
    if (eventObject["command"]) {
      sendObject["ec"] = eventObject["command"];
      sendObject["ea"] = JSON.stringify(eventObject["args"]);
      sendObject["el"] = eventObject["version"];
      sendObject["dp"] = "/" + eventObject["command"];
    } else {
      sendObject["ec"] = "Error";
      sendObject["ea"] = "nonzero exit code";
      sendObject["el"] =
        eventObject["version"] + " " + eventObject["exception"];
      sendObject["dp"] = "/error";
    }

    if (visitor) {
      // eslint-disable-next-line no-unused-vars
      visitor.event(sendObject, function(err) {});
    }

    return true;
  }
};

module.exports = googleAnalytics;


/***/ }),

/***/ 54708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Extracts the input flags --option from the arguments  of type `--option=value` or `--option value` or `--flag`
const extractFlags = inputArguments => {
  // Get all the args that begins with `--`. This also includes `--option=value`
  const inputFlags = inputArguments.filter(flag => {
    return flag.startsWith("--") ? flag : null;
  });

  // Extract only the flags i.e `--option` from `--option=value`
  inputFlags.map((flag, i) => {
    let indexOfEqualsSign = flag.indexOf("=");
    if (indexOfEqualsSign > 0) {
      flag = flag.slice(0, indexOfEqualsSign);
      inputFlags.splice(i, 1, flag);
    }
  });
  return inputFlags;
};

const detectConfigOrDefault = options => {
  const Config = __webpack_require__(120553);

  try {
    return Config.detect(options);
  } catch (error) {
    // Suppress error when truffle can't find a config
    if (error.message === "Could not find suitable configuration file.") {
      return Config.default();
    } else {
      throw error;
    }
  }
};

module.exports = { extractFlags, detectConfigOrDefault };


/***/ }),

/***/ 64146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const pkg = __webpack_require__(373755);
const { CompilerSupplier } = __webpack_require__(4273);
const Config = __webpack_require__(120553);

const info = config => {
  let bundleVersion;
  // NOTE: Webpack will replace BUNDLE_VERSION with a string.
  if (true) bundleVersion = "5.5.15";

  let supplierOptions;
  if (config && config.compilers) {
    supplierOptions = {
      events: config.events,
      solcConfig: config.compilers.solc
    };
  } else {
    const { events, compilers } = new Config();
    const solcConfig = compilers.solc;
    supplierOptions = { events, solcConfig };
  }
  const supplier = new CompilerSupplier(supplierOptions);

  return {
    core: pkg.version,
    bundle: bundleVersion,
    solc: supplier.version
  };
};

const logTruffle = (logger = console, versionInformation) => {
  const bundle = versionInformation.bundle
    ? `v${versionInformation.bundle}`
    : "(unbundled)";
  logger.log(`Truffle ${bundle} (core: ${versionInformation.core})`);
};

const logNode = (logger = console) => {
  logger.log(`Node ${process.version}`);
};

const logSolidity = (logger = console, versionInformation, config) => {
  let solcVersion;
  if (
    config &&
    config.compilers &&
    config.compilers.solc &&
    config.compilers.solc.version
  ) {
    solcVersion = config.compilers.solc.version;
    logger.log(`Solidity - ${solcVersion} (solc-js)`);
  } else {
    const versionInformation = info(config);
    solcVersion = versionInformation.solc;
    logger.log(`Solidity v${solcVersion} (solc-js)`);
  }
};

const logWeb3 = (logger = console) => {
  const web3Version = pkg.dependencies.web3;
  logger.log(`Web3.js v${web3Version}`);
};

const logGanache = (logger = console) => {
  const ganacheVersion = pkg.dependencies.ganache;
  logger.log(`Ganache v${ganacheVersion}`);
};

const logAll = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logGanache(logger);
  logSolidity(logger, versionInformation, config);
  logNode(logger);
  logWeb3(logger);
};

const logTruffleAndNode = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logNode(logger);
};

module.exports = {
  logAll,
  info,
  logTruffleAndNode
};


/***/ }),

/***/ 386927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { IPC } = __webpack_require__(775898);
const path = __webpack_require__(371017);
const { spawn } = __webpack_require__(532081);
const debug = __webpack_require__(615158);

const Develop = {
  start: async function (ipcNetwork, options = {}) {
    let chainPath;

    // The path to the dev env process depends on whether or not
    // we're running in the bundled version. If not, use chain.js
    // directly, otherwise let the bundle point at the bundled version.
    if (true) {
      // Remember: In the bundled version, __dirname refers to the
      // build directory where cli.bundled.js and cli.chain.js live.
      chainPath = path.join(__dirname, "chain.bundled.js");
    } else {}

    const logger = options.logger || console;
    //check that genesis-time config option passed through the truffle-config.js file is a valid time.
    if (options.time && isNaN(Date.parse(options.time))) {
      options.time = Date.now();
      logger.log(
        "\x1b[31m%s\x1b[0m",
        "Invalid Date passed to genesis-time, using current Date instead",
        "\x1b[0m"
      );
    }

    const stringifiedOptions = JSON.stringify(options);
    const optionsBuffer = Buffer.from(stringifiedOptions);
    const base64OptionsString = optionsBuffer.toString("base64");

    return spawn("node", [chainPath, ipcNetwork, base64OptionsString], {
      detached: true,
      stdio: "ignore"
    });
  },

  connect: function (options) {
    const debugServer = debug("develop:ipc:server");
    const debugClient = debug("develop:ipc:client");
    const debugRPC = debug("develop:ganache");

    options.retry = options.retry || false;
    options.log = options.log || false;
    options.network = options.network || "develop";
    var ipcNetwork = options.network;

    var ipc = new IPC();
    ipc.config.appspace = "truffle.";

    // set connectPath explicitly
    var dirname = ipc.config.socketRoot;
    var basename = `${ipc.config.appspace}${ipcNetwork}`;
    var connectPath = path.join(dirname, basename);

    ipc.config.silent = !debugClient.enabled;
    ipc.config.logger = debugClient;

    var loggers = {};

    if (debugServer.enabled) {
      loggers.ipc = debugServer;
    }

    if (options.log) {
      debugRPC.enabled = true;

      loggers.ganache = function () {
        // HACK-y: replace `{}` that is getting logged instead of ""
        var args = Array.prototype.slice.call(arguments);
        if (
          args.length === 1 &&
          typeof args[0] === "object" &&
          Object.keys(args[0]).length === 0
        ) {
          args[0] = "";
        }

        debugRPC.apply(undefined, args);
      };
    }

    if (!options.retry) {
      ipc.config.maxRetries = 0;
    }

    var disconnect = function () {
      ipc.disconnect(ipcNetwork);
    };

    return new Promise((resolve, reject) => {
      ipc.connectTo(ipcNetwork, connectPath, function () {
        ipc.of[ipcNetwork].on("destroy", function () {
          reject(new Error("IPC connection destroyed"));
        });

        ipc.of[ipcNetwork].on("truffle.ready", function () {
          resolve(disconnect);
        });

        Object.keys(loggers).forEach(function (key) {
          var log = loggers[key];
          if (log) {
            var message = `truffle.${key}.log`;
            ipc.of[ipcNetwork].on(message, log);
          }
        });
      });
    });
  },

  connectOrStart: async function (options, ganacheOptions) {
    options.retry = false;

    const ipcNetwork = options.network || "develop";

    let started = false;
    let disconnect;

    try {
      disconnect = await this.connect(options);
    } catch (_error) {
      await this.start(ipcNetwork, ganacheOptions);
      options.retry = true;
      disconnect = await this.connect(options);
      started = true;
    } finally {
      return {
        disconnect,
        started
      };
    }
  }
};

module.exports = Develop;


/***/ }),

/***/ 753234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Web3 = __webpack_require__(503283);
const { createInterfaceAdapter } = __webpack_require__(936339);
const expect = __webpack_require__(414096);
const TruffleError = __webpack_require__(673321);
const { Resolver } = __webpack_require__(648511);
const Artifactor = __webpack_require__(529463);
const Ganache = __webpack_require__(711651);
const Provider = __webpack_require__(200509);

const Environment = {
  // It's important config is a Config object and not a vanilla object
  detect: async function (config) {
    expect.options(config, ["networks"]);

    helpers.setUpConfig(config);
    helpers.validateNetworkConfig(config);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    await Provider.testConnection(config);
    await helpers.detectAndSetNetworkId(config, interfaceAdapter);
    await helpers.setFromOnConfig(config, interfaceAdapter);
  },

  // Ensure you call Environment.detect() first.
  fork: async function (config, ganacheOptions) {
    expect.options(config, ["from", "provider", "networks", "network"]);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    let accounts;
    try {
      accounts = await interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }
    const block = await interfaceAdapter.getBlock("latest");

    const upstreamNetwork = config.network;
    const upstreamConfig = config.networks[upstreamNetwork];
    const forkedNetwork = config.network + "-fork";
    ganacheOptions = {
      ...ganacheOptions,
      fork: config.provider,
      gasLimit: block.gasLimit
    };
    if (accounts.length > 0) ganacheOptions.unlocked_accounts = accounts;

    config.networks[forkedNetwork] = {
      network_id: config.network_id,
      provider: Ganache.provider(ganacheOptions),
      from: config.from,
      gas: upstreamConfig.gas,
      gasPrice: upstreamConfig.gasPrice
    };
    config.network = forkedNetwork;
  },

  develop: async (config, ganacheOptions) => {
    expect.options(config, ["networks"]);

    const network = config.network || "develop";
    const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

    config.networks[network] = {
      ...config.networks[network],
      network_id: ganacheOptions.network_id,
      provider: function () {
        return new Web3.providers.HttpProvider(url, { keepAlive: false });
      }
    };

    config.network = network;

    return await Environment.detect(config);
  }
};

const helpers = {
  setFromOnConfig: async (config, interfaceAdapter) => {
    if (config.from) return;

    try {
      const accounts = await interfaceAdapter.getAccounts();
      config.networks[config.network].from = accounts[0];
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
    }
  },

  detectAndSetNetworkId: async (config, interfaceAdapter) => {
    const configNetworkId = config.networks[config.network].network_id;
    const providerNetworkId = await interfaceAdapter.getNetworkId();
    if (configNetworkId !== "*") {
      // Ensure the network id matches the one in the config for safety
      if (providerNetworkId.toString() !== configNetworkId.toString()) {
        const error =
          `The network id specified in the truffle config ` +
          `(${configNetworkId}) does not match the one returned by the network ` +
          `(${providerNetworkId}).  Ensure that both the network and the ` +
          `provider are properly configured.`;
        throw new Error(error);
      }
    } else {
      // We have a "*" network. Get the current network and replace it with the real one.
      // TODO: Should we replace this with the blockchain uri?
      config.networks[config.network].network_id = providerNetworkId;
    }
  },

  validateNetworkConfig: config => {
    const networkConfig = config.network_config;

    if (!networkConfig) {
      throw new TruffleError(
        `Unknown network "${config.network}` +
          `". See your Truffle configuration file for available networks.`
      );
    }

    const configNetworkId = config.network_config.network_id;

    if (configNetworkId == null) {
      throw new Error(
        `You must specify a network_id in your '` +
          `${config.network}' configuration in order to use this network.`
      );
    }
  },

  setUpConfig: config => {
    if (!config.resolver) {
      config.resolver = new Resolver(config);
    }

    if (!config.artifactor) {
      config.artifactor = new Artifactor(config.contracts_build_directory);
    }

    if (!config.network) {
      if (config.networks["development"]) {
        config.network = "development";
      } else {
        config.network = "ganache";
        config.networks[config.network] = {
          host: "127.0.0.1",
          port: 7545,
          network_id: 5777
        };
      }
    }

    const currentNetworkSettings = config.networks[config.network];
    if (
      currentNetworkSettings &&
      currentNetworkSettings.ens &&
      currentNetworkSettings.ens.registry
    ) {
      config.ens.registryAddress = currentNetworkSettings.ens.registry.address;
    }
  }
};

module.exports = Environment;


/***/ }),

/***/ 376765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Environment = __webpack_require__(753234);
const Develop = __webpack_require__(386927);

module.exports = { Environment, Develop };


/***/ }),

/***/ 221579:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSourcePath = void 0;
const utils_1 = __importDefault(__webpack_require__(326086));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
const config_1 = __importDefault(__webpack_require__(120553));
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const inquirer_1 = __importDefault(__webpack_require__(496062));
const debug_1 = __importDefault(__webpack_require__(615158));
const debug = debug_1.default("unbox");
const defaultPath = "git@github.com:trufflesuite/truffle-init-default";
/*
 * accepts a number of different url and org/repo formats and returns the
 * format required by https://www.npmjs.com/package/download-git-repo for remote URLs
 * or absolute path to local folder if the source is local folder
 *
 * supported input formats are as follows:
 *   - org/repo[#branch]
 *   - https://github.com(/|:)<org>/<repo>[.git][#branch]
 *   - git@github.com:<org>/<repo>[#branch]
 *   - path to local folder (absolute, relative or ~/home)
 */
const normalizeSourcePath = (url = defaultPath) => {
    // Process filepath resolution
    //
    if (url.startsWith(".") || url.startsWith("/") || url.startsWith("~")) {
        debug({ in: url, out: path_1.default.normalize(url) });
        return path_1.default.resolve(path_1.default.normalize(url));
    }
    // preprocess to reduce regex complexity
    // `https` is not case sensitiv, unlike `git`
    url = url.replace(/^https/i, "https");
    // branch should not end with slash
    const invalidBranch = /\/$/;
    // process https? or git prefixed input
    //
    if (/^(https?|git)/i.test(url)) {
        // This regular expression uses named capture groups to parse input. The
        // format is (?<the-name>the-regex)
        //
        // \w, the word meta character is a member of [A-Za-z0-9_]. all letters,
        // digits and the underscore. Note \w has to be \\w to escape the backslash
        // in a string literal.
        //
        const protocolRex = new RegExp([
            // match either `htps://` or `git@`
            "(?<protocol>(https://|git@))",
            // service is 1 or many (word, dot or dash)
            "(?<service>[\\w.-]+)",
            // match either `/` or `:`
            "(/|:)",
            // org is 1 or many (word, dot or dash)
            "(?<org>[\\w.-]+)",
            "/",
            // repo is 1 or many (word, dot or dash)
            "(?<repo>[\\w.-]+)",
            // branch is 1 or many (word, dot or dash) and can be optional
            "(?<branch>#[\\w./-]+)?",
            // the input string must be consumed fully at this point to match
            "$",
        ].join(""));
        const match = url.match(protocolRex);
        if (match) {
            const { groups } = match;
            const branch = groups["branch"] || "";
            if (invalidBranch.test(branch)) {
                debug({
                    in: url,
                    error: "InvalidFormat (protocol)",
                    hint: "branch is malformed",
                });
                throw new Error("Box specified with invalid format (git/https)");
            }
            const repo = groups["repo"].replace(/\.git$/i, "");
            const result = `https://${groups["service"]}:${groups["org"]}/${repo}${branch}`;
            debug({ in: url, out: result });
            return result;
        }
        debug({
            in: url,
            error: "InvalidFormat (protocol)",
            hint: "did not match protocol",
        });
        throw new Error("Box specified with invalid format (git/https)");
    }
    // default case: process [org/] + repo + [ #branch/name/with/slashes ]
    //
    const orgRepoBranchRex = new RegExp([
        // start match at beginning
        "^",
        // org is 1 or many (word, dot or dash) followed by a slash. org can be
        // optional
        "(?<org>[\\w.-]+/)?",
        // repo is 1 or many (word, dot or dash)
        "(?<repo>[\\w.-]+)",
        // optional branch (undefined if unmatched)
        "(?<branch>#[\\w./-]+)?",
        "$",
    ].join(""));
    const match = url.match(orgRepoBranchRex);
    if (match) {
        const { groups } = match;
        // `truffle-box` is the default org
        const org = groups["org"] || "truffle-box/";
        const branch = groups["branch"] || "";
        if (invalidBranch.test(branch)) {
            debug({
                in: url,
                error: "InvalidFormat (orgRepoBranch)",
                hint: "branch is malformed",
            });
            throw new Error("Box specified with invalid format");
        }
        let repo = groups["repo"];
        // Official Truffle boxes should have a `-box` suffix
        if (org.toLowerCase().startsWith("truffle-box")) {
            repo = repo.endsWith("-box") ? repo : `${repo}-box`;
        }
        const result = `https://github.com:${org}${repo}${branch}`;
        debug({ in: url, out: result });
        return result;
    }
    // No match, it's an error!
    debug({ in: url, error: "InvalidFormat", hint: "matched nothing" });
    throw new Error("Box specified in invalid format");
};
exports.normalizeSourcePath = normalizeSourcePath;
const parseSandboxOptions = (options) => {
    if (typeof options === "string") {
        // back compatibility for when `options` used to be `name`
        return {
            name: options,
            unsafeCleanup: false,
            setGracefulCleanup: false,
            logger: console,
            force: false,
        };
    }
    else if (typeof options === "object") {
        return {
            name: options.name || "default",
            unsafeCleanup: options.unsafeCleanup || false,
            setGracefulCleanup: options.setGracefulCleanup || false,
            logger: options.logger || console,
            force: options.force || false,
        };
    }
};
const Box = {
    unbox: (url, destination, options = {}, config) => __awaiter(void 0, void 0, void 0, function* () {
        const { events } = config;
        let tempDirCleanup;
        const logger = options.logger || { log: () => { } };
        const unpackBoxOptions = {
            logger: options.logger,
            force: options.force,
        };
        try {
            const normalizedSourcePath = exports.normalizeSourcePath(url);
            yield Box.checkDir(options, destination);
            const tempDir = utils_1.default.setUpTempDirectory(events);
            const tempDirPath = tempDir.path;
            tempDirCleanup = tempDir.cleanupCallback;
            yield utils_1.default.downloadBox(normalizedSourcePath, tempDirPath, events);
            const boxConfig = yield utils_1.default.readBoxConfig(tempDirPath);
            yield utils_1.default.unpackBox(tempDirPath, destination, boxConfig, unpackBoxOptions);
            events.emit("unbox:cleaningTempFiles:start");
            tempDirCleanup();
            events.emit("unbox:cleaningTempFiles:succeed");
            utils_1.default.setUpBox(boxConfig, destination, events);
            return boxConfig;
        }
        catch (error) {
            if (tempDirCleanup)
                tempDirCleanup();
            events.emit("unbox:fail");
            throw error;
        }
    }),
    checkDir: (options = {}, destination) => __awaiter(void 0, void 0, void 0, function* () {
        let logger = options.logger || console;
        if (!options.force) {
            const unboxDir = fs_extra_1.default.readdirSync(destination);
            if (unboxDir.length) {
                logger.log(`This directory is non-empty...`);
                const prompt = [
                    {
                        type: "confirm",
                        name: "proceed",
                        message: `Proceed anyway?`,
                        default: true,
                    },
                ];
                const answer = yield inquirer_1.default.prompt(prompt);
                if (!answer.proceed) {
                    logger.log("Unbox cancelled");
                    process.exit();
                }
            }
        }
    }),
    // options.unsafeCleanup
    //   Recursively removes the created temporary directory, even when it's not empty. default is false
    // options.setGracefulCleanup
    //   Cleanup temporary files even when an uncaught exception occurs
    sandbox: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, unsafeCleanup, setGracefulCleanup, logger, force, } = parseSandboxOptions(options);
        const boxPath = name.replace(/^default(?=#|$)/, defaultPath);
        //ordinarily, this line will have no effect.  however, if the name is "default",
        //possibly with a branch specification, this replaces it appropriately
        //(this is necessary in order to keep using trufflesuite/truffle-init-default
        //instead of truffle-box/etc)
        if (setGracefulCleanup)
            tmp_1.default.setGracefulCleanup();
        let config = new config_1.default();
        const tmpDir = tmp_1.default.dirSync({ unsafeCleanup });
        const unboxOptions = { logger, force };
        yield Box.unbox(boxPath, tmpDir.name, unboxOptions, config);
        return config_1.default.load(path_1.default.join(tmpDir.name, "truffle-config.js"), {});
    }),
};
exports["default"] = Box;
//# sourceMappingURL=box.js.map

/***/ }),

/***/ 77220:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
function setDefaults(config = {}) {
    const hooks = config.hooks || {};
    return {
        ignore: config.ignore || [],
        commands: config.commands || {
            compile: "truffle compile",
            migrate: "truffle migrate",
            test: "truffle test"
        },
        hooks: {
            "post-unpack": hooks["post-unpack"] || ""
        }
    };
}
function read(path) {
    return fs_extra_1.default
        .readFile(path)
        .catch(() => "{}")
        .then(JSON.parse)
        .then(setDefaults);
}
module.exports = {
    read,
    setDefaults
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 326086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(__webpack_require__(91104));
const fs_1 = __importDefault(__webpack_require__(657147));
const config_1 = __importDefault(__webpack_require__(77220));
const tmp_1 = __importDefault(__webpack_require__(336276));
const path_1 = __importDefault(__webpack_require__(371017));
module.exports = {
    downloadBox: (source, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        yield unbox_1.default.verifySourcePath(source);
        yield unbox_1.default.fetchRepository(source, destination);
        events.emit("unbox:downloadingBox:succeed");
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            unsafeCleanup: true
        };
        const tmpDir = tmp_1.default.dirSync(options);
        events.emit("unbox:preparingToDownload:succeed");
        return {
            path: path_1.default.join(tmpDir.name, "box"),
            cleanupCallback: tmpDir.removeCallback
        };
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        unbox_1.default.installBoxDependencies(boxConfig, destination);
        events.emit("unbox:settingUpBox:succeed");
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(655674));
const path_1 = __importDefault(__webpack_require__(371017));
const download_git_repo_1 = __importDefault(__webpack_require__(120448));
const axios_1 = __importDefault(__webpack_require__(409669));
const vcsurl_1 = __importDefault(__webpack_require__(309627));
const url_1 = __webpack_require__(257310);
const child_process_1 = __webpack_require__(532081);
const inquirer_1 = __importDefault(__webpack_require__(496062));
const util_1 = __webpack_require__(473837);
const ignore_1 = __importDefault(__webpack_require__(754877));
function verifyLocalPath(localPath) {
    const configPath = path_1.default.join(localPath, "truffle-box.json");
    fs_extra_1.default.access(configPath).catch(_e => {
        throw new Error(`Truffle Box at path ${localPath} doesn't exist.`);
    });
}
function verifyVCSURL(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Next let's see if the expected repository exists. If it doesn't, ghdownload
        // will fail spectacularly in a way we can't catch, so we have to do it ourselves.
        const configURL = url_1.parse(`${vcsurl_1.default(url)
            .replace("github.com", "raw.githubusercontent.com")
            .replace(/#.*/, "")}/master/truffle-box.json`);
        const repoUrl = `https://${configURL.host}${configURL.path}`;
        try {
            yield axios_1.default.head(repoUrl, { maxRedirects: 50 });
        }
        catch (error) {
            if (error.response && error.response.status === 404) {
                throw new Error(`Truffle Box at URL ${url} doesn't exist. If you believe this is an error, please contact Truffle support.`);
            }
            else {
                const prefix = `Error connecting to ${repoUrl}. Please check your internet connection and try again.`;
                error.message = `${prefix}\n\n${error.message || ''}`;
                throw error;
            }
        }
    });
}
function verifySourcePath(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            return verifyLocalPath(sourcePath);
        }
        return verifyVCSURL(sourcePath);
    });
}
function gitIgnoreFilter(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreFilter = ignore_1.default();
        try {
            const gitIgnore = yield fs_extra_1.default.readFile(path_1.default.join(sourcePath, ".gitignore"), "utf8");
            ignoreFilter.add(gitIgnore.split(/\r?\n/).map(p => p.replace(/\/$/, "")));
        }
        catch (err) { }
        return ignoreFilter;
    });
}
function fetchRepository(sourcePath, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            const filter = yield gitIgnoreFilter(sourcePath);
            return fs_extra_1.default.copy(sourcePath, dir, {
                filter: file => sourcePath === file || !filter.ignores(path_1.default.relative(sourcePath, file))
            });
        }
        return util_1.promisify(download_git_repo_1.default)(sourcePath, dir);
    });
}
function prepareToCopyFiles(tempDir, { ignore }) {
    const needingRemoval = ignore;
    // remove box config file
    needingRemoval.push("truffle-box.json");
    needingRemoval.push("truffle-init.json");
    needingRemoval
        .map((fileName) => path_1.default.join(tempDir, fileName))
        .forEach((filePath) => fs_extra_1.default.removeSync(filePath));
}
function promptOverwrites(contentCollisions, logger = console) {
    return __awaiter(this, void 0, void 0, function* () {
        const overwriteContents = [];
        for (const file of contentCollisions) {
            logger.log(`${file} already exists in this directory...`);
            const overwriting = [
                {
                    type: "confirm",
                    name: "overwrite",
                    message: `Overwrite ${file}?`,
                    default: false
                }
            ];
            const { overwrite } = yield inquirer_1.default.prompt(overwriting);
            if (overwrite) {
                fs_extra_1.default.removeSync(file);
                overwriteContents.push(file);
            }
        }
        return overwriteContents;
    });
}
function copyTempIntoDestination(tmpDir, destination, options) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(destination);
        const { force, logger } = options;
        const boxContents = fs_extra_1.default.readdirSync(tmpDir);
        const destinationContents = fs_extra_1.default.readdirSync(destination);
        const newContents = boxContents.filter(filename => !destinationContents.includes(filename));
        const contentCollisions = boxContents.filter(filename => destinationContents.includes(filename));
        let shouldCopy;
        if (force) {
            shouldCopy = boxContents;
        }
        else {
            const overwriteContents = yield promptOverwrites(contentCollisions, logger);
            shouldCopy = [...newContents, ...overwriteContents];
        }
        for (const file of shouldCopy) {
            fs_extra_1.default.copySync(`${tmpDir}/${file}`, `${destination}/${file}`);
        }
    });
}
function installBoxDependencies({ hooks }, destination) {
    const postUnpack = hooks["post-unpack"];
    if (postUnpack.length === 0)
        return;
    child_process_1.execSync(postUnpack, { cwd: destination });
}
module.exports = {
    copyTempIntoDestination,
    fetchRepository,
    installBoxDependencies,
    prepareToCopyFiles,
    verifySourcePath,
    verifyVCSURL
};
//# sourceMappingURL=unbox.js.map

/***/ }),

/***/ 518727:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 518727;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 921077:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 921077;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 457372:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 457372;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 826503:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 826503;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 396524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBus = void 0;
const delay_1 = __importDefault(__webpack_require__(465780));
const events_1 = __webpack_require__(582361);
const utils_1 = __webpack_require__(944794);
const util_1 = __webpack_require__(473837);
class DashboardMessageBus extends events_1.EventEmitter {
    constructor(publishPort, subscribePort, host = "localhost") {
        super();
        this.publishPort = publishPort;
        this.subscribePort = subscribePort;
        this.host = host;
        this.publishers = [];
        this.subscribers = [];
        this.unfulfilledRequests = new Map([]);
    }
    /**
     * Start the DashboardMessageBus
     * @dev This starts separate websocket servers for subscribers/publishers
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscribeServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.subscribePort
            });
            this.subscribeServer.on("connection", (newSubscriber) => {
                newSubscriber.on("close", () => {
                    this.removeSubscriber(newSubscriber);
                });
                // Require the subscriber to send a message *first* before being added
                newSubscriber.once("message", () => this.addSubscriber(newSubscriber));
            });
            this.publishServer = yield utils_1.startWebSocketServer({
                host: this.host,
                port: this.publishPort
            });
            this.publishServer.on("connection", (newPublisher) => {
                newPublisher.on("close", () => {
                    this.removePublisher(newPublisher);
                });
                this.addPublisher(newPublisher);
            });
        });
    }
    /**
     * Wait for the message bus to be "ready" to process requests (i.e. having any subscribers).
     * @dev Polls every second to see if the number of subscribers > 0
     */
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.subscribers.length === 0) {
                yield delay_1.default(1000);
            }
        });
    }
    /**
     * Close both websocket servers
     * @dev Emits a "terminate" event
     */
    terminate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.promisify(this.publishServer.close.bind(this.publishServer))();
            yield util_1.promisify(this.subscribeServer.close.bind(this.subscribeServer))();
            this.emit("terminate");
        });
    }
    /**
     * Process a message `data` coming from `publisher` by sending it to `subscribers`
     * and return the first received response to the `publisher`
     */
    processRequest(publisher, data, subscribers) {
        return __awaiter(this, void 0, void 0, function* () {
            // convert to string for uniformity since WebSocket.Data can take other forms
            if (typeof data !== "string") {
                data = data.toString();
            }
            yield this.ready();
            this.unfulfilledRequests.set(data, { publisher, data });
            const message = utils_1.base64ToJson(data);
            try {
                this.logToPublishers(`Sending message to ${subscribers.length} subscribers`, "requests");
                this.logToPublishers(message, "requests");
                const response = yield utils_1.broadcastAndAwaitFirst(subscribers, message);
                this.logToPublishers(`Sending response for message ${message.id}`, "responses");
                this.logToPublishers(response, "responses");
                const encodedResponse = utils_1.jsonToBase64(response);
                publisher.send(encodedResponse);
                this.unfulfilledRequests.delete(data);
                this.invalidateMessage(message.id);
            }
            catch (error) {
                this.logToPublishers(`An error occurred while processing message ${message.id}`, "errors");
                this.logToPublishers(error, "errors");
            }
        });
    }
    invalidateMessage(id) {
        const invalidationMessage = utils_1.createMessage("invalidate", id);
        utils_1.broadcastAndDisregard(this.subscribers, invalidationMessage);
    }
    logToPublishers(logMessage, namespace) {
        this.logTo(logMessage, this.publishers, namespace);
    }
    logToSubscribers(logMessage, namespace) {
        this.logTo(logMessage, this.subscribers, namespace);
    }
    logToAll(logMessage, namespace) {
        this.logToPublishers(logMessage, namespace);
        this.logToSubscribers(logMessage, namespace);
    }
    logTo(logMessage, receivers, namespace) {
        const payload = {
            namespace: "dashboard-message-bus",
            message: logMessage
        };
        if (namespace) {
            payload.namespace += `:${namespace}`;
        }
        const message = utils_1.createMessage("log", payload);
        utils_1.broadcastAndDisregard(receivers, message);
    }
    /**
     * Add a publisher so it can be used to send requests to
     * @dev Also sends all backlogged (unfulfilled) requests upon connection
     */
    addSubscriber(newSubscriber) {
        this.unfulfilledRequests.forEach(({ publisher, data }) => this.processRequest(publisher, data, [newSubscriber]));
        this.logToPublishers("Subscriber connected", "connections");
        this.subscribers.push(newSubscriber);
    }
    /**
     * Remove a subscriber
     * @dev Will cause the server to terminate if this was the last connection
     */
    removeSubscriber(subscriberToRemove) {
        this.logToPublishers("Subscriber disconnected", "connections");
        this.subscribers = this.subscribers.filter(subscriber => subscriber !== subscriberToRemove);
        this.terminateIfNoConnections();
    }
    /**
     * Add a publisher and set up message listeners to process their requests
     */
    addPublisher(newPublisher) {
        this.logToPublishers("Publisher connected", "connections");
        newPublisher.on("message", (data) => {
            this.processRequest(newPublisher, data, this.subscribers);
        });
        this.publishers.push(newPublisher);
    }
    /**
     * Remove a publisher and their corresponding requests
     * @dev Will cause the server to terminate if this was the last connection
     */
    removePublisher(publisherToRemove) {
        this.logToPublishers("Publisher disconnected", "connections");
        this.publishers = this.publishers.filter(publisher => publisher !== publisherToRemove);
        this.clearRequestsForPublisher(publisherToRemove);
        this.terminateIfNoConnections();
    }
    terminateIfNoConnections() {
        if (this.publishers.length === 0 && this.subscribers.length === 0) {
            this.terminate();
        }
    }
    clearRequestsForPublisher(publisher) {
        this.unfulfilledRequests.forEach(({ publisher: requestPublisher }, key) => {
            if (requestPublisher === publisher) {
                this.unfulfilledRequests.delete(key);
            }
        });
    }
}
exports.DashboardMessageBus = DashboardMessageBus;
//# sourceMappingURL=DashboardMessageBus.js.map

/***/ }),

/***/ 737108:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(396524), exports);
__exportStar(__webpack_require__(944794), exports);
__exportStar(__webpack_require__(136167), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 431482:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isInvalidateMessage = exports.isLogMessage = exports.isDashboardProviderMessage = void 0;
const isDashboardProviderMessage = (message) => {
    return message.type === "provider";
};
exports.isDashboardProviderMessage = isDashboardProviderMessage;
const isLogMessage = (message) => {
    return message.type === "log";
};
exports.isLogMessage = isLogMessage;
const isInvalidateMessage = (message) => {
    return message.type === "invalidate";
};
exports.isInvalidateMessage = isInvalidateMessage;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 136167:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(431482), exports);
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 944794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMessageBusPorts = exports.connectToMessageBus = exports.connectToMessageBusWithRetries = exports.sendAndAwait = exports.broadcastAndAwaitFirst = exports.broadcastAndDisregard = exports.createMessage = exports.startWebSocketServer = exports.base64ToJson = exports.jsonToBase64 = void 0;
const isomorphic_ws_1 = __importDefault(__webpack_require__(347030));
const promise_any_1 = __importDefault(__webpack_require__(625795));
const delay_1 = __importDefault(__webpack_require__(465780));
const axios_1 = __importDefault(__webpack_require__(409669));
promise_any_1.default.shim();
/**
 * Convert any JS object or value to a base64 representation of it
 */
const jsonToBase64 = (json) => {
    const stringifiedJson = JSON.stringify(json);
    const buffer = Buffer.from(stringifiedJson);
    const base64 = buffer.toString("base64");
    return base64;
};
exports.jsonToBase64 = jsonToBase64;
/**
 * Convert the base64 representation of a JS object or value to its JS representation
 * @dev This is the reverse of `jsonToBase64` and is not expected to work with other base64 formats
 */
const base64ToJson = (base64) => {
    const buffer = Buffer.from(base64, "base64");
    const stringifiedJson = buffer.toString("utf8");
    const json = JSON.parse(stringifiedJson);
    return json;
};
exports.base64ToJson = base64ToJson;
/**
 * Starts a websocket server and waits for it to be opened
 * @dev If you need to attach event listeners *before* the server connection opens,
 * do not use this function since it resolves *after* the connection is opened
 */
const startWebSocketServer = (options) => {
    return new Promise(resolve => {
        const server = new isomorphic_ws_1.default.Server(options, () => resolve(server));
    });
};
exports.startWebSocketServer = startWebSocketServer;
const createMessage = (type, payload) => {
    const id = Math.random();
    return { id, type, payload };
};
exports.createMessage = createMessage;
/**
 * Broadcast a message to multiple websocket connections and disregard them
 */
const broadcastAndDisregard = (sockets, message) => {
    const encodedMessage = exports.jsonToBase64(message);
    sockets.forEach(socket => {
        socket.send(encodedMessage);
    });
};
exports.broadcastAndDisregard = broadcastAndDisregard;
/**
 * Broadcast a message to multuple websocket connections and return the first response
 */
const broadcastAndAwaitFirst = (sockets, message) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = sockets.map(socket => exports.sendAndAwait(socket, message));
    const result = yield Promise.any(promises);
    return result;
});
exports.broadcastAndAwaitFirst = broadcastAndAwaitFirst;
/**
 * Send a message to a websocket connection and await a matching response
 * @dev Responses are matched by looking at received messages that match the ID of the sent message
 */
const sendAndAwait = (socket, message) => {
    return new Promise((resolve, reject) => {
        socket.addEventListener("message", (event) => {
            if (typeof event.data !== "string") {
                event.data = event.data.toString();
            }
            const response = exports.base64ToJson(event.data);
            if (response.id !== message.id)
                return;
            resolve(response);
        });
        // TODO: Need to check that the error corresponds to the sent message?
        socket.addEventListener("error", (event) => {
            reject(event.error);
        });
        socket.addEventListener("close", (event) => {
            reject(new Error(`Socket connection closed with code '${event.code}' and reason '${event.reason}'`));
        });
        const encodedMessage = exports.jsonToBase64(message);
        socket.send(encodedMessage);
    });
};
exports.sendAndAwait = sendAndAwait;
const connectToMessageBusWithRetries = (port, host = "localhost", retries = 50) => __awaiter(void 0, void 0, void 0, function* () {
    let error = new Error();
    for (let tryCount = 0; tryCount < retries; tryCount += 1) {
        try {
            return yield exports.connectToMessageBus(port, host);
        }
        catch (e) {
            error = e;
            yield delay_1.default(1000);
        }
    }
    throw error;
});
exports.connectToMessageBusWithRetries = connectToMessageBusWithRetries;
const connectToMessageBus = (port, host = "localhost") => {
    const socket = new isomorphic_ws_1.default(`ws://${host}:${port}`);
    return new Promise((resolve, reject) => {
        socket.addEventListener("open", () => resolve(socket));
        socket.addEventListener("error", (event) => reject(event.error));
    });
};
exports.connectToMessageBus = connectToMessageBus;
const getMessageBusPorts = (dashboardPort, dashboardHost = "localhost", retries = 5) => __awaiter(void 0, void 0, void 0, function* () {
    for (let tryCount = 0; tryCount < retries; tryCount += 1) {
        try {
            const { data } = yield axios_1.default.get(`http://${dashboardHost}:${dashboardPort}/ports`);
            return data;
        }
        catch (e) {
            yield delay_1.default(1000);
        }
    }
    throw new Error(`Could not connect to dashboard at http://${dashboardHost}:${dashboardPort}/ports`);
});
exports.getMessageBusPorts = getMessageBusPorts;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 866205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardServer = void 0;
const express_1 = __importDefault(__webpack_require__(999268));
const path_1 = __importDefault(__webpack_require__(371017));
const get_port_1 = __importDefault(__webpack_require__(715959));
const open_1 = __importDefault(__webpack_require__(678318));
const dashboard_message_bus_1 = __webpack_require__(737108);
const cors_1 = __importDefault(__webpack_require__(917846));
const debug_1 = __importDefault(__webpack_require__(791258));
class DashboardServer {
    constructor(options) {
        var _a, _b, _c, _d;
        this.port = options.port;
        this.host = (_a = options.host) !== null && _a !== void 0 ? _a : "localhost";
        this.rpc = (_b = options.rpc) !== null && _b !== void 0 ? _b : true;
        this.verbose = (_c = options.verbose) !== null && _c !== void 0 ? _c : false;
        this.autoOpen = (_d = options.autoOpen) !== null && _d !== void 0 ? _d : true;
        this.frontendPath = path_1.default.join(__dirname, ".", "dashboard-frontend", "build");
        this.boundTerminateListener = () => this.stop();
    }
    start() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.listening)
                return;
            this.messageBus = yield this.startMessageBus();
            this.expressApp = express_1.default();
            this.expressApp.use(cors_1.default());
            this.expressApp.use(express_1.default.json());
            this.expressApp.use(express_1.default.static(this.frontendPath));
            this.expressApp.get("/ports", this.getPorts.bind(this));
            if (this.rpc) {
                this.socket = yield this.connectToMessageBus();
                this.expressApp.post("/rpc", this.postRpc.bind(this));
            }
            yield new Promise(resolve => {
                this.httpServer = this.expressApp.listen(this.port, this.host, () => {
                    if (this.autoOpen) {
                        const host = this.host === "0.0.0.0" ? "localhost" : this.host;
                        open_1.default(`http://${host}:${this.port}`);
                    }
                    resolve();
                });
            });
        });
    }
    stop() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.off("terminate", this.boundTerminateListener);
            yield ((_b = this.messageBus) === null || _b === void 0 ? void 0 : _b.terminate());
            (_c = this.socket) === null || _c === void 0 ? void 0 : _c.terminate();
            return new Promise(resolve => {
                var _a;
                (_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.close(() => resolve());
            });
        });
    }
    getPorts(req, res) {
        if (!this.messageBus) {
            throw new Error("Message bus has not been started yet");
        }
        res.json({
            dashboardPort: this.port,
            subscribePort: this.messageBus.subscribePort,
            publishPort: this.messageBus.publishPort
        });
    }
    postRpc(req, res, next) {
        if (!this.socket) {
            throw new Error("Not connected to message bus");
        }
        const message = dashboard_message_bus_1.createMessage("provider", req.body);
        dashboard_message_bus_1.sendAndAwait(this.socket, message)
            .then(response => res.json(response.payload))
            .catch(next);
    }
    startMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            const messageBusPublishPort = yield get_port_1.default({ host: this.host });
            const messageBusSubscribePort = yield get_port_1.default({ host: this.host });
            const messageBus = new dashboard_message_bus_1.DashboardMessageBus(messageBusPublishPort, messageBusSubscribePort, this.host);
            yield messageBus.start();
            messageBus.on("terminate", this.boundTerminateListener);
            return messageBus;
        });
    }
    connectToMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.messageBus) {
                throw new Error("Message bus has not been started yet");
            }
            const socket = yield dashboard_message_bus_1.connectToMessageBusWithRetries(this.messageBus.publishPort, this.host);
            if (this.verbose) {
                socket.addEventListener("message", (event) => {
                    if (typeof event.data !== "string") {
                        event.data = event.data.toString();
                    }
                    const message = dashboard_message_bus_1.base64ToJson(event.data);
                    if (message.type === "log") {
                        const logMessage = message;
                        const debug = debug_1.default(logMessage.payload.namespace);
                        debug.enabled = true;
                        debug(logMessage.payload.message);
                    }
                });
            }
            return socket;
        });
    }
}
exports.DashboardServer = DashboardServer;
//# sourceMappingURL=DashboardServer.js.map

/***/ }),

/***/ 897722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(866205), exports);
__exportStar(__webpack_require__(732550), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 732550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startDashboardInBackground = void 0;
const dashboard_message_bus_1 = __webpack_require__(737108);
const child_process_1 = __webpack_require__(532081);
const path_1 = __importDefault(__webpack_require__(371017));
const startDashboardInBackground = (options) => {
    const dashboardPath = path_1.default.join(__dirname, "..", "bin", "start-dashboard");
    const optionsBase64 = dashboard_message_bus_1.jsonToBase64(options);
    const child = child_process_1.spawn("node", [dashboardPath, optionsBase64], {
        detached: true,
        stdio: "ignore"
    });
    return child;
};
exports.startDashboardInBackground = startDashboardInBackground;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 495183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugin = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
const path_1 = __importDefault(__webpack_require__(371017));
class Plugin {
    constructor({ module, definition }) {
        this.module = module;
        this.definition = definition;
    }
    /*
     * `truffle run` support
     */
    get commands() {
        return Object.keys(this.definition.commands || {});
    }
    definesCommand(commandName) {
        return this.commands.includes(commandName);
    }
    loadCommand(commandName) {
        const commandLocalPath = this.definition.commands && this.definition.commands[commandName];
        if (!commandLocalPath) {
            throw new TruffleError(`Plugin ${this.module} does not define command ${commandName}`);
        }
        return this.loadModule(commandLocalPath);
    }
    /*
     * `truffle preserve` support
     */
    get tag() {
        return this.definition.tag;
    }
    definesRecipe() {
        return !!(this.definition.preserve && this.definition.preserve.recipe);
    }
    loadRecipe() {
        if (!this.definesRecipe()) {
            throw new TruffleError(`Plugin ${this.module} does not define a \`truffle preserve\` recipe.`);
        }
        return this.loadModule(this.definition.preserve.recipe).Recipe;
    }
    loadModule(localPath) {
        if (path_1.default.isAbsolute(localPath)) {
            throw new TruffleError(`\nError: Absolute paths not allowed!\nPlease ensure truffle-plugin.json only references paths relative to the plugin root.\n`);
        }
        const pluginPath = originalRequire.resolve(this.module);
        const modulePath = path_1.default.resolve(path_1.default.dirname(pluginPath), localPath);
        return originalRequire(modulePath);
    }
}
exports.Plugin = Plugin;
//# sourceMappingURL=Plugin.js.map

/***/ }),

/***/ 108097:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugins = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
const path_1 = __importDefault(__webpack_require__(371017));
const Plugin_1 = __webpack_require__(495183);
const utils_1 = __webpack_require__(436025);
class Plugins {
    /**
     * Given a truffle-config-like, find and return all configured plugins
     */
    static listAll(config) {
        const plugins = Plugins.checkPluginModules(config);
        const definitions = Plugins.loadPluginDefinitions(plugins);
        return Object.entries(definitions).map(([module, definition]) => new Plugin_1.Plugin({ module, definition }));
    }
    /**
     * Given a truffle-config-like and command, find and return all plugins that define the command
     */
    static findPluginsForCommand(config, command) {
        const allPlugins = Plugins.listAll(config);
        const pluginsForCommand = allPlugins.filter(plugin => plugin.definesCommand(command));
        return pluginsForCommand;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define any command
     */
    static listAllCommandPlugins(config) {
        const allPlugins = Plugins.listAll(config);
        const pluginsWithCommands = allPlugins.filter(plugin => plugin.commands.length > 0);
        return pluginsWithCommands;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define a recipe
     */
    static listAllRecipes(config) {
        const allPlugins = Plugins.listAll(config);
        const recipes = allPlugins.filter(plugin => plugin.definesRecipe());
        return recipes;
    }
    /*
     * internals
     */
    static checkPluginModules(config) {
        originalRequire("app-module-path").addPath(path_1.default.resolve(config.working_directory, "node_modules"));
        const plugins = utils_1.normalizeConfigPlugins(config.plugins || []);
        return plugins;
    }
    static loadPluginDefinitions(plugins) {
        let pluginConfigs = {};
        for (const { module, tag } of plugins) {
            try {
                const required = originalRequire(`${module}/truffle-plugin.json`);
                const defaultTag = required.preserve && required.preserve.tag;
                required.tag = tag || defaultTag || undefined;
                pluginConfigs[module] = required;
            }
            catch (_) {
                throw new TruffleError(`\nError: truffle-plugin.json not found in the ${module} plugin package!\n`);
            }
        }
        return pluginConfigs;
    }
}
exports.Plugins = Plugins;
//# sourceMappingURL=Plugins.js.map

/***/ }),

/***/ 342113:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(849094), exports);
__exportStar(__webpack_require__(495183), exports);
__exportStar(__webpack_require__(108097), exports);
__exportStar(__webpack_require__(436025), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 849094:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 436025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeConfigPlugins = exports.resolves = void 0;
const TruffleError = __webpack_require__(673321);
const originalRequire = __webpack_require__(344516);
/**
 * Returns true or false based on whether or not a particular plugin
 * resolves successfully
 */
const resolves = (module) => {
    try {
        originalRequire.resolve(module);
        return true;
    }
    catch (_) {
        return false;
    }
};
exports.resolves = resolves;
/**
 * Takes a list of raw plugin configurations and returns a list of normalized
 * internal representations
 */
const normalizeConfigPlugins = (plugins) => {
    const map = new Map([]);
    const normalized = plugins.map((plugin) => typeof plugin === "string" ? { module: plugin } : plugin);
    for (const plugin of normalized) {
        // fatal error if we can't load a plugin listed in truffle-config.js
        if (!exports.resolves(plugin.module)) {
            throw new TruffleError(`\nError: ${plugin.module} listed as a plugin, but not found in global or local node modules!\n`);
        }
        map.set(plugin.module, plugin);
    }
    return [...map.values()];
};
exports.normalizeConfigPlugins = normalizeConfigPlugins;
//# sourceMappingURL=utils.js.map

/***/ })

};
;
//# sourceMappingURL=486.bundled.js.map